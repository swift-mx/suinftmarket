import { Provider } from './provider';
import { HttpHeaders, JsonRpcClient } from '../rpc/client';
import { ExecuteTransactionRequestType, GatewayTxSeqNumber, GetTxnDigestsResponse, ObjectId, PaginatedTransactionDigests, SubscriptionId, SuiAddress, SuiEventEnvelope, SuiEventFilter, SuiExecuteTransactionResponse, SuiMoveFunctionArgTypes, SuiMoveNormalizedFunction, SuiMoveNormalizedModule, SuiMoveNormalizedModules, SuiMoveNormalizedStruct, SuiObjectInfo, SuiObjectRef, SuiTransactionResponse, TransactionDigest, TransactionQuery, RpcApiVersion, EventQuery, EventId, PaginatedEvents, FaucetResponse, Order, TransactionEffects, DevInspectResults, CoinMetadata, PaginatedCoins, GetObjectDataResponse, DelegatedStake, ValidatorMetaData, SuiSystemState, CoinBalance, CoinSupply, CheckpointSummary, CheckpointContents, CheckpointDigest, CheckPointContentsDigest, CommitteeInfo } from '../types';
import { DynamicFieldName, DynamicFieldPage } from '../types/dynamic_fields';
import { WebsocketClient, WebsocketClientOptions } from '../rpc/websocket-client';
import { UnserializedSignableTransaction } from '../signers/txn-data-serializers/txn-data-serializer';
import { SerializedSignature } from '../cryptography/signature';
import { Connection } from '../rpc/connection';
export declare const TARGETED_RPC_VERSION = "0.27.0";
/**
 * Configuration options for the JsonRpcProvider. If the value of a field is not provided,
 * value in `DEFAULT_OPTIONS` for that field will be used
 */
export type RpcProviderOptions = {
    /**
     * Default to `true`. If set to `false`, the rpc
     * client will throw an error if the responses from the RPC server do not
     * conform to the schema defined in the TypeScript SDK. If set to `true`, the
     * rpc client will log the mismatch as a warning message instead of throwing an
     * error. The mismatches often happen when the SDK is in a different version than
     * the RPC server. Skipping the validation can maximize
     * the version compatibility of the SDK, as not all the schema
     * changes in the RPC response will affect the caller, but the caller needs to
     * understand that the data may not match the TypeSrcript definitions.
     */
    skipDataValidation?: boolean;
    /**
     * Configuration options for the websocket connection
     * TODO: Move to connection.
     */
    socketOptions?: WebsocketClientOptions;
    /**
     * Cache timeout in seconds for the RPC API Version
     */
    versionCacheTimeoutInSeconds?: number;
    /** Allow defining a custom RPC client to use */
    rpcClient?: JsonRpcClient;
    /** Allow defining a custom websocket client to use */
    websocketClient?: WebsocketClient;
};
export declare class JsonRpcProvider extends Provider {
    options: RpcProviderOptions;
    connection: Connection;
    protected client: JsonRpcClient;
    protected wsClient: WebsocketClient;
    private rpcApiVersion;
    private cacheExpiry;
    /**
     * Establish a connection to a Sui RPC endpoint
     *
     * @param connection The `Connection` object containing configuration for the network.
     * @param options configuration options for the provider
     */
    constructor(connection?: Connection, options?: RpcProviderOptions);
    getRpcApiVersion(): Promise<RpcApiVersion | undefined>;
    requestSuiFromFaucet(recipient: SuiAddress, httpHeaders?: HttpHeaders): Promise<FaucetResponse>;
    getCoins(owner: SuiAddress, coinType?: string | null, cursor?: ObjectId | null, limit?: number | null): Promise<PaginatedCoins>;
    getAllCoins(owner: SuiAddress, cursor?: ObjectId | null, limit?: number | null): Promise<PaginatedCoins>;
    getBalance(owner: SuiAddress, coinType?: string | null): Promise<CoinBalance>;
    getAllBalances(owner: SuiAddress): Promise<CoinBalance[]>;
    getCoinMetadata(coinType: string): Promise<CoinMetadata>;
    getTotalSupply(coinType: string): Promise<CoinSupply>;
    call(endpoint: string, params: Array<any>): Promise<any>;
    getMoveFunctionArgTypes(packageId: string, moduleName: string, functionName: string): Promise<SuiMoveFunctionArgTypes>;
    getNormalizedMoveModulesByPackage(packageId: string): Promise<SuiMoveNormalizedModules>;
    getNormalizedMoveModule(packageId: string, moduleName: string): Promise<SuiMoveNormalizedModule>;
    getNormalizedMoveFunction(packageId: string, moduleName: string, functionName: string): Promise<SuiMoveNormalizedFunction>;
    getNormalizedMoveStruct(packageId: string, moduleName: string, structName: string): Promise<SuiMoveNormalizedStruct>;
    getObjectsOwnedByAddress(address: SuiAddress): Promise<SuiObjectInfo[]>;
    getGasObjectsOwnedByAddress(address: SuiAddress): Promise<SuiObjectInfo[]>;
    /**
     * @deprecated The method should not be used
     */
    getCoinBalancesOwnedByAddress(address: SuiAddress, typeArg?: string): Promise<GetObjectDataResponse[]>;
    selectCoinsWithBalanceGreaterThanOrEqual(address: SuiAddress, amount: bigint, typeArg?: string, exclude?: ObjectId[]): Promise<GetObjectDataResponse[]>;
    selectCoinSetWithCombinedBalanceGreaterThanOrEqual(address: SuiAddress, amount: bigint, typeArg?: string, exclude?: ObjectId[]): Promise<GetObjectDataResponse[]>;
    getObject(objectId: ObjectId): Promise<GetObjectDataResponse>;
    getObjectRef(objectId: ObjectId): Promise<SuiObjectRef | undefined>;
    getObjectBatch(objectIds: ObjectId[]): Promise<GetObjectDataResponse[]>;
    getTransactions(query: TransactionQuery, cursor?: TransactionDigest | null, limit?: number | null, order?: Order): Promise<PaginatedTransactionDigests>;
    getTransactionsForObject(objectID: ObjectId, descendingOrder?: boolean): Promise<GetTxnDigestsResponse>;
    getTransactionsForAddress(addressID: SuiAddress, descendingOrder?: boolean): Promise<GetTxnDigestsResponse>;
    getTransactionWithEffects(digest: TransactionDigest): Promise<SuiTransactionResponse>;
    getTransactionWithEffectsBatch(digests: TransactionDigest[]): Promise<SuiTransactionResponse[]>;
    executeTransaction(txnBytes: Uint8Array | string, signature: SerializedSignature, requestType?: ExecuteTransactionRequestType): Promise<SuiExecuteTransactionResponse>;
    getTotalTransactionNumber(): Promise<number>;
    getTransactionDigestsInRange(start: GatewayTxSeqNumber, end: GatewayTxSeqNumber): Promise<GetTxnDigestsResponse>;
    getReferenceGasPrice(): Promise<number>;
    getDelegatedStakes(address: SuiAddress): Promise<DelegatedStake[]>;
    getValidators(): Promise<ValidatorMetaData[]>;
    getSuiSystemState(): Promise<SuiSystemState>;
    getEvents(query: EventQuery, cursor: EventId | null, limit: number | null, order?: Order): Promise<PaginatedEvents>;
    subscribeEvent(filter: SuiEventFilter, onMessage: (event: SuiEventEnvelope) => void): Promise<SubscriptionId>;
    unsubscribeEvent(id: SubscriptionId): Promise<boolean>;
    devInspectTransaction(sender: SuiAddress, tx: UnserializedSignableTransaction | string | Uint8Array, gasPrice?: number | null, epoch?: number | null): Promise<DevInspectResults>;
    dryRunTransaction(txBytes: Uint8Array): Promise<TransactionEffects>;
    getDynamicFields(parent_object_id: ObjectId, cursor?: ObjectId | null, limit?: number | null): Promise<DynamicFieldPage>;
    getDynamicFieldObject(parent_object_id: ObjectId, name: string | DynamicFieldName): Promise<GetObjectDataResponse>;
    getLatestCheckpointSequenceNumber(): Promise<number>;
    getCheckpointSummary(sequence_number: number): Promise<CheckpointSummary>;
    getCheckpointSummaryByDigest(digest: CheckpointDigest): Promise<CheckpointSummary>;
    getCheckpointContents(sequence_number: number | CheckPointContentsDigest): Promise<CheckpointContents>;
    getCheckpointContentsByDigest(digest: CheckPointContentsDigest): Promise<CheckpointContents>;
    getCommitteeInfo(epoch?: number): Promise<CommitteeInfo>;
}
