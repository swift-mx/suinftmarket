"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ADD_DELEGATION_LOCKED_COIN_FUN_NAME: () => ADD_DELEGATION_LOCKED_COIN_FUN_NAME,
  ADD_DELEGATION_MUL_COIN_FUN_NAME: () => ADD_DELEGATION_MUL_COIN_FUN_NAME,
  ActiveDelegationStatus: () => ActiveDelegationStatus,
  ActiveFields: () => ActiveFields,
  AppId: () => AppId,
  AuthorityName: () => AuthorityName,
  AuthorityQuorumSignInfo: () => AuthorityQuorumSignInfo,
  AuthoritySignature: () => AuthoritySignature,
  Balance: () => Balance,
  BalanceChangeType: () => BalanceChangeType,
  COIN_TYPE_ARG_REGEX: () => COIN_TYPE_ARG_REGEX,
  CertifiedTransaction: () => CertifiedTransaction,
  CheckPointContentsDigest: () => CheckPointContentsDigest,
  CheckpointContents: () => CheckpointContents,
  CheckpointDigest: () => CheckpointDigest,
  CheckpointEvent: () => CheckpointEvent,
  CheckpointSummary: () => CheckpointSummary,
  Coin: () => Coin,
  CoinBalance: () => CoinBalance,
  CoinBalanceChangeEvent: () => CoinBalanceChangeEvent,
  CoinMetadataStruct: () => CoinMetadataStruct,
  CoinStruct: () => CoinStruct,
  CoinSupply: () => CoinSupply,
  CommitteeInfo: () => CommitteeInfo,
  Connection: () => Connection,
  Contents: () => Contents,
  ContentsFields: () => ContentsFields,
  ContentsFieldsWithdraw: () => ContentsFieldsWithdraw,
  DEFAULT_CLIENT_OPTIONS: () => DEFAULT_CLIENT_OPTIONS,
  DEFAULT_ED25519_DERIVATION_PATH: () => DEFAULT_ED25519_DERIVATION_PATH,
  DEFAULT_SECP256K1_DERIVATION_PATH: () => DEFAULT_SECP256K1_DERIVATION_PATH,
  DelegatedStake: () => DelegatedStake,
  Delegation: () => Delegation,
  DelegationStakingPool: () => DelegationStakingPool,
  DelegationStakingPoolFields: () => DelegationStakingPoolFields,
  DeleteObjectEvent: () => DeleteObjectEvent,
  DevInspectResults: () => DevInspectResults,
  Ed25519Keypair: () => Ed25519Keypair,
  Ed25519PublicKey: () => Ed25519PublicKey,
  EpochChangeEvent: () => EpochChangeEvent,
  EpochId: () => EpochId,
  ErrorResponse: () => ErrorResponse,
  EventId: () => EventId,
  ExecutionStatus: () => ExecutionStatus,
  ExecutionStatusType: () => ExecutionStatusType,
  FaucetRateLimitError: () => FaucetRateLimitError,
  GasCostSummary: () => GasCostSummary2,
  GenericAuthoritySignature: () => GenericAuthoritySignature,
  Genesis: () => Genesis,
  GetObjectDataResponse: () => GetObjectDataResponse,
  GetOwnedObjectsResponse: () => GetOwnedObjectsResponse,
  GetTxnDigestsResponse: () => GetTxnDigestsResponse,
  ID_STRUCT_NAME: () => ID_STRUCT_NAME,
  IntentScope: () => IntentScope,
  IntentVersion: () => IntentVersion,
  JsonRpcClient: () => JsonRpcClient,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcProviderWithCache: () => JsonRpcProviderWithCache,
  LEGACY_PRIVATE_KEY_SIZE: () => LEGACY_PRIVATE_KEY_SIZE,
  LocalTxnDataSerializer: () => LocalTxnDataSerializer,
  MIST_PER_SUI: () => MIST_PER_SUI,
  MOVE_STDLIB_ADDRESS: () => MOVE_STDLIB_ADDRESS,
  MoveActiveValidator: () => MoveActiveValidator,
  MoveActiveValidatorFields: () => MoveActiveValidatorFields,
  MoveCall: () => MoveCall,
  MoveDelegationStakingPoolFields: () => MoveDelegationStakingPoolFields,
  MoveEvent: () => MoveEvent,
  MoveNextEpochValidatorFields: () => MoveNextEpochValidatorFields,
  MovePackageContent: () => MovePackageContent,
  MoveSuiSystemObject: () => MoveSuiSystemObject,
  MoveSuiSystemObjectFields: () => MoveSuiSystemObjectFields,
  MoveValidatorsFieldsClass: () => MoveValidatorsFieldsClass,
  MutateObjectEvent: () => MutateObjectEvent,
  NewObjectEvent: () => NewObjectEvent,
  OBJECT_MODULE_NAME: () => OBJECT_MODULE_NAME,
  ObjectContentFields: () => ObjectContentFields,
  ObjectId: () => ObjectId,
  ObjectOwner: () => ObjectOwner,
  ObjectStatus: () => ObjectStatus,
  ObjectType: () => ObjectType,
  OwnedObjectRef: () => OwnedObjectRef,
  PAY_JOIN_COIN_FUNC_NAME: () => PAY_JOIN_COIN_FUNC_NAME,
  PAY_MODULE_NAME: () => PAY_MODULE_NAME,
  PAY_SPLIT_COIN_VEC_FUNC_NAME: () => PAY_SPLIT_COIN_VEC_FUNC_NAME,
  PRIVATE_KEY_SIZE: () => PRIVATE_KEY_SIZE,
  PaginatedCoins: () => PaginatedCoins,
  PaginatedEvents: () => PaginatedEvents,
  PaginatedTransactionDigests: () => PaginatedTransactionDigests,
  Parameters: () => Parameters,
  ParametersFields: () => ParametersFields,
  Pay: () => Pay,
  PayAllSui: () => PayAllSui,
  PaySui: () => PaySui,
  PendingWithdawFields: () => PendingWithdawFields,
  Provider: () => Provider,
  PublishEvent: () => PublishEvent,
  RawSigner: () => RawSigner,
  RpcTxnDataSerializer: () => RpcTxnDataSerializer,
  SIGNATURE_FLAG_TO_SCHEME: () => SIGNATURE_FLAG_TO_SCHEME,
  SIGNATURE_SCHEME_TO_FLAG: () => SIGNATURE_SCHEME_TO_FLAG,
  SUI_ADDRESS_LENGTH: () => SUI_ADDRESS_LENGTH,
  SUI_FRAMEWORK_ADDRESS: () => SUI_FRAMEWORK_ADDRESS,
  SUI_SYSTEM_MODULE_NAME: () => SUI_SYSTEM_MODULE_NAME,
  SUI_SYSTEM_STATE_OBJECT_ID: () => SUI_SYSTEM_STATE_OBJECT_ID,
  SUI_TYPE_ARG: () => SUI_TYPE_ARG,
  Secp256k1Keypair: () => Secp256k1Keypair,
  Secp256k1PublicKey: () => Secp256k1PublicKey,
  SequenceNumber: () => SequenceNumber,
  SignerWithProvider: () => SignerWithProvider,
  StakeSubsidy: () => StakeSubsidy,
  StakeSubsidyFields: () => StakeSubsidyFields,
  StakedSui: () => StakedSui,
  SubscriptionEvent: () => SubscriptionEvent,
  SubscriptionId: () => SubscriptionId,
  SuiAddress: () => SuiAddress,
  SuiCertifiedTransactionEffects: () => SuiCertifiedTransactionEffects,
  SuiChangeEpoch: () => SuiChangeEpoch,
  SuiConsensusCommitPrologue: () => SuiConsensusCommitPrologue,
  SuiData: () => SuiData,
  SuiEffectsFinalityInfo: () => SuiEffectsFinalityInfo,
  SuiEvent: () => SuiEvent,
  SuiEventEnvelope: () => SuiEventEnvelope,
  SuiExecuteTransactionResponse: () => SuiExecuteTransactionResponse,
  SuiFinalizedEffects: () => SuiFinalizedEffects,
  SuiGasData: () => SuiGasData,
  SuiJsonValue: () => SuiJsonValue,
  SuiMoveAbilitySet: () => SuiMoveAbilitySet,
  SuiMoveFunctionArgType: () => SuiMoveFunctionArgType,
  SuiMoveFunctionArgTypes: () => SuiMoveFunctionArgTypes,
  SuiMoveModuleId: () => SuiMoveModuleId,
  SuiMoveNormalizedField: () => SuiMoveNormalizedField,
  SuiMoveNormalizedFunction: () => SuiMoveNormalizedFunction,
  SuiMoveNormalizedModule: () => SuiMoveNormalizedModule,
  SuiMoveNormalizedModules: () => SuiMoveNormalizedModules,
  SuiMoveNormalizedStruct: () => SuiMoveNormalizedStruct,
  SuiMoveNormalizedStructType: () => SuiMoveNormalizedStructType,
  SuiMoveNormalizedType: () => SuiMoveNormalizedType,
  SuiMoveNormalizedTypeParameterType: () => SuiMoveNormalizedTypeParameterType,
  SuiMoveObject: () => SuiMoveObject,
  SuiMovePackage: () => SuiMovePackage,
  SuiMoveStructTypeParameter: () => SuiMoveStructTypeParameter,
  SuiMoveVisibility: () => SuiMoveVisibility,
  SuiObject: () => SuiObject,
  SuiObjectInfo: () => SuiObjectInfo,
  SuiObjectRef: () => SuiObjectRef,
  SuiPackage: () => SuiPackage,
  SuiParsedMergeCoinResponse: () => SuiParsedMergeCoinResponse,
  SuiParsedPublishResponse: () => SuiParsedPublishResponse,
  SuiParsedSplitCoinResponse: () => SuiParsedSplitCoinResponse,
  SuiParsedTransactionResponse: () => SuiParsedTransactionResponse,
  SuiSupplyFields: () => SuiSupplyFields,
  SuiSystemState: () => SuiSystemState,
  SuiSystemStateUtil: () => SuiSystemStateUtil,
  SuiTransaction: () => SuiTransaction,
  SuiTransactionData: () => SuiTransactionData,
  SuiTransactionKind: () => SuiTransactionKind,
  SuiTransactionResponse: () => SuiTransactionResponse,
  SuiTransferSui: () => SuiTransferSui,
  SystemParameters: () => SystemParameters,
  TARGETED_RPC_VERSION: () => TARGETED_RPC_VERSION,
  TRANSACTION_DATA_TYPE_TAG: () => TRANSACTION_DATA_TYPE_TAG,
  TransactionBytes: () => TransactionBytes,
  TransactionDigest: () => TransactionDigest,
  TransactionEffects: () => TransactionEffects,
  TransactionEffectsDigest: () => TransactionEffectsDigest,
  TransferObject: () => TransferObject,
  TransferObjectEvent: () => TransferObjectEvent,
  TypeTagSerializer: () => TypeTagSerializer,
  UID_STRUCT_NAME: () => UID_STRUCT_NAME,
  ValidResponse: () => ValidResponse,
  Validator: () => Validator,
  ValidatorMetaData: () => ValidatorMetaData,
  ValidatorPair: () => ValidatorPair,
  ValidatorSet: () => ValidatorSet,
  WITHDRAW_DELEGATION_FUN_NAME: () => WITHDRAW_DELEGATION_FUN_NAME,
  WebsocketClient: () => WebsocketClient,
  assert: () => import_superstruct15.assert,
  bcs: () => bcs,
  bcsForVersion: () => bcsForVersion,
  bytesEqual: () => bytesEqual,
  deserializeTransactionBytesToTransactionData: () => deserializeTransactionBytesToTransactionData,
  devnetConnection: () => devnetConnection,
  extractMutableReference: () => extractMutableReference,
  extractReference: () => extractReference,
  extractStructTag: () => extractStructTag,
  formatAddress: () => formatAddress,
  formatDigest: () => formatDigest,
  fromB64: () => import_bcs16.fromB64,
  fromExportedKeypair: () => fromExportedKeypair,
  fromSerializedSignature: () => fromSerializedSignature,
  generateTransactionDigest: () => generateTransactionDigest,
  getCertifiedTransaction: () => getCertifiedTransaction,
  getChangeEpochTransaction: () => getChangeEpochTransaction,
  getCoinAfterMerge: () => getCoinAfterMerge,
  getCoinAfterSplit: () => getCoinAfterSplit,
  getConsensusCommitPrologueTransaction: () => getConsensusCommitPrologueTransaction,
  getCreatedObjects: () => getCreatedObjects,
  getEvents: () => getEvents,
  getExecutionStatus: () => getExecutionStatus,
  getExecutionStatusError: () => getExecutionStatusError,
  getExecutionStatusGasSummary: () => getExecutionStatusGasSummary,
  getExecutionStatusType: () => getExecutionStatusType,
  getGasData: () => getGasData,
  getMoveCallTransaction: () => getMoveCallTransaction,
  getMoveObject: () => getMoveObject,
  getMoveObjectType: () => getMoveObjectType,
  getMovePackageContent: () => getMovePackageContent,
  getNewlyCreatedCoinRefsAfterSplit: () => getNewlyCreatedCoinRefsAfterSplit,
  getNewlyCreatedCoinsAfterSplit: () => getNewlyCreatedCoinsAfterSplit,
  getObjectDeletedResponse: () => getObjectDeletedResponse,
  getObjectExistsResponse: () => getObjectExistsResponse,
  getObjectFields: () => getObjectFields,
  getObjectId: () => getObjectId,
  getObjectNotExistsResponse: () => getObjectNotExistsResponse,
  getObjectOwner: () => getObjectOwner,
  getObjectPreviousTransactionDigest: () => getObjectPreviousTransactionDigest,
  getObjectReference: () => getObjectReference,
  getObjectType: () => getObjectType,
  getObjectVersion: () => getObjectVersion,
  getParsedMergeCoinResponse: () => getParsedMergeCoinResponse,
  getParsedPublishResponse: () => getParsedPublishResponse,
  getParsedSplitCoinResponse: () => getParsedSplitCoinResponse,
  getPayAllSuiTransaction: () => getPayAllSuiTransaction,
  getPaySuiTransaction: () => getPaySuiTransaction,
  getPayTransaction: () => getPayTransaction,
  getPublishTransaction: () => getPublishTransaction,
  getSharedObjectInitialVersion: () => getSharedObjectInitialVersion,
  getTimestampFromTransactionResponse: () => getTimestampFromTransactionResponse,
  getTotalGasUsed: () => getTotalGasUsed,
  getTotalGasUsedUpperBound: () => getTotalGasUsedUpperBound,
  getTransactionData: () => getTransactionData,
  getTransactionDigest: () => getTransactionDigest,
  getTransactionEffects: () => getTransactionEffects,
  getTransactionGasBudget: () => getTransactionGasBudget,
  getTransactionGasObject: () => getTransactionGasObject,
  getTransactionGasPrice: () => getTransactionGasPrice,
  getTransactionKindName: () => getTransactionKindName,
  getTransactionSender: () => getTransactionSender,
  getTransactionSignature: () => getTransactionSignature,
  getTransactions: () => getTransactions,
  getTransferObjectTransaction: () => getTransferObjectTransaction,
  getTransferSuiAmount: () => getTransferSuiAmount,
  getTransferSuiTransaction: () => getTransferSuiTransaction,
  getWebsocketUrl: () => getWebsocketUrl,
  hasPublicTransfer: () => hasPublicTransfer,
  is: () => import_superstruct15.is,
  isImmutableObject: () => isImmutableObject,
  isPureArg: () => isPureArg,
  isSharedObject: () => isSharedObject,
  isValidBIP32Path: () => isValidBIP32Path,
  isValidHardenedPath: () => isValidHardenedPath,
  isValidSuiAddress: () => isValidSuiAddress,
  isValidSuiObjectId: () => isValidSuiObjectId,
  isValidTransactionDigest: () => isValidTransactionDigest,
  localnetConnection: () => localnetConnection,
  messageWithIntent: () => messageWithIntent,
  mnemonicToSeed: () => mnemonicToSeed,
  mnemonicToSeedHex: () => mnemonicToSeedHex,
  normalizeSuiAddress: () => normalizeSuiAddress,
  normalizeSuiObjectId: () => normalizeSuiObjectId,
  parseVersionFromString: () => parseVersionFromString,
  publicKeyFromSerialized: () => publicKeyFromSerialized,
  requestSuiFromFaucet: () => requestSuiFromFaucet,
  toB64: () => import_bcs16.toB64,
  toSerializedSignature: () => toSerializedSignature,
  verifyMessage: () => verifyMessage,
  versionToString: () => versionToString
});
module.exports = __toCommonJS(src_exports);

// src/cryptography/ed25519-keypair.ts
var import_tweetnacl2 = __toESM(require("tweetnacl"));

// src/cryptography/keypair.ts
var import_bcs6 = require("@mysten/bcs");

// src/cryptography/secp256k1-keypair.ts
var secp = __toESM(require("@noble/secp256k1"));
var import_hmac = require("@noble/hashes/hmac");
var import_sha256 = require("@noble/hashes/sha256");

// src/cryptography/secp256k1-publickey.ts
var import_bcs3 = require("@mysten/bcs");
var import_js_sha32 = __toESM(require("js-sha3"));

// src/cryptography/ed25519-publickey.ts
var import_js_sha3 = __toESM(require("js-sha3"));
var import_bcs2 = require("@mysten/bcs");

// src/cryptography/signature.ts
var import_bcs = require("@mysten/bcs");
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1"
};
function toSerializedSignature({
  signature,
  signatureScheme,
  pubKey
}) {
  const serializedSignature = new Uint8Array(
    1 + signature.length + pubKey.toBytes().length
  );
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKey.toBytes(), 1 + signature.length);
  return (0, import_bcs.toB64)(serializedSignature);
}
function fromSerializedSignature(serializedSignature) {
  const bytes = (0, import_bcs.fromB64)(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  const PublicKey2 = signatureScheme === "ED25519" ? Ed25519PublicKey : Secp256k1PublicKey;
  const signature = bytes.slice(1, bytes.length - PublicKey2.SIZE);
  const pubkeyBytes = bytes.slice(1 + signature.length);
  const pubKey = new PublicKey2(pubkeyBytes);
  return {
    signatureScheme,
    signature,
    pubKey
  };
}

// src/cryptography/ed25519-publickey.ts
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class {
  constructor(value) {
    if (typeof value === "string") {
      this.data = (0, import_bcs2.fromB64)(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  equals(publicKey) {
    return bytesEqual(this.toBytes(), publicKey.toBytes());
  }
  toBase64() {
    return (0, import_bcs2.toB64)(this.toBytes());
  }
  toBytes() {
    return this.data;
  }
  toString() {
    return this.toBase64();
  }
  toSuiAddress() {
    let tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["ED25519"]]);
    tmp.set(this.toBytes(), 1);
    return import_js_sha3.default.sha3_256(tmp).slice(0, 40);
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// src/cryptography/publickey.ts
function bytesEqual(a, b) {
  if (a === b)
    return true;
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function publicKeyFromSerialized(schema, pubKey) {
  if (schema === "ED25519") {
    return new Ed25519PublicKey(pubKey);
  }
  if (schema === "Secp256k1") {
    return new Secp256k1PublicKey(pubKey);
  }
  throw new Error("Unknown public key schema");
}

// src/cryptography/secp256k1-publickey.ts
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class {
  constructor(value) {
    if (typeof value === "string") {
      this.data = (0, import_bcs3.fromB64)(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  equals(publicKey) {
    return bytesEqual(this.toBytes(), publicKey.toBytes());
  }
  toBase64() {
    return (0, import_bcs3.toB64)(this.toBytes());
  }
  toBytes() {
    return this.data;
  }
  toString() {
    return this.toBase64();
  }
  toSuiAddress() {
    let tmp = new Uint8Array(SECP256K1_PUBLIC_KEY_SIZE + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["Secp256k1"]]);
    tmp.set(this.toBytes(), 1);
    return import_js_sha32.default.sha3_256(tmp).slice(0, 40);
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;

// src/cryptography/secp256k1-keypair.ts
var import_secp256k1 = require("@noble/secp256k1");

// src/cryptography/mnemonics.ts
var import_bcs4 = require("@mysten/bcs");
var import_bip39 = require("@scure/bip39");
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function isValidBIP32Path(path) {
  if (!new RegExp("^m\\/54'\\/784'\\/[0-9]+'\\/[0-9]+\\/[0-9]+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return (0, import_bip39.mnemonicToSeedSync)(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return (0, import_bcs4.toHEX)(mnemonicToSeed(mnemonics));
}

// src/cryptography/secp256k1-keypair.ts
var import_bip32 = require("@scure/bip32");
var import_bcs5 = require("@mysten/bcs");
var DEFAULT_SECP256K1_DERIVATION_PATH = "m/54'/784'/0'/0/0";
secp.utils.hmacSha256Sync = (key, ...msgs) => {
  const h = import_hmac.hmac.create(import_sha256.sha256, key);
  msgs.forEach((msg) => h.update(msg));
  return h.digest();
};
var Secp256k1Keypair = class {
  constructor(keypair) {
    if (keypair) {
      this.keypair = keypair;
    } else {
      const secretKey = secp.utils.randomPrivateKey();
      const publicKey = secp.getPublicKey(secretKey, true);
      this.keypair = { publicKey, secretKey };
    }
  }
  getKeyScheme() {
    return "Secp256k1";
  }
  static generate() {
    const secretKey = secp.utils.randomPrivateKey();
    const publicKey = secp.getPublicKey(secretKey, true);
    return new Secp256k1Keypair({ publicKey, secretKey });
  }
  static fromSecretKey(secretKey, options) {
    const publicKey = secp.getPublicKey(secretKey, true);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const msgHash = (0, import_sha256.sha256)(signData);
      const signature = secp.signSync(msgHash, secretKey);
      if (!secp.verify(signature, msgHash, publicKey, { strict: true })) {
        throw new Error("Provided secretKey is invalid");
      }
    }
    return new Secp256k1Keypair({ publicKey, secretKey });
  }
  static fromSeed(seed) {
    let publicKey = secp.getPublicKey(seed, true);
    return new Secp256k1Keypair({ publicKey, secretKey: seed });
  }
  getPublicKey() {
    return new Secp256k1PublicKey(this.keypair.publicKey);
  }
  signData(data, useRecoverable) {
    const msgHash = (0, import_sha256.sha256)(data);
    if (useRecoverable) {
      const [sig, rec_id] = secp.signSync(msgHash, this.keypair.secretKey, {
        canonical: true,
        recovered: true
      });
      var recoverable_sig = new Uint8Array(65);
      recoverable_sig.set(import_secp256k1.Signature.fromDER(sig).toCompactRawBytes());
      recoverable_sig.set([rec_id], 64);
      return recoverable_sig;
    } else {
      const sig = secp.signSync(msgHash, this.keypair.secretKey, {
        canonical: true,
        recovered: false
      });
      return import_secp256k1.Signature.fromDER(sig).toCompactRawBytes();
    }
  }
  static deriveKeypair(path, mnemonics) {
    if (!isValidBIP32Path(path)) {
      throw new Error("Invalid derivation path");
    }
    const key = import_bip32.HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);
    if (key.publicKey == null || key.privateKey == null) {
      throw new Error("Invalid key");
    }
    return new Secp256k1Keypair({
      publicKey: key.publicKey,
      secretKey: key.privateKey
    });
  }
  export() {
    return {
      schema: "Secp256k1",
      privateKey: (0, import_bcs5.toB64)(this.keypair.secretKey)
    };
  }
};

// src/cryptography/keypair.ts
var PRIVATE_KEY_SIZE = 32;
var LEGACY_PRIVATE_KEY_SIZE = 64;
function fromExportedKeypair(keypair) {
  const secretKey = (0, import_bcs6.fromB64)(keypair.privateKey);
  switch (keypair.schema) {
    case "ED25519":
      let pureSecretKey = secretKey;
      if (secretKey.length === LEGACY_PRIVATE_KEY_SIZE) {
        pureSecretKey = secretKey.slice(0, PRIVATE_KEY_SIZE);
      }
      return Ed25519Keypair.fromSecretKey(pureSecretKey);
    case "Secp256k1":
      return Secp256k1Keypair.fromSecretKey(secretKey);
    default:
      throw new Error(`Invalid keypair schema ${keypair.schema}`);
  }
}

// src/utils/ed25519-hd-key.ts
var import_sha512 = require("@noble/hashes/sha512");
var import_hmac2 = require("@noble/hashes/hmac");
var import_tweetnacl = __toESM(require("tweetnacl"));
var import_bcs7 = require("@mysten/bcs");
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h = import_hmac2.hmac.create(import_sha512.sha512, ED25519_CURVE);
  const I = h.update((0, import_bcs7.fromHEX)(seed)).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key, 1);
  data.set(
    new Uint8Array(indexBuffer, 0, indexBuffer.byteLength),
    key.length + 1
  );
  const I = import_hmac2.hmac.create(import_sha512.sha512, chainCode).update(data).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(isNaN);
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce(
    (parentKeys, segment) => CKDPriv(parentKeys, segment + offset),
    { key, chainCode }
  );
};

// src/cryptography/ed25519-keypair.ts
var import_bcs8 = require("@mysten/bcs");
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class {
  constructor(keypair) {
    if (keypair) {
      this.keypair = keypair;
    } else {
      this.keypair = import_tweetnacl2.default.sign.keyPair();
    }
  }
  getKeyScheme() {
    return "ED25519";
  }
  static generate() {
    return new Ed25519Keypair(import_tweetnacl2.default.sign.keyPair());
  }
  static fromSecretKey(secretKey, options) {
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = import_tweetnacl2.default.sign.keyPair.fromSeed(secretKey);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = import_tweetnacl2.default.sign.detached(signData, keypair.secretKey);
      if (!import_tweetnacl2.default.sign.detached.verify(signData, signature, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new Ed25519Keypair(keypair);
  }
  getPublicKey() {
    return new Ed25519PublicKey(this.keypair.publicKey);
  }
  signData(data, _useRecoverable = false) {
    return import_tweetnacl2.default.sign.detached(data, this.keypair.secretKey);
  }
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return Ed25519Keypair.fromSecretKey(key);
  }
  export() {
    return {
      schema: "ED25519",
      privateKey: (0, import_bcs8.toB64)(this.keypair.secretKey)
    };
  }
};

// src/providers/provider.ts
var Provider = class {
};

// src/rpc/client.ts
var import_browser = __toESM(require("jayson/lib/client/browser/index.js"));
var import_cross_fetch = __toESM(require("cross-fetch"));
var import_superstruct = require("superstruct");

// src/pkg-version.ts
var pkgVersion = "0.29.1";

// src/rpc/client.ts
var TYPE_MISMATCH_ERROR = `The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server. Please update your SDK version to the latest. `;
var ValidResponse = (0, import_superstruct.object)({
  jsonrpc: (0, import_superstruct.literal)("2.0"),
  id: (0, import_superstruct.string)(),
  result: (0, import_superstruct.any)()
});
var ErrorResponse = (0, import_superstruct.object)({
  jsonrpc: (0, import_superstruct.literal)("2.0"),
  id: (0, import_superstruct.string)(),
  error: (0, import_superstruct.object)({
    code: (0, import_superstruct.any)(),
    message: (0, import_superstruct.string)(),
    data: (0, import_superstruct.optional)((0, import_superstruct.any)())
  })
});
var JsonRpcClient = class {
  constructor(url, httpHeaders) {
    this.rpcClient = new import_browser.default(
      (request, callback) => __async(this, null, function* () {
        const options = {
          method: "POST",
          body: request,
          headers: __spreadValues({
            "Content-Type": "application/json",
            "Client-Sdk-Type": "typescript",
            "Client-Sdk-Version": pkgVersion,
            "Client-Target-Api-Version": TARGETED_RPC_VERSION
          }, httpHeaders)
        };
        try {
          let res = yield (0, import_cross_fetch.default)(url, options);
          const result = yield res.text();
          if (res.ok) {
            callback(null, result);
          } else {
            const isHtml = res.headers.get("content-type") === "text/html";
            callback(
              new Error(
                `${res.status} ${res.statusText}${isHtml ? "" : `: ${result}`}`
              )
            );
          }
        } catch (err) {
          if (err instanceof Error)
            callback(err);
        }
      }),
      {}
    );
  }
  requestWithType(method, args, struct, skipDataValidation = false) {
    return __async(this, null, function* () {
      const response = yield this.request(method, args);
      if ((0, import_superstruct.is)(response, ErrorResponse)) {
        throw new Error(`RPC Error: ${response.error.message}`);
      } else if ((0, import_superstruct.is)(response, ValidResponse)) {
        const err = (0, import_superstruct.validate)(response.result, struct)[0];
        const errMsg = TYPE_MISMATCH_ERROR + `Result received was: ${JSON.stringify(
          response.result
        )}. Debug info: ${err}`;
        if (skipDataValidation && err) {
          console.warn(errMsg);
          return response.result;
        } else if (err) {
          throw new Error(`RPC Error: ${errMsg}`);
        }
        return response.result;
      }
      throw new Error(`Unexpected RPC Response: ${response}`);
    });
  }
  request(method, args) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        this.rpcClient.request(method, args, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    });
  }
  batchRequestWithType(requests, struct, skipDataValidation = false) {
    return __async(this, null, function* () {
      const responses = yield this.batchRequest(requests);
      const validResponses = responses.filter(
        (response) => (0, import_superstruct.is)(response, ValidResponse) && (skipDataValidation || (0, import_superstruct.is)(response.result, struct))
      );
      if (responses.length > validResponses.length) {
        console.warn(
          `Batch request contains invalid responses. ${responses.length - validResponses.length} of the ${responses.length} requests has invalid schema.`
        );
        const exampleTypeMismatch = responses.find(
          (r) => !(0, import_superstruct.is)(r.result, struct)
        );
        const exampleInvalidResponseIndex = responses.findIndex(
          (r) => !(0, import_superstruct.is)(r, ValidResponse)
        );
        if (exampleTypeMismatch) {
          console.warn(
            TYPE_MISMATCH_ERROR + `One example mismatch is: ${JSON.stringify(
              exampleTypeMismatch.result
            )}`
          );
        }
        if (exampleInvalidResponseIndex !== -1) {
          console.warn(
            `The request ${JSON.stringify(
              requests[exampleInvalidResponseIndex]
            )} within a batch request returns an invalid response ${JSON.stringify(
              responses[exampleInvalidResponseIndex]
            )}`
          );
        }
      }
      return validResponses.map(
        (response) => response.result
      );
    });
  }
  batchRequest(requests) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        if (requests.length === 0)
          resolve([]);
        const batch = requests.map((params) => {
          return this.rpcClient.request(params.method, params.args);
        });
        this.rpcClient.request(batch, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    });
  }
};

// src/types/common.ts
var import_superstruct2 = require("superstruct");

// src/cryptography/hash.ts
var import_bcs9 = require("@mysten/bcs");
var import_js_sha33 = __toESM(require("js-sha3"));
function sha256Hash(typeTag, data) {
  const hash = import_js_sha33.default.sha3_256.create();
  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  hash.update(dataWithTag);
  return (0, import_bcs9.fromHEX)(hash.hex());
}

// src/types/common.ts
var import_bcs10 = require("@mysten/bcs");
var TransactionDigest = (0, import_superstruct2.string)();
var TransactionEffectsDigest = (0, import_superstruct2.string)();
var ObjectId = (0, import_superstruct2.string)();
var SuiAddress = (0, import_superstruct2.string)();
var SequenceNumber = (0, import_superstruct2.number)();
var ObjectOwner = (0, import_superstruct2.union)([
  (0, import_superstruct2.object)({
    AddressOwner: SuiAddress
  }),
  (0, import_superstruct2.object)({
    ObjectOwner: SuiAddress
  }),
  (0, import_superstruct2.object)({
    Shared: (0, import_superstruct2.object)({
      initial_shared_version: (0, import_superstruct2.number)()
    })
  }),
  (0, import_superstruct2.literal)("Immutable")
]);
var SuiJsonValue = (0, import_superstruct2.unknown)();
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = (0, import_bcs10.fromB58)(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH = 20;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function generateTransactionDigest(data, bcs2) {
  const txBytes = bcs2.ser("TransactionData", data).toBytes();
  const hash = sha256Hash("TransactionData", txBytes);
  return (0, import_bcs10.toB58)(hash);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}

// src/types/objects.ts
var import_superstruct3 = require("superstruct");
var ObjectType = (0, import_superstruct3.union)([(0, import_superstruct3.literal)("moveObject"), (0, import_superstruct3.literal)("package")]);
var SuiObjectRef = (0, import_superstruct3.object)({
  digest: TransactionDigest,
  objectId: (0, import_superstruct3.string)(),
  version: (0, import_superstruct3.number)()
});
var SuiGasData = (0, import_superstruct3.object)({
  payment: SuiObjectRef,
  owner: (0, import_superstruct3.string)(),
  price: (0, import_superstruct3.number)(),
  budget: (0, import_superstruct3.number)()
});
var SuiObjectInfo = (0, import_superstruct3.assign)(
  SuiObjectRef,
  (0, import_superstruct3.object)({
    type: (0, import_superstruct3.string)(),
    owner: ObjectOwner,
    previousTransaction: TransactionDigest
  })
);
var ObjectContentFields = (0, import_superstruct3.record)((0, import_superstruct3.string)(), (0, import_superstruct3.any)());
var MovePackageContent = (0, import_superstruct3.record)((0, import_superstruct3.string)(), (0, import_superstruct3.string)());
var SuiMoveObject = (0, import_superstruct3.object)({
  type: (0, import_superstruct3.string)(),
  fields: ObjectContentFields,
  has_public_transfer: (0, import_superstruct3.optional)((0, import_superstruct3.boolean)())
});
var SuiMovePackage = (0, import_superstruct3.object)({
  disassembled: MovePackageContent
});
var SuiData = (0, import_superstruct3.union)([
  (0, import_superstruct3.assign)(SuiMoveObject, (0, import_superstruct3.object)({ dataType: (0, import_superstruct3.literal)("moveObject") })),
  (0, import_superstruct3.assign)(SuiMovePackage, (0, import_superstruct3.object)({ dataType: (0, import_superstruct3.literal)("package") }))
]);
var MIST_PER_SUI = BigInt(1e9);
var SuiObject = (0, import_superstruct3.object)({
  data: SuiData,
  owner: ObjectOwner,
  previousTransaction: TransactionDigest,
  storageRebate: (0, import_superstruct3.number)(),
  reference: SuiObjectRef
});
var ObjectStatus = (0, import_superstruct3.union)([
  (0, import_superstruct3.literal)("Exists"),
  (0, import_superstruct3.literal)("NotExists"),
  (0, import_superstruct3.literal)("Deleted")
]);
var GetOwnedObjectsResponse = (0, import_superstruct3.array)(SuiObjectInfo);
var GetObjectDataResponse = (0, import_superstruct3.object)({
  status: ObjectStatus,
  details: (0, import_superstruct3.union)([SuiObject, ObjectId, SuiObjectRef])
});
function getObjectExistsResponse(resp) {
  return resp.status !== "Exists" ? void 0 : resp.details;
}
function getObjectDeletedResponse(resp) {
  return resp.status !== "Deleted" ? void 0 : resp.details;
}
function getObjectNotExistsResponse(resp) {
  return resp.status !== "NotExists" ? void 0 : resp.details;
}
function getObjectReference(resp) {
  var _a;
  return ((_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.reference) || getObjectDeletedResponse(resp);
}
function getObjectId(data) {
  var _a, _b;
  if ("objectId" in data) {
    return data.objectId;
  }
  return (_b = (_a = getObjectReference(data)) == null ? void 0 : _a.objectId) != null ? _b : getObjectNotExistsResponse(data);
}
function getObjectVersion(data) {
  var _a;
  if ("version" in data) {
    return data.version;
  }
  return (_a = getObjectReference(data)) == null ? void 0 : _a.version;
}
function getObjectType(resp) {
  var _a;
  return (_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.data.dataType;
}
function getObjectPreviousTransactionDigest(resp) {
  var _a;
  return (_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.previousTransaction;
}
function getObjectOwner(resp) {
  var _a;
  return (_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.owner;
}
function getSharedObjectInitialVersion(resp) {
  const owner = getObjectOwner(resp);
  if (typeof owner === "object" && "Shared" in owner) {
    return owner.Shared.initial_shared_version;
  } else {
    return void 0;
  }
}
function isSharedObject(resp) {
  const owner = getObjectOwner(resp);
  return typeof owner === "object" && "Shared" in owner;
}
function isImmutableObject(resp) {
  const owner = getObjectOwner(resp);
  return owner === "Immutable";
}
function getMoveObjectType(resp) {
  var _a;
  return (_a = getMoveObject(resp)) == null ? void 0 : _a.type;
}
function getObjectFields(resp) {
  var _a;
  if ("fields" in resp) {
    return resp.fields;
  }
  return (_a = getMoveObject(resp)) == null ? void 0 : _a.fields;
}
function getMoveObject(data) {
  const suiObject = "data" in data ? data : getObjectExistsResponse(data);
  if ((suiObject == null ? void 0 : suiObject.data.dataType) !== "moveObject") {
    return void 0;
  }
  return suiObject.data;
}
function hasPublicTransfer(data) {
  var _a, _b;
  return (_b = (_a = getMoveObject(data)) == null ? void 0 : _a.has_public_transfer) != null ? _b : false;
}
function getMovePackageContent(data) {
  if ("disassembled" in data) {
    return data.disassembled;
  }
  const suiObject = getObjectExistsResponse(data);
  if ((suiObject == null ? void 0 : suiObject.data.dataType) !== "package") {
    return void 0;
  }
  return suiObject.data.disassembled;
}

// src/types/events.ts
var import_superstruct4 = require("superstruct");
var BalanceChangeType = (0, import_superstruct4.union)([
  (0, import_superstruct4.literal)("Gas"),
  (0, import_superstruct4.literal)("Pay"),
  (0, import_superstruct4.literal)("Receive")
]);
var MoveEvent = (0, import_superstruct4.object)({
  packageId: ObjectId,
  transactionModule: (0, import_superstruct4.string)(),
  sender: SuiAddress,
  type: (0, import_superstruct4.string)(),
  fields: (0, import_superstruct4.record)((0, import_superstruct4.string)(), (0, import_superstruct4.any)()),
  bcs: (0, import_superstruct4.string)()
});
var PublishEvent = (0, import_superstruct4.object)({
  sender: SuiAddress,
  packageId: ObjectId,
  version: (0, import_superstruct4.optional)((0, import_superstruct4.number)()),
  digest: (0, import_superstruct4.optional)((0, import_superstruct4.string)())
});
var CoinBalanceChangeEvent = (0, import_superstruct4.object)({
  packageId: ObjectId,
  transactionModule: (0, import_superstruct4.string)(),
  sender: SuiAddress,
  owner: ObjectOwner,
  changeType: BalanceChangeType,
  coinType: (0, import_superstruct4.string)(),
  coinObjectId: ObjectId,
  version: SequenceNumber,
  amount: (0, import_superstruct4.number)()
});
var TransferObjectEvent = (0, import_superstruct4.object)({
  packageId: ObjectId,
  transactionModule: (0, import_superstruct4.string)(),
  sender: SuiAddress,
  recipient: ObjectOwner,
  objectType: (0, import_superstruct4.string)(),
  objectId: ObjectId,
  version: SequenceNumber
});
var MutateObjectEvent = (0, import_superstruct4.object)({
  packageId: ObjectId,
  transactionModule: (0, import_superstruct4.string)(),
  sender: SuiAddress,
  objectType: (0, import_superstruct4.string)(),
  objectId: ObjectId,
  version: SequenceNumber
});
var DeleteObjectEvent = (0, import_superstruct4.object)({
  packageId: ObjectId,
  transactionModule: (0, import_superstruct4.string)(),
  sender: SuiAddress,
  objectId: ObjectId,
  version: SequenceNumber
});
var NewObjectEvent = (0, import_superstruct4.object)({
  packageId: ObjectId,
  transactionModule: (0, import_superstruct4.string)(),
  sender: SuiAddress,
  recipient: ObjectOwner,
  objectType: (0, import_superstruct4.string)(),
  objectId: ObjectId,
  version: SequenceNumber
});
var EpochChangeEvent = (0, import_superstruct4.union)([(0, import_superstruct4.bigint)(), (0, import_superstruct4.number)()]);
var CheckpointEvent = (0, import_superstruct4.union)([(0, import_superstruct4.bigint)(), (0, import_superstruct4.number)()]);
var SuiEvent = (0, import_superstruct4.union)([
  (0, import_superstruct4.object)({ moveEvent: MoveEvent }),
  (0, import_superstruct4.object)({ publish: PublishEvent }),
  (0, import_superstruct4.object)({ coinBalanceChange: CoinBalanceChangeEvent }),
  (0, import_superstruct4.object)({ transferObject: TransferObjectEvent }),
  (0, import_superstruct4.object)({ mutateObject: MutateObjectEvent }),
  (0, import_superstruct4.object)({ deleteObject: DeleteObjectEvent }),
  (0, import_superstruct4.object)({ newObject: NewObjectEvent }),
  (0, import_superstruct4.object)({ epochChange: EpochChangeEvent }),
  (0, import_superstruct4.object)({ checkpoint: CheckpointEvent })
]);
var EventId = (0, import_superstruct4.object)({
  txDigest: TransactionDigest,
  eventSeq: (0, import_superstruct4.number)()
});
var SuiEventEnvelope = (0, import_superstruct4.object)({
  timestamp: (0, import_superstruct4.number)(),
  txDigest: TransactionDigest,
  id: EventId,
  event: SuiEvent
});
var PaginatedEvents = (0, import_superstruct4.object)({
  data: (0, import_superstruct4.array)(SuiEventEnvelope),
  nextCursor: (0, import_superstruct4.union)([EventId, (0, import_superstruct4.literal)(null)])
});
var SubscriptionId = (0, import_superstruct4.number)();
var SubscriptionEvent = (0, import_superstruct4.object)({
  subscription: SubscriptionId,
  result: SuiEventEnvelope
});

// src/types/transactions.ts
var import_superstruct5 = require("superstruct");
var EpochId = (0, import_superstruct5.number)();
var TransferObject = (0, import_superstruct5.object)({
  recipient: SuiAddress,
  objectRef: SuiObjectRef
});
var SuiTransferSui = (0, import_superstruct5.object)({
  recipient: SuiAddress,
  amount: (0, import_superstruct5.union)([(0, import_superstruct5.number)(), (0, import_superstruct5.literal)(null)])
});
var SuiChangeEpoch = (0, import_superstruct5.object)({
  epoch: EpochId,
  storage_charge: (0, import_superstruct5.number)(),
  computation_charge: (0, import_superstruct5.number)(),
  storage_rebate: (0, import_superstruct5.optional)((0, import_superstruct5.number)()),
  epoch_start_timestamp_ms: (0, import_superstruct5.optional)((0, import_superstruct5.number)())
});
var SuiConsensusCommitPrologue = (0, import_superstruct5.object)({
  checkpoint_start_timestamp_ms: (0, import_superstruct5.number)()
});
var Pay = (0, import_superstruct5.object)({
  coins: (0, import_superstruct5.array)(SuiObjectRef),
  recipients: (0, import_superstruct5.array)(SuiAddress),
  amounts: (0, import_superstruct5.array)((0, import_superstruct5.number)())
});
var PaySui = (0, import_superstruct5.object)({
  coins: (0, import_superstruct5.array)(SuiObjectRef),
  recipients: (0, import_superstruct5.array)(SuiAddress),
  amounts: (0, import_superstruct5.array)((0, import_superstruct5.number)())
});
var PayAllSui = (0, import_superstruct5.object)({
  coins: (0, import_superstruct5.array)(SuiObjectRef),
  recipient: SuiAddress
});
var MoveCall = (0, import_superstruct5.object)({
  package: (0, import_superstruct5.string)(),
  module: (0, import_superstruct5.string)(),
  function: (0, import_superstruct5.string)(),
  typeArguments: (0, import_superstruct5.optional)((0, import_superstruct5.array)((0, import_superstruct5.string)())),
  arguments: (0, import_superstruct5.optional)((0, import_superstruct5.array)(SuiJsonValue))
});
var Genesis = (0, import_superstruct5.object)({
  objects: (0, import_superstruct5.array)(ObjectId)
});
var SuiTransactionKind = (0, import_superstruct5.union)([
  (0, import_superstruct5.object)({ TransferObject }),
  (0, import_superstruct5.object)({ Publish: SuiMovePackage }),
  (0, import_superstruct5.object)({ Call: MoveCall }),
  (0, import_superstruct5.object)({ TransferSui: SuiTransferSui }),
  (0, import_superstruct5.object)({ ChangeEpoch: SuiChangeEpoch }),
  (0, import_superstruct5.object)({ ConsensusCommitPrologue: SuiConsensusCommitPrologue }),
  (0, import_superstruct5.object)({ Pay }),
  (0, import_superstruct5.object)({ PaySui }),
  (0, import_superstruct5.object)({ PayAllSui }),
  (0, import_superstruct5.object)({ Genesis })
]);
var SuiTransactionData = (0, import_superstruct5.object)({
  transactions: (0, import_superstruct5.array)(SuiTransactionKind),
  sender: SuiAddress,
  gasData: SuiGasData
});
var AuthoritySignature = (0, import_superstruct5.string)();
var GenericAuthoritySignature = (0, import_superstruct5.union)([
  AuthoritySignature,
  (0, import_superstruct5.array)(AuthoritySignature)
]);
var AuthorityQuorumSignInfo = (0, import_superstruct5.object)({
  epoch: EpochId,
  signature: GenericAuthoritySignature,
  signers_map: (0, import_superstruct5.array)((0, import_superstruct5.number)())
});
var CertifiedTransaction = (0, import_superstruct5.object)({
  transactionDigest: TransactionDigest,
  data: SuiTransactionData,
  txSignatures: (0, import_superstruct5.array)((0, import_superstruct5.string)()),
  authSignInfo: AuthorityQuorumSignInfo
});
var GasCostSummary = (0, import_superstruct5.object)({
  computationCost: (0, import_superstruct5.number)(),
  storageCost: (0, import_superstruct5.number)(),
  storageRebate: (0, import_superstruct5.number)()
});
var ExecutionStatusType = (0, import_superstruct5.union)([
  (0, import_superstruct5.literal)("success"),
  (0, import_superstruct5.literal)("failure")
]);
var ExecutionStatus = (0, import_superstruct5.object)({
  status: ExecutionStatusType,
  error: (0, import_superstruct5.optional)((0, import_superstruct5.string)())
});
var OwnedObjectRef = (0, import_superstruct5.object)({
  owner: ObjectOwner,
  reference: SuiObjectRef
});
var TransactionEffects = (0, import_superstruct5.object)({
  status: ExecutionStatus,
  executedEpoch: (0, import_superstruct5.optional)(EpochId),
  gasUsed: GasCostSummary,
  sharedObjects: (0, import_superstruct5.optional)((0, import_superstruct5.array)(SuiObjectRef)),
  transactionDigest: TransactionDigest,
  created: (0, import_superstruct5.optional)((0, import_superstruct5.array)(OwnedObjectRef)),
  mutated: (0, import_superstruct5.optional)((0, import_superstruct5.array)(OwnedObjectRef)),
  unwrapped: (0, import_superstruct5.optional)((0, import_superstruct5.array)(OwnedObjectRef)),
  deleted: (0, import_superstruct5.optional)((0, import_superstruct5.array)(SuiObjectRef)),
  unwrapped_then_deleted: (0, import_superstruct5.optional)((0, import_superstruct5.array)(SuiObjectRef)),
  wrapped: (0, import_superstruct5.optional)((0, import_superstruct5.array)(SuiObjectRef)),
  gasObject: OwnedObjectRef,
  events: (0, import_superstruct5.optional)((0, import_superstruct5.array)(SuiEvent)),
  dependencies: (0, import_superstruct5.optional)((0, import_superstruct5.array)(TransactionDigest))
});
var ReturnValueType = (0, import_superstruct5.tuple)([(0, import_superstruct5.array)((0, import_superstruct5.number)()), (0, import_superstruct5.string)()]);
var MutableReferenceOutputType = (0, import_superstruct5.tuple)([(0, import_superstruct5.number)(), (0, import_superstruct5.array)((0, import_superstruct5.number)()), (0, import_superstruct5.string)()]);
var ExecutionResultType = (0, import_superstruct5.object)({
  mutableReferenceOutputs: (0, import_superstruct5.optional)((0, import_superstruct5.array)(MutableReferenceOutputType)),
  returnValues: (0, import_superstruct5.optional)((0, import_superstruct5.array)(ReturnValueType))
});
var DevInspectResultTupleType = (0, import_superstruct5.tuple)([(0, import_superstruct5.number)(), ExecutionResultType]);
var DevInspectResultsType = (0, import_superstruct5.union)([
  (0, import_superstruct5.object)({ Ok: (0, import_superstruct5.array)(DevInspectResultTupleType) }),
  (0, import_superstruct5.object)({ Err: (0, import_superstruct5.string)() })
]);
var DevInspectResults = (0, import_superstruct5.object)({
  effects: TransactionEffects,
  results: DevInspectResultsType
});
var SuiCertifiedTransactionEffects = (0, import_superstruct5.object)({
  transactionEffectsDigest: (0, import_superstruct5.string)(),
  authSignInfo: AuthorityQuorumSignInfo,
  effects: TransactionEffects
});
var SuiEffectsFinalityInfo = (0, import_superstruct5.union)([
  (0, import_superstruct5.object)({ certified: AuthorityQuorumSignInfo }),
  (0, import_superstruct5.object)({ checkpointed: (0, import_superstruct5.tuple)([(0, import_superstruct5.number)(), (0, import_superstruct5.number)()]) })
]);
var SuiFinalizedEffects = (0, import_superstruct5.object)({
  transactionEffectsDigest: (0, import_superstruct5.string)(),
  effects: TransactionEffects,
  finalityInfo: SuiEffectsFinalityInfo
});
var GetTxnDigestsResponse = (0, import_superstruct5.array)(TransactionDigest);
var PaginatedTransactionDigests = (0, import_superstruct5.object)({
  data: (0, import_superstruct5.array)(TransactionDigest),
  nextCursor: (0, import_superstruct5.union)([TransactionDigest, (0, import_superstruct5.literal)(null)])
});
var AuthorityName = (0, import_superstruct5.string)();
var TransactionBytes = (0, import_superstruct5.object)({
  txBytes: (0, import_superstruct5.string)(),
  gas: SuiObjectRef,
  inputObjects: (0, import_superstruct5.unknown)()
});
var SuiParsedMergeCoinResponse = (0, import_superstruct5.object)({
  updatedCoin: SuiObject,
  updatedGas: SuiObject
});
var SuiParsedSplitCoinResponse = (0, import_superstruct5.object)({
  updatedCoin: SuiObject,
  newCoins: (0, import_superstruct5.array)(SuiObject),
  updatedGas: SuiObject
});
var SuiPackage = (0, import_superstruct5.object)({
  digest: (0, import_superstruct5.string)(),
  objectId: (0, import_superstruct5.string)(),
  version: (0, import_superstruct5.number)()
});
var SuiParsedPublishResponse = (0, import_superstruct5.object)({
  createdObjects: (0, import_superstruct5.array)(SuiObject),
  package: SuiPackage,
  updatedGas: SuiObject
});
var SuiParsedTransactionResponse = (0, import_superstruct5.union)([
  (0, import_superstruct5.object)({ SplitCoin: SuiParsedSplitCoinResponse }),
  (0, import_superstruct5.object)({ MergeCoin: SuiParsedMergeCoinResponse }),
  (0, import_superstruct5.object)({ Publish: SuiParsedPublishResponse })
]);
var SuiTransaction = (0, import_superstruct5.object)({
  data: SuiTransactionData,
  txSignatures: (0, import_superstruct5.array)((0, import_superstruct5.string)())
});
var SuiTransactionResponse = (0, import_superstruct5.object)({
  transaction: (0, import_superstruct5.optional)(SuiTransaction),
  certificate: (0, import_superstruct5.optional)(CertifiedTransaction),
  effects: TransactionEffects,
  timestamp_ms: (0, import_superstruct5.optional)((0, import_superstruct5.union)([(0, import_superstruct5.number)(), (0, import_superstruct5.literal)(null)])),
  timestampMs: (0, import_superstruct5.optional)((0, import_superstruct5.union)([(0, import_superstruct5.number)(), (0, import_superstruct5.literal)(null)])),
  checkpoint: (0, import_superstruct5.optional)((0, import_superstruct5.union)([(0, import_superstruct5.number)(), (0, import_superstruct5.literal)(null)])),
  confirmedLocalExecution: (0, import_superstruct5.optional)((0, import_superstruct5.boolean)()),
  parsed_data: (0, import_superstruct5.optional)((0, import_superstruct5.union)([SuiParsedTransactionResponse, (0, import_superstruct5.literal)(null)]))
});
var SuiExecuteTransactionResponse = (0, import_superstruct5.union)([
  (0, import_superstruct5.object)({
    EffectsCert: (0, import_superstruct5.object)({
      certificate: CertifiedTransaction,
      effects: SuiCertifiedTransactionEffects,
      confirmed_local_execution: (0, import_superstruct5.boolean)()
    })
  }),
  (0, import_superstruct5.object)({
    certificate: (0, import_superstruct5.optional)(CertifiedTransaction),
    effects: SuiFinalizedEffects,
    confirmed_local_execution: (0, import_superstruct5.boolean)()
  }),
  SuiTransactionResponse
]);
function getCertifiedTransaction(tx) {
  if ("certificate" in tx) {
    return tx.certificate;
  } else if ("EffectsCert" in tx) {
    return tx.EffectsCert.certificate;
  }
  return void 0;
}
function getTransactionDigest(tx) {
  if ("transactionDigest" in tx) {
    return tx.transactionDigest;
  }
  const effects = getTransactionEffects(tx);
  return effects.transactionDigest;
}
function getTransactionSignature(tx) {
  const certificateOrTx = "certificate" in tx ? tx.certificate : "transaction" in tx ? tx.transaction : tx;
  if ("txSignatures" in certificateOrTx) {
    return certificateOrTx.txSignatures;
  }
  return [];
}
function getTransactionData(tx) {
  return tx.data;
}
function getTransactionSender(tx) {
  return tx.certificate ? tx.certificate.data.sender : tx.transaction.data.sender;
}
function getGasData(tx) {
  if ("data" in tx) {
    return tx.data.gasData;
  }
  if ("certificate" in tx) {
    return tx.certificate.data.gasData;
  }
  return tx.transaction.data.gasData;
}
function getTransactionGasObject(tx) {
  return getGasData(tx).payment;
}
function getTransactionGasPrice(tx) {
  return getGasData(tx).price;
}
function getTransactionGasBudget(tx) {
  return getGasData(tx).budget;
}
function getTransferObjectTransaction(data) {
  return "TransferObject" in data ? data.TransferObject : void 0;
}
function getPublishTransaction(data) {
  return "Publish" in data ? data.Publish : void 0;
}
function getMoveCallTransaction(data) {
  return "Call" in data ? data.Call : void 0;
}
function getTransferSuiTransaction(data) {
  return "TransferSui" in data ? data.TransferSui : void 0;
}
function getPayTransaction(data) {
  return "Pay" in data ? data.Pay : void 0;
}
function getPaySuiTransaction(data) {
  return "PaySui" in data ? data.PaySui : void 0;
}
function getPayAllSuiTransaction(data) {
  return "PayAllSui" in data ? data.PayAllSui : void 0;
}
function getChangeEpochTransaction(data) {
  return "ChangeEpoch" in data ? data.ChangeEpoch : void 0;
}
function getConsensusCommitPrologueTransaction(data) {
  return "ConsensusCommitPrologue" in data ? data.ConsensusCommitPrologue : void 0;
}
function getTransactions(data) {
  return data.certificate ? data.certificate.data.transactions : data.transaction.data.transactions;
}
function getTransferSuiAmount(data) {
  return "TransferSui" in data && data.TransferSui.amount ? BigInt(data.TransferSui.amount) : null;
}
function getTransactionKindName(data) {
  return Object.keys(data)[0];
}
function getExecutionStatusType(data) {
  var _a;
  return (_a = getExecutionStatus(data)) == null ? void 0 : _a.status;
}
function getExecutionStatus(data) {
  var _a;
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.status;
}
function getExecutionStatusError(data) {
  var _a;
  return (_a = getExecutionStatus(data)) == null ? void 0 : _a.error;
}
function getExecutionStatusGasSummary(data) {
  var _a;
  if ((0, import_superstruct5.is)(data, TransactionEffects)) {
    return data.gasUsed;
  }
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.gasUsed;
}
function getTotalGasUsed(data) {
  const gasSummary = getExecutionStatusGasSummary(data);
  return gasSummary ? gasSummary.computationCost + gasSummary.storageCost - gasSummary.storageRebate : void 0;
}
function getTotalGasUsedUpperBound(data) {
  const gasSummary = getExecutionStatusGasSummary(data);
  return gasSummary ? gasSummary.computationCost + gasSummary.storageCost : void 0;
}
function getTransactionEffects(data) {
  if ("effects" in data) {
    return `effects` in data.effects ? data.effects.effects : data.effects;
  }
  return "EffectsCert" in data ? data.EffectsCert.effects.effects : void 0;
}
function getEvents(data) {
  var _a;
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.events;
}
function getCreatedObjects(data) {
  var _a;
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.created;
}
function getTimestampFromTransactionResponse(data) {
  var _a;
  return "timestamp_ms" in data || "timestampMs" in data ? (_a = data.timestamp_ms || data.timestampMs) != null ? _a : void 0 : void 0;
}
function getParsedSplitCoinResponse(data) {
  const parsed = data.parsed_data;
  return parsed && "SplitCoin" in parsed ? parsed.SplitCoin : void 0;
}
function getParsedMergeCoinResponse(data) {
  const parsed = data.parsed_data;
  return parsed && "MergeCoin" in parsed ? parsed.MergeCoin : void 0;
}
function getParsedPublishResponse(data) {
  const parsed = data.parsed_data;
  return parsed && "Publish" in parsed ? parsed.Publish : void 0;
}
function getCoinAfterMerge(data) {
  var _a;
  return (_a = getParsedMergeCoinResponse(data)) == null ? void 0 : _a.updatedCoin;
}
function getCoinAfterSplit(data) {
  var _a;
  return (_a = getParsedSplitCoinResponse(data)) == null ? void 0 : _a.updatedCoin;
}
function getNewlyCreatedCoinsAfterSplit(data) {
  var _a;
  return (_a = getParsedSplitCoinResponse(data)) == null ? void 0 : _a.newCoins;
}
function getNewlyCreatedCoinRefsAfterSplit(data) {
  var _a, _b;
  if ("EffectsCert" in data) {
    const effects = data.EffectsCert.effects.effects;
    return (_a = effects.created) == null ? void 0 : _a.map((c) => c.reference);
  }
  if ("effects" in data) {
    const effects = "effects" in data.effects ? data.effects.effects : data.effects;
    return (_b = effects.created) == null ? void 0 : _b.map((c) => c.reference);
  }
  return void 0;
}

// src/types/option.ts
function getOption(option) {
  if (typeof option === "object" && option !== null && "type" in option && option.type.startsWith("0x1::option::Option<")) {
    return void 0;
  }
  return option;
}

// src/framework/framework.ts
var import_superstruct6 = require("superstruct");
var SUI_FRAMEWORK_ADDRESS = "0x2";
var MOVE_STDLIB_ADDRESS = "0x1";
var OBJECT_MODULE_NAME = "object";
var UID_STRUCT_NAME = "UID";
var ID_STRUCT_NAME = "ID";
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var PAY_MODULE_NAME = "pay";
var PAY_SPLIT_COIN_VEC_FUNC_NAME = "split_vec";
var PAY_JOIN_COIN_FUNC_NAME = "join";
var COIN_TYPE_ARG_REGEX = /^0x2::coin::Coin<(.+)>$/;
var CoinMetadataStruct = (0, import_superstruct6.object)({
  decimals: (0, import_superstruct6.number)(),
  name: (0, import_superstruct6.string)(),
  symbol: (0, import_superstruct6.string)(),
  description: (0, import_superstruct6.string)(),
  iconUrl: (0, import_superstruct6.union)([(0, import_superstruct6.string)(), (0, import_superstruct6.literal)(null)]),
  id: (0, import_superstruct6.union)([ObjectId, (0, import_superstruct6.literal)(null)])
});
var Coin = class {
  static isCoin(data) {
    var _a;
    return ((_a = Coin.getType(data)) == null ? void 0 : _a.match(COIN_TYPE_ARG_REGEX)) != null;
  }
  static getCoinType(type) {
    var _a;
    const [, res] = (_a = type.match(COIN_TYPE_ARG_REGEX)) != null ? _a : [];
    return res || null;
  }
  static getCoinTypeArg(obj) {
    const type = Coin.getType(obj);
    return type ? Coin.getCoinType(type) : null;
  }
  static isSUI(obj) {
    const arg = Coin.getCoinTypeArg(obj);
    return arg ? Coin.getCoinSymbol(arg) === "SUI" : false;
  }
  static getCoinSymbol(coinTypeArg) {
    return coinTypeArg.substring(coinTypeArg.lastIndexOf(":") + 1);
  }
  static getCoinStructTag(coinTypeArg) {
    return {
      address: normalizeSuiObjectId(coinTypeArg.split("::")[0]),
      module: coinTypeArg.split("::")[1],
      name: coinTypeArg.split("::")[2],
      typeParams: []
    };
  }
  static getID(obj) {
    if ("fields" in obj) {
      return obj.fields.id.id;
    }
    return getObjectId(obj);
  }
  static selectCoinsWithBalanceGreaterThanOrEqual(coins, amount, exclude = []) {
    return Coin.sortByBalance(
      coins.filter(
        (c) => !exclude.includes(Coin.getID(c)) && Coin.getBalance(c) >= amount
      )
    );
  }
  static selectCoinWithBalanceGreaterThanOrEqual(coins, amount, exclude = []) {
    return coins.find(
      (c) => !exclude.includes(Coin.getID(c)) && Coin.getBalance(c) >= amount
    );
  }
  static selectCoinSetWithCombinedBalanceGreaterThanOrEqual(coins, amount, exclude = []) {
    const sortedCoins = Coin.sortByBalance(
      coins.filter((c) => !exclude.includes(Coin.getID(c)))
    );
    const total = Coin.totalBalance(sortedCoins);
    if (total < amount) {
      return [];
    } else if (total === amount) {
      return sortedCoins;
    }
    let sum = BigInt(0);
    let ret = [];
    while (sum < total) {
      const target = amount - sum;
      const coinWithSmallestSufficientBalance = sortedCoins.find(
        (c) => Coin.getBalance(c) >= target
      );
      if (coinWithSmallestSufficientBalance) {
        ret.push(coinWithSmallestSufficientBalance);
        break;
      }
      const coinWithLargestBalance = sortedCoins.pop();
      ret.push(coinWithLargestBalance);
      sum += Coin.getBalance(coinWithLargestBalance);
    }
    return Coin.sortByBalance(ret);
  }
  static totalBalance(coins) {
    return coins.reduce(
      (partialSum, c) => partialSum + Coin.getBalance(c),
      BigInt(0)
    );
  }
  static sortByBalance(coins) {
    return [...coins].sort(
      (a, b) => Coin.getBalance(a) < Coin.getBalance(b) ? -1 : Coin.getBalance(a) > Coin.getBalance(b) ? 1 : 0
    );
  }
  static getBalance(data) {
    var _a;
    if (!Coin.isCoin(data)) {
      return void 0;
    }
    const balance = (_a = getObjectFields(data)) == null ? void 0 : _a.balance;
    return BigInt(balance);
  }
  static getZero() {
    return BigInt(0);
  }
  static getType(data) {
    if ("status" in data) {
      return getMoveObjectType(data);
    }
    return data.type;
  }
  static newPayTransaction(allCoins, coinTypeArg, amountToSend, recipient, gasBudget) {
    return __async(this, null, function* () {
      const isSuiTransfer = coinTypeArg === SUI_TYPE_ARG;
      const coinsOfTransferType = allCoins.filter(
        (aCoin) => Coin.getCoinTypeArg(aCoin) === coinTypeArg
      );
      const coinsOfGas = isSuiTransfer ? coinsOfTransferType : allCoins.filter((aCoin) => Coin.isSUI(aCoin));
      const gasCoin = Coin.selectCoinWithBalanceGreaterThanOrEqual(
        coinsOfGas,
        BigInt(gasBudget)
      );
      if (!gasCoin) {
        throw new Error(
          `Unable to find a coin to cover the gas budget ${gasBudget}`
        );
      }
      const totalAmountIncludingGas = amountToSend + BigInt(
        isSuiTransfer ? BigInt(gasBudget) - BigInt(Coin.getBalance(gasCoin) || 0) : 0
      );
      const inputCoinObjs = totalAmountIncludingGas > 0 ? yield Coin.selectCoinSetWithCombinedBalanceGreaterThanOrEqual(
        coinsOfTransferType,
        totalAmountIncludingGas,
        isSuiTransfer ? [Coin.getID(gasCoin)] : []
      ) : [];
      if (totalAmountIncludingGas > 0 && !inputCoinObjs.length) {
        const totalBalanceOfTransferType = Coin.totalBalance(coinsOfTransferType);
        const suggestedAmountToSend = totalBalanceOfTransferType - BigInt(isSuiTransfer ? gasBudget : 0);
        throw new Error(
          `Coin balance ${totalBalanceOfTransferType} is not sufficient to cover the transfer amount ${amountToSend}. Try reducing the transfer amount to ${suggestedAmountToSend}.`
        );
      }
      if (isSuiTransfer) {
        inputCoinObjs.unshift(gasCoin);
      }
      return {
        kind: isSuiTransfer ? "paySui" : "pay",
        data: {
          inputCoins: inputCoinObjs.map(Coin.getID),
          recipients: [recipient],
          amounts: [Number(amountToSend)],
          gasBudget: Number(gasBudget)
        }
      };
    });
  }
};
var _Delegation = class {
  static isDelegationSuiObject(obj) {
    return "type" in obj.data && obj.data.type === _Delegation.SUI_OBJECT_TYPE;
  }
  constructor(obj) {
    this.suiObject = obj;
  }
  nextRewardUnclaimedEpoch() {
    return this.suiObject.data.fields.next_reward_unclaimed_epoch;
  }
  activeDelegation() {
    return BigInt(getOption(this.suiObject.data.fields.active_delegation) || 0);
  }
  delegateAmount() {
    return this.suiObject.data.fields.delegate_amount;
  }
  endingEpoch() {
    return getOption(this.suiObject.data.fields.ending_epoch);
  }
  validatorAddress() {
    return this.suiObject.data.fields.validator_address;
  }
  isActive() {
    return this.activeDelegation() > 0 && !this.endingEpoch();
  }
  hasUnclaimedRewards(epoch) {
    return this.nextRewardUnclaimedEpoch() <= epoch && (this.isActive() || (this.endingEpoch() || 0) > epoch);
  }
};
var Delegation = _Delegation;
Delegation.SUI_OBJECT_TYPE = "0x2::delegation::Delegation";

// src/types/sui-bcs.ts
var import_bcs11 = require("@mysten/bcs");
function registerUTF8String(bcs2) {
  bcs2.registerType(
    "utf8string",
    (writer, str) => {
      const bytes = Array.from(new TextEncoder().encode(str));
      return writer.writeVec(bytes, (writer2, el) => writer2.write8(el));
    },
    (reader) => {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return new TextDecoder().decode(new Uint8Array(bytes));
    }
  );
}
function isPureArg(arg) {
  return arg.Pure !== void 0;
}
var TRANSACTION_DATA_TYPE_TAG = Array.from("TransactionData::").map(
  (e) => e.charCodeAt(0)
);
function deserializeTransactionBytesToTransactionData(bcs2, bytes) {
  return bcs2.de("TransactionData", bytes);
}
var BCS_SPEC = {
  enums: {
    "Option<T>": {
      None: null,
      Some: "T"
    },
    ObjectArg: {
      ImmOrOwned: "SuiObjectRef",
      Shared: "SharedObjectRef"
    },
    CallArg: {
      Pure: "vector<u8>",
      Object: "ObjectArg",
      ObjVec: "vector<ObjectArg>"
    },
    TypeTag: {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: "TypeTag",
      struct: "StructTag",
      u16: null,
      u32: null,
      u256: null
    },
    Transaction: {
      TransferObject: "TransferObjectTx",
      Publish: "PublishTx",
      Call: "MoveCallTx",
      TransferSui: "TransferSuiTx",
      Pay: "PayTx",
      PaySui: "PaySuiTx",
      PayAllSui: "PayAllSuiTx"
    },
    TransactionKind: {
      Single: "Transaction",
      Batch: "vector<Transaction>"
    },
    TransactionExpiration: {
      None: null,
      Epoch: import_bcs11.BCS.U64
    }
  },
  structs: {
    SuiObjectRef: {
      objectId: import_bcs11.BCS.ADDRESS,
      version: import_bcs11.BCS.U64,
      digest: "ObjectDigest"
    },
    TransferObjectTx: {
      recipient: import_bcs11.BCS.ADDRESS,
      object_ref: "SuiObjectRef"
    },
    PayTx: {
      coins: "vector<SuiObjectRef>",
      recipients: "vector<address>",
      amounts: "vector<u64>"
    },
    PaySuiTx: {
      coins: "vector<SuiObjectRef>",
      recipients: "vector<address>",
      amounts: "vector<u64>"
    },
    PayAllSuiTx: {
      coins: "vector<SuiObjectRef>",
      recipient: import_bcs11.BCS.ADDRESS
    },
    TransferSuiTx: {
      recipient: import_bcs11.BCS.ADDRESS,
      amount: "Option<u64>"
    },
    PublishTx: {
      modules: "vector<vector<u8>>"
    },
    SharedObjectRef: {
      objectId: import_bcs11.BCS.ADDRESS,
      initialSharedVersion: import_bcs11.BCS.U64,
      mutable: import_bcs11.BCS.BOOL
    },
    StructTag: {
      address: import_bcs11.BCS.ADDRESS,
      module: import_bcs11.BCS.STRING,
      name: import_bcs11.BCS.STRING,
      typeParams: "vector<TypeTag>"
    },
    MoveCallTx: {
      package: import_bcs11.BCS.ADDRESS,
      module: import_bcs11.BCS.STRING,
      function: import_bcs11.BCS.STRING,
      typeArguments: "vector<TypeTag>",
      arguments: "vector<CallArg>"
    },
    TransactionData: {
      kind: "TransactionKind",
      sender: import_bcs11.BCS.ADDRESS,
      gasData: "GasData",
      expiration: "TransactionExpiration"
    },
    GasData: {
      payment: "SuiObjectRef",
      owner: import_bcs11.BCS.ADDRESS,
      price: import_bcs11.BCS.U64,
      budget: import_bcs11.BCS.U64
    },
    SenderSignedData: {
      data: "TransactionData",
      txSignatures: "vector<vector<u8>>"
    }
  },
  aliases: {
    ObjectDigest: import_bcs11.BCS.BASE64
  }
};
var BCS_0_27_SPEC = {
  structs: __spreadProps(__spreadValues({}, BCS_SPEC.structs), {
    TransactionData: {
      kind: "TransactionKind",
      sender: import_bcs11.BCS.ADDRESS,
      gasData: "GasData"
    },
    SenderSignedData: {
      data: "TransactionData",
      txSignature: "vector<u8>"
    }
  }),
  enums: BCS_SPEC.enums,
  aliases: {
    ObjectDigest: import_bcs11.BCS.BASE64
  }
};
var bcs = new import_bcs11.BCS(__spreadProps(__spreadValues({}, (0, import_bcs11.getSuiMoveConfig)()), { types: BCS_SPEC }));
registerUTF8String(bcs);
var bcs_0_27 = new import_bcs11.BCS(__spreadProps(__spreadValues({}, (0, import_bcs11.getSuiMoveConfig)()), { types: BCS_0_27_SPEC }));
registerUTF8String(bcs_0_27);
function bcsForVersion(v) {
  if ((v == null ? void 0 : v.major) === 0 && (v == null ? void 0 : v.minor) <= 27) {
    return bcs_0_27;
  }
  return bcs;
}

// src/types/version.ts
var import_femver = require("@suchipi/femver");
function parseVersionFromString(version) {
  return (0, import_femver.parse)(version);
}
function versionToString(version) {
  const { major, minor, patch } = version;
  return `${major}.${minor}.${patch}`;
}

// src/types/normalized.ts
var import_superstruct7 = require("superstruct");
var SuiMoveFunctionArgType = (0, import_superstruct7.union)([
  (0, import_superstruct7.string)(),
  (0, import_superstruct7.object)({ Object: (0, import_superstruct7.string)() })
]);
var SuiMoveFunctionArgTypes = (0, import_superstruct7.array)(SuiMoveFunctionArgType);
var SuiMoveModuleId = (0, import_superstruct7.object)({
  address: (0, import_superstruct7.string)(),
  name: (0, import_superstruct7.string)()
});
var SuiMoveVisibility = (0, import_superstruct7.union)([
  (0, import_superstruct7.literal)("Private"),
  (0, import_superstruct7.literal)("Public"),
  (0, import_superstruct7.literal)("Friend")
]);
var SuiMoveAbilitySet = (0, import_superstruct7.object)({
  abilities: (0, import_superstruct7.array)((0, import_superstruct7.string)())
});
var SuiMoveStructTypeParameter = (0, import_superstruct7.object)({
  constraints: SuiMoveAbilitySet,
  is_phantom: (0, import_superstruct7.boolean)()
});
var SuiMoveNormalizedTypeParameterType = (0, import_superstruct7.object)({
  TypeParameter: (0, import_superstruct7.number)()
});
function isSuiMoveNormalizedType(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return true;
  if ((0, import_superstruct7.is)(value, SuiMoveNormalizedTypeParameterType))
    return true;
  if (isSuiMoveNormalizedStructType(value))
    return true;
  if (typeof value !== "object")
    return false;
  const valueProperties = value;
  if ((0, import_superstruct7.is)(valueProperties.Reference, SuiMoveNormalizedType))
    return true;
  if ((0, import_superstruct7.is)(valueProperties.MutableReference, SuiMoveNormalizedType))
    return true;
  if ((0, import_superstruct7.is)(valueProperties.Vector, SuiMoveNormalizedType))
    return true;
  return false;
}
var SuiMoveNormalizedType = (0, import_superstruct7.define)(
  "SuiMoveNormalizedType",
  isSuiMoveNormalizedType
);
function isSuiMoveNormalizedStructType(value) {
  if (!value || typeof value !== "object")
    return false;
  const valueProperties = value;
  if (!valueProperties.Struct || typeof valueProperties.Struct !== "object")
    return false;
  const structProperties = valueProperties.Struct;
  if (typeof structProperties.address !== "string" || typeof structProperties.module !== "string" || typeof structProperties.name !== "string" || !Array.isArray(structProperties.type_arguments) || !structProperties.type_arguments.every(
    (value2) => isSuiMoveNormalizedType(value2)
  )) {
    return false;
  }
  return true;
}
var SuiMoveNormalizedStructType = (0, import_superstruct7.define)(
  "SuiMoveNormalizedStructType",
  isSuiMoveNormalizedStructType
);
var SuiMoveNormalizedFunction = (0, import_superstruct7.object)({
  visibility: SuiMoveVisibility,
  is_entry: (0, import_superstruct7.boolean)(),
  type_parameters: (0, import_superstruct7.array)(SuiMoveAbilitySet),
  parameters: (0, import_superstruct7.array)(SuiMoveNormalizedType),
  return_: (0, import_superstruct7.array)(SuiMoveNormalizedType)
});
var SuiMoveNormalizedField = (0, import_superstruct7.object)({
  name: (0, import_superstruct7.string)(),
  type_: SuiMoveNormalizedType
});
var SuiMoveNormalizedStruct = (0, import_superstruct7.object)({
  abilities: SuiMoveAbilitySet,
  type_parameters: (0, import_superstruct7.array)(SuiMoveStructTypeParameter),
  fields: (0, import_superstruct7.array)(SuiMoveNormalizedField)
});
var SuiMoveNormalizedModule = (0, import_superstruct7.object)({
  file_format_version: (0, import_superstruct7.number)(),
  address: (0, import_superstruct7.string)(),
  name: (0, import_superstruct7.string)(),
  friends: (0, import_superstruct7.array)(SuiMoveModuleId),
  structs: (0, import_superstruct7.record)((0, import_superstruct7.string)(), SuiMoveNormalizedStruct),
  exposed_functions: (0, import_superstruct7.record)((0, import_superstruct7.string)(), SuiMoveNormalizedFunction)
});
var SuiMoveNormalizedModules = (0, import_superstruct7.record)(
  (0, import_superstruct7.string)(),
  SuiMoveNormalizedModule
);
function extractMutableReference(normalizedType) {
  return typeof normalizedType === "object" && "MutableReference" in normalizedType ? normalizedType.MutableReference : void 0;
}
function extractReference(normalizedType) {
  return typeof normalizedType === "object" && "Reference" in normalizedType ? normalizedType.Reference : void 0;
}
function extractStructTag(normalizedType) {
  if (typeof normalizedType === "object" && "Struct" in normalizedType) {
    return normalizedType;
  }
  const ref = extractReference(normalizedType);
  const mutRef = extractMutableReference(normalizedType);
  if (typeof ref === "object" && "Struct" in ref) {
    return ref;
  }
  if (typeof mutRef === "object" && "Struct" in mutRef) {
    return mutRef;
  }
  return void 0;
}

// src/types/validator.ts
var import_superstruct8 = require("superstruct");
var ValidatorMetaData = (0, import_superstruct8.object)({
  sui_address: SuiAddress,
  pubkey_bytes: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  network_pubkey_bytes: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  worker_pubkey_bytes: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  proof_of_possession_bytes: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  name: (0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.array)((0, import_superstruct8.number)())]),
  description: (0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.nullable)((0, import_superstruct8.array)((0, import_superstruct8.number)()))]),
  image_url: (0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.nullable)((0, import_superstruct8.array)((0, import_superstruct8.number)()))]),
  project_url: (0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.nullable)((0, import_superstruct8.array)((0, import_superstruct8.number)()))]),
  net_address: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  consensus_address: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  worker_address: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  next_epoch_stake: (0, import_superstruct8.number)(),
  next_epoch_delegation: (0, import_superstruct8.number)(),
  next_epoch_gas_price: (0, import_superstruct8.number)(),
  next_epoch_commission_rate: (0, import_superstruct8.number)()
});
var Balance = (0, import_superstruct8.object)({
  value: (0, import_superstruct8.number)()
});
var StakedSui = (0, import_superstruct8.object)({
  id: (0, import_superstruct8.object)({
    id: (0, import_superstruct8.string)()
  }),
  validator_address: SuiAddress,
  pool_starting_epoch: (0, import_superstruct8.number)(),
  delegation_request_epoch: (0, import_superstruct8.number)(),
  principal: Balance,
  sui_token_lock: (0, import_superstruct8.union)([(0, import_superstruct8.number)(), (0, import_superstruct8.literal)(null)])
});
var ActiveFields = (0, import_superstruct8.object)({
  id: (0, import_superstruct8.object)({
    id: (0, import_superstruct8.string)()
  }),
  staked_sui_id: SuiAddress,
  principal_sui_amount: (0, import_superstruct8.number)(),
  pool_tokens: Balance
});
var ActiveDelegationStatus = (0, import_superstruct8.object)({
  Active: ActiveFields
});
var DelegatedStake = (0, import_superstruct8.object)({
  staked_sui: StakedSui,
  delegation_status: (0, import_superstruct8.union)([(0, import_superstruct8.literal)("Pending"), ActiveDelegationStatus])
});
var ParametersFields = (0, import_superstruct8.object)({
  max_validator_candidate_count: (0, import_superstruct8.string)(),
  min_validator_stake: (0, import_superstruct8.string)(),
  storage_gas_price: (0, import_superstruct8.optional)((0, import_superstruct8.string)())
});
var Parameters = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: ParametersFields
});
var StakeSubsidyFields = (0, import_superstruct8.object)({
  balance: (0, import_superstruct8.object)({ value: (0, import_superstruct8.number)() }),
  current_epoch_amount: (0, import_superstruct8.number)(),
  epoch_counter: (0, import_superstruct8.number)()
});
var StakeSubsidy = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: StakeSubsidyFields
});
var SuiSupplyFields = (0, import_superstruct8.object)({
  value: (0, import_superstruct8.number)()
});
var ContentsFields = (0, import_superstruct8.object)({
  id: (0, import_superstruct8.string)(),
  size: (0, import_superstruct8.number)(),
  head: (0, import_superstruct8.object)({ vec: (0, import_superstruct8.array)() }),
  tail: (0, import_superstruct8.object)({ vec: (0, import_superstruct8.array)() })
});
var ContentsFieldsWithdraw = (0, import_superstruct8.object)({
  id: (0, import_superstruct8.string)(),
  size: (0, import_superstruct8.number)()
});
var Contents = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: ContentsFields
});
var PendingWithdawFields = (0, import_superstruct8.object)({
  contents: ContentsFieldsWithdraw
});
var DelegationStakingPoolFields = (0, import_superstruct8.object)({
  delegation_token_supply: SuiSupplyFields,
  pending_delegations: ContentsFields,
  pending_withdraws: PendingWithdawFields,
  rewards_pool: (0, import_superstruct8.object)({ value: (0, import_superstruct8.number)() }),
  starting_epoch: (0, import_superstruct8.number)(),
  sui_balance: (0, import_superstruct8.number)(),
  validator_address: (0, import_superstruct8.string)()
});
var DelegationStakingPool = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: DelegationStakingPoolFields
});
var CommitteeInfo = (0, import_superstruct8.object)({
  epoch: (0, import_superstruct8.number)(),
  protocol_version: (0, import_superstruct8.optional)((0, import_superstruct8.number)()),
  committee_info: (0, import_superstruct8.optional)((0, import_superstruct8.array)((0, import_superstruct8.tuple)([AuthorityName, (0, import_superstruct8.number)()])))
});
var SystemParameters = (0, import_superstruct8.object)({
  min_validator_stake: (0, import_superstruct8.number)(),
  max_validator_candidate_count: (0, import_superstruct8.number)(),
  storage_gas_price: (0, import_superstruct8.optional)((0, import_superstruct8.number)())
});
var Validator = (0, import_superstruct8.object)({
  metadata: ValidatorMetaData,
  voting_power: (0, import_superstruct8.number)(),
  stake_amount: (0, import_superstruct8.number)(),
  pending_stake: (0, import_superstruct8.number)(),
  pending_withdraw: (0, import_superstruct8.number)(),
  gas_price: (0, import_superstruct8.number)(),
  delegation_staking_pool: DelegationStakingPoolFields,
  commission_rate: (0, import_superstruct8.number)()
});
var ValidatorPair = (0, import_superstruct8.object)({
  from: SuiAddress,
  to: SuiAddress
});
var ValidatorSet = (0, import_superstruct8.object)({
  validator_stake: (0, import_superstruct8.number)(),
  delegation_stake: (0, import_superstruct8.number)(),
  active_validators: (0, import_superstruct8.array)(Validator),
  pending_validators: (0, import_superstruct8.array)(Validator),
  pending_removals: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  next_epoch_validators: (0, import_superstruct8.array)(ValidatorMetaData),
  pending_delegation_switches: (0, import_superstruct8.optional)(
    (0, import_superstruct8.object)({ contents: (0, import_superstruct8.array)(ValidatorPair) })
  )
});
var SuiSystemState = (0, import_superstruct8.object)({
  info: (0, import_superstruct8.object)({ id: (0, import_superstruct8.string)() }),
  epoch: (0, import_superstruct8.number)(),
  protocol_version: (0, import_superstruct8.optional)((0, import_superstruct8.number)()),
  validators: ValidatorSet,
  treasury_cap: SuiSupplyFields,
  storage_fund: Balance,
  parameters: SystemParameters,
  reference_gas_price: (0, import_superstruct8.number)(),
  validator_report_records: (0, import_superstruct8.object)({ contents: (0, import_superstruct8.array)() }),
  stake_subsidy: StakeSubsidyFields,
  safe_mode: (0, import_superstruct8.boolean)(),
  epoch_start_timestamp_ms: (0, import_superstruct8.optional)((0, import_superstruct8.number)())
});
var MovePendingWithdrawals = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: (0, import_superstruct8.object)({
    contents: (0, import_superstruct8.object)({
      type: (0, import_superstruct8.string)(),
      fields: (0, import_superstruct8.object)({
        id: (0, import_superstruct8.object)({
          id: (0, import_superstruct8.string)()
        }),
        size: (0, import_superstruct8.string)()
      })
    })
  })
});
var MovePendingDelegations = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: (0, import_superstruct8.object)({
    id: (0, import_superstruct8.object)({
      id: (0, import_superstruct8.string)()
    }),
    head: (0, import_superstruct8.nullable)((0, import_superstruct8.string)()),
    size: (0, import_superstruct8.string)(),
    tail: (0, import_superstruct8.nullable)((0, import_superstruct8.string)())
  })
});
var MoveDelegationStakingPoolFields = (0, import_superstruct8.object)({
  delegation_token_supply: (0, import_superstruct8.object)({
    type: (0, import_superstruct8.string)(),
    fields: (0, import_superstruct8.object)({
      value: (0, import_superstruct8.string)()
    })
  }),
  pending_delegations: MovePendingDelegations,
  pending_withdraws: MovePendingWithdrawals,
  rewards_pool: (0, import_superstruct8.string)(),
  starting_epoch: (0, import_superstruct8.string)(),
  sui_balance: (0, import_superstruct8.string)(),
  validator_address: (0, import_superstruct8.string)()
});
var ValidatorReportRecords = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: (0, import_superstruct8.object)({
    contents: (0, import_superstruct8.array)((0, import_superstruct8.any)())
  })
});
var MoveNextEpochValidatorFields = (0, import_superstruct8.object)({
  consensus_address: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  name: (0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.array)((0, import_superstruct8.number)())]),
  description: (0, import_superstruct8.optional)((0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.array)((0, import_superstruct8.number)())])),
  image_url: (0, import_superstruct8.optional)((0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.array)((0, import_superstruct8.number)())])),
  project_url: (0, import_superstruct8.optional)((0, import_superstruct8.union)([(0, import_superstruct8.string)(), (0, import_superstruct8.array)((0, import_superstruct8.number)())])),
  net_address: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  network_pubkey_bytes: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  next_epoch_commission_rate: (0, import_superstruct8.string)(),
  next_epoch_delegation: (0, import_superstruct8.string)(),
  next_epoch_gas_price: (0, import_superstruct8.string)(),
  next_epoch_stake: (0, import_superstruct8.string)(),
  proof_of_possession: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  pubkey_bytes: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  sui_address: (0, import_superstruct8.string)(),
  worker_address: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  worker_pubkey_bytes: (0, import_superstruct8.array)((0, import_superstruct8.number)())
});
var MoveNextEpochValidator = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: MoveNextEpochValidatorFields
});
var MoveActiveValidatorFields = (0, import_superstruct8.object)({
  commission_rate: (0, import_superstruct8.string)(),
  delegation_staking_pool: (0, import_superstruct8.object)({
    type: (0, import_superstruct8.string)(),
    fields: MoveDelegationStakingPoolFields
  }),
  gas_price: (0, import_superstruct8.string)(),
  metadata: MoveNextEpochValidator,
  pending_stake: (0, import_superstruct8.string)(),
  pending_withdraw: (0, import_superstruct8.string)(),
  stake_amount: (0, import_superstruct8.string)(),
  voting_power: (0, import_superstruct8.nullable)((0, import_superstruct8.string)())
});
var MoveActiveValidator = (0, import_superstruct8.object)({
  type: (0, import_superstruct8.string)(),
  fields: MoveActiveValidatorFields
});
var MoveValidatorsFieldsClass = (0, import_superstruct8.object)({
  active_validators: (0, import_superstruct8.array)(MoveActiveValidator),
  next_epoch_validators: (0, import_superstruct8.array)(MoveNextEpochValidator),
  pending_delegation_switches: (0, import_superstruct8.optional)(ValidatorReportRecords),
  pending_removals: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  pending_validators: (0, import_superstruct8.array)((0, import_superstruct8.number)()),
  quorum_stake_threshold: (0, import_superstruct8.optional)((0, import_superstruct8.string)()),
  total_delegation_stake: (0, import_superstruct8.string)(),
  total_validator_stake: (0, import_superstruct8.string)()
});
var MoveSuiSystemObjectFields = (0, import_superstruct8.object)({
  chain_id: (0, import_superstruct8.optional)((0, import_superstruct8.number)()),
  epoch: (0, import_superstruct8.string)(),
  protocol_version: (0, import_superstruct8.optional)((0, import_superstruct8.string)()),
  epoch_start_timestamp_ms: (0, import_superstruct8.optional)((0, import_superstruct8.string)()),
  safe_mode: (0, import_superstruct8.boolean)(),
  id: (0, import_superstruct8.object)({
    id: (0, import_superstruct8.string)()
  }),
  parameters: Parameters,
  reference_gas_price: (0, import_superstruct8.string)(),
  stake_subsidy: (0, import_superstruct8.object)({
    type: (0, import_superstruct8.string)(),
    fields: (0, import_superstruct8.object)({
      balance: (0, import_superstruct8.string)(),
      current_epoch_amount: (0, import_superstruct8.string)(),
      epoch_counter: (0, import_superstruct8.string)()
    })
  }),
  storage_fund: (0, import_superstruct8.string)(),
  sui_supply: (0, import_superstruct8.object)({
    type: (0, import_superstruct8.string)(),
    fields: (0, import_superstruct8.object)({
      value: (0, import_superstruct8.string)()
    })
  }),
  validator_report_records: ValidatorReportRecords,
  validators: (0, import_superstruct8.object)({
    type: (0, import_superstruct8.string)(),
    fields: MoveValidatorsFieldsClass
  })
});
var MoveSuiSystemObject = (0, import_superstruct8.object)({
  dataType: (0, import_superstruct8.literal)("moveObject"),
  type: (0, import_superstruct8.string)(),
  has_public_transfer: (0, import_superstruct8.boolean)(),
  fields: MoveSuiSystemObjectFields
});

// src/types/coin.ts
var import_superstruct9 = require("superstruct");
var CoinStruct = (0, import_superstruct9.object)({
  coinType: (0, import_superstruct9.string)(),
  coinObjectId: ObjectId,
  version: (0, import_superstruct9.number)(),
  digest: TransactionDigest,
  balance: (0, import_superstruct9.number)(),
  lockedUntilEpoch: (0, import_superstruct9.nullable)((0, import_superstruct9.number)()),
  previousTransaction: (0, import_superstruct9.optional)(TransactionDigest)
});
var PaginatedCoins = (0, import_superstruct9.object)({
  data: (0, import_superstruct9.array)(CoinStruct),
  nextCursor: (0, import_superstruct9.union)([ObjectId, (0, import_superstruct9.literal)(null)])
});
var CoinBalance = (0, import_superstruct9.object)({
  coinType: (0, import_superstruct9.string)(),
  coinObjectCount: (0, import_superstruct9.number)(),
  totalBalance: (0, import_superstruct9.number)(),
  lockedBalance: (0, import_superstruct9.object)({
    epochId: (0, import_superstruct9.optional)((0, import_superstruct9.number)()),
    number: (0, import_superstruct9.optional)((0, import_superstruct9.number)())
  })
});
var CoinSupply = (0, import_superstruct9.object)({
  value: (0, import_superstruct9.number)()
});

// src/types/checkpoints.ts
var import_superstruct10 = require("superstruct");
var GasCostSummary2 = (0, import_superstruct10.object)({
  computation_cost: (0, import_superstruct10.number)(),
  storage_cost: (0, import_superstruct10.number)(),
  storage_rebate: (0, import_superstruct10.number)()
});
var CheckPointContentsDigest = (0, import_superstruct10.string)();
var CheckpointDigest = (0, import_superstruct10.string)();
var EndOfEpochData = (0, import_superstruct10.object)({
  next_epoch_committee: (0, import_superstruct10.array)((0, import_superstruct10.tuple)([(0, import_superstruct10.string)(), (0, import_superstruct10.number)()])),
  next_epoch_protocol_version: (0, import_superstruct10.number)(),
  root_state_digest: (0, import_superstruct10.optional)((0, import_superstruct10.array)((0, import_superstruct10.number)()))
});
var CheckpointSummary = (0, import_superstruct10.object)({
  epoch: (0, import_superstruct10.number)(),
  sequence_number: (0, import_superstruct10.number)(),
  network_total_transactions: (0, import_superstruct10.number)(),
  content_digest: CheckPointContentsDigest,
  previous_digest: (0, import_superstruct10.union)([CheckpointDigest, (0, import_superstruct10.literal)(null)]),
  epoch_rolling_gas_cost_summary: GasCostSummary2,
  end_of_epoch_data: (0, import_superstruct10.union)([EndOfEpochData, (0, import_superstruct10.literal)(null)]),
  timestamp_ms: (0, import_superstruct10.union)([(0, import_superstruct10.number)(), (0, import_superstruct10.literal)(null)]),
  version_specific_data: (0, import_superstruct10.optional)((0, import_superstruct10.array)((0, import_superstruct10.number)()))
});
var ExecutionDigests = (0, import_superstruct10.object)({
  transaction: TransactionDigest,
  effects: TransactionEffectsDigest
});
var CheckpointContents = (0, import_superstruct10.object)({
  transactions: (0, import_superstruct10.array)(ExecutionDigests),
  user_signatures: (0, import_superstruct10.array)((0, import_superstruct10.string)())
});

// src/types/dynamic_fields.ts
var import_superstruct11 = require("superstruct");
var DynamicFieldType = (0, import_superstruct11.union)([
  (0, import_superstruct11.literal)("DynamicField"),
  (0, import_superstruct11.literal)("DynamicObject")
]);
var DynamicFieldName = (0, import_superstruct11.object)({
  type: (0, import_superstruct11.string)(),
  value: (0, import_superstruct11.any)()
});
var DynamicFieldInfo = (0, import_superstruct11.object)({
  name: (0, import_superstruct11.union)([DynamicFieldName, (0, import_superstruct11.string)()]),
  type: DynamicFieldType,
  objectType: (0, import_superstruct11.string)(),
  objectId: ObjectId,
  version: (0, import_superstruct11.number)(),
  digest: (0, import_superstruct11.string)()
});
var DynamicFieldPage = (0, import_superstruct11.object)({
  data: (0, import_superstruct11.array)(DynamicFieldInfo),
  nextCursor: (0, import_superstruct11.union)([ObjectId, (0, import_superstruct11.literal)(null)])
});

// src/rpc/websocket-client.ts
var import_superstruct12 = require("superstruct");
var import_rpc_websockets = require("rpc-websockets");
var getWebsocketUrl = (httpUrl, port) => {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  if (port) {
    url.port = port.toString();
  }
  return url.toString();
};
var isMinimumSubscriptionMessage = (msg) => msg && "subscription" in msg && typeof msg["subscription"] === "number" && "result" in msg && typeof msg["result"] === "object";
var DEFAULT_CLIENT_OPTIONS = {
  connectTimeout: 15e3,
  callTimeout: 3e4,
  reconnectInterval: 3e3,
  maxReconnects: 5
};
var SUBSCRIBE_EVENT_METHOD = "sui_subscribeEvent";
var UNSUBSCRIBE_EVENT_METHOD = "sui_unsubscribeEvent";
var WebsocketClient = class {
  constructor(endpoint, skipValidation, options = DEFAULT_CLIENT_OPTIONS) {
    this.endpoint = endpoint;
    this.skipValidation = skipValidation;
    this.options = options;
    this.connectionState = 0 /* NotConnected */;
    this.connectionTimeout = null;
    this.isSetup = false;
    this.connectionPromise = null;
    this.eventSubscriptions = /* @__PURE__ */ new Map();
    if (this.endpoint.startsWith("http"))
      this.endpoint = getWebsocketUrl(this.endpoint);
    this.rpcClient = new import_rpc_websockets.Client(this.endpoint, {
      reconnect_interval: this.options.reconnectInterval,
      max_reconnects: this.options.maxReconnects,
      autoconnect: false
    });
  }
  setupSocket() {
    if (this.isSetup)
      return;
    this.rpcClient.on("open", () => {
      if (this.connectionTimeout) {
        clearTimeout(this.connectionTimeout);
        this.connectionTimeout = null;
      }
      this.connectionState = 2 /* Connected */;
      this.rpcClient.socket.on(
        "message",
        this.onSocketMessage.bind(this)
      );
    });
    this.rpcClient.on("close", () => {
      this.connectionState = 0 /* NotConnected */;
    });
    this.rpcClient.on("error", console.error);
    this.isSetup = true;
  }
  onSocketMessage(rawMessage) {
    const msg = JSON.parse(rawMessage);
    const params = msg.params;
    if (msg.method === SUBSCRIBE_EVENT_METHOD) {
      if (this.skipValidation && isMinimumSubscriptionMessage(params)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      } else if ((0, import_superstruct12.is)(params, SubscriptionEvent)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      }
    }
  }
  connect() {
    return __async(this, null, function* () {
      if (this.connectionPromise)
        return this.connectionPromise;
      if (this.connectionState === 2 /* Connected */)
        return Promise.resolve();
      this.setupSocket();
      this.rpcClient.connect();
      this.connectionState = 1 /* Connecting */;
      this.connectionPromise = new Promise((resolve, reject) => {
        this.connectionTimeout = setTimeout(
          () => reject(new Error("timeout")),
          this.options.connectTimeout
        );
        this.rpcClient.once("open", () => {
          this.refreshSubscriptions();
          this.connectionPromise = null;
          resolve();
        });
        this.rpcClient.once("error", (err) => {
          this.connectionPromise = null;
          reject(err);
        });
      });
      return this.connectionPromise;
    });
  }
  refreshSubscriptions() {
    return __async(this, null, function* () {
      if (this.eventSubscriptions.size === 0)
        return;
      try {
        let newSubs = /* @__PURE__ */ new Map();
        let newSubsArr = yield Promise.all(
          Array.from(this.eventSubscriptions.values()).map((sub) => __async(this, null, function* () {
            const onMessage = sub.onMessage;
            const filter = sub.filter;
            if (!filter || !onMessage)
              return Promise.resolve(null);
            const id = yield this.subscribeEvent(filter, onMessage);
            return { id, onMessage, filter };
          }))
        );
        newSubsArr.forEach((entry) => {
          if (entry === null)
            return;
          const filter = entry.filter;
          const onMessage = entry.onMessage;
          newSubs.set(entry.id, { filter, onMessage });
        });
        this.eventSubscriptions = newSubs;
      } catch (err) {
        throw new Error(`error refreshing event subscriptions: ${err}`);
      }
    });
  }
  subscribeEvent(filter, onMessage) {
    return __async(this, null, function* () {
      try {
        if (this.connectionState !== 2 /* Connected */)
          yield this.connect();
        let subId = yield this.rpcClient.call(
          SUBSCRIBE_EVENT_METHOD,
          [filter],
          this.options.callTimeout
        );
        this.eventSubscriptions.set(subId, { filter, onMessage });
        return subId;
      } catch (err) {
        throw new Error(
          `Error subscribing to event: ${JSON.stringify(
            err,
            null,
            2
          )}, filter: ${JSON.stringify(filter)}`
        );
      }
    });
  }
  unsubscribeEvent(id) {
    return __async(this, null, function* () {
      try {
        if (this.connectionState !== 2 /* Connected */)
          yield this.connect();
        let removedOnNode = yield this.rpcClient.call(
          UNSUBSCRIBE_EVENT_METHOD,
          [id],
          this.options.callTimeout
        );
        return this.eventSubscriptions.delete(id) || removedOnNode;
      } catch (err) {
        throw new Error(
          `Error unsubscribing from event: ${err}, subscription: ${id}`
        );
      }
    });
  }
};

// src/rpc/faucet-client.ts
var import_cross_fetch2 = __toESM(require("cross-fetch"));
var FaucetRateLimitError = class extends Error {
};
function requestSuiFromFaucet(endpoint, recipient, httpHeaders) {
  return __async(this, null, function* () {
    const res = yield (0, import_cross_fetch2.default)(endpoint, {
      method: "POST",
      body: JSON.stringify({
        FixedAmountRequest: {
          recipient
        }
      }),
      headers: __spreadValues({
        "Content-Type": "application/json"
      }, httpHeaders || {})
    });
    if (res.status === 429) {
      throw new FaucetRateLimitError(
        `Too many requests from this client have been sent to the faucet. Please retry later`
      );
    }
    let parsed;
    try {
      parsed = yield res.json();
    } catch (e) {
      throw new Error(
        `Ecountered error when parsing response from faucet, error: ${e}, status ${res.status}, response ${res}`
      );
    }
    if (parsed.error) {
      throw new Error(`Faucet returns error: ${parsed.error}`);
    }
    return parsed;
  });
}

// src/providers/json-rpc-provider.ts
var import_superstruct13 = require("superstruct");

// src/signers/txn-data-serializers/call-arg-serializer.ts
var MOVE_CALL_SER_ERROR = "Move call argument serialization error:";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
var RESOLVED_SUI_ID = {
  address: SUI_FRAMEWORK_ADDRESS,
  module: OBJECT_MODULE_NAME,
  name: ID_STRUCT_NAME
};
var RESOLVED_ASCII_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_ASCII_MODULE_NAME,
  name: STD_ASCII_STRUCT_NAME
};
var RESOLVED_UTF8_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_UTF8_MODULE_NAME,
  name: STD_UTF8_STRUCT_NAME
};
var RESOLVED_STD_OPTION = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_OPTION_MODULE_NAME,
  name: STD_OPTION_STRUCT_NAME
};
var isTypeFunc = (type) => (t) => typeof t === type;
var isSameStruct = (a, b) => a.address === b.address && a.module === b.module && a.name === b.name;
var CallArgSerializer = class {
  constructor(provider) {
    this.provider = provider;
  }
  extractObjectIds(txn) {
    return __async(this, null, function* () {
      const args = yield this.serializeMoveCallArguments(txn);
      return args.map(
        (arg) => "ObjVec" in arg ? Array.from(arg.ObjVec).map((a) => ({
          Object: a
        })) : arg
      ).flat().map((arg) => {
        if ("Object" in arg) {
          const objectArg = arg.Object;
          if ("Shared" in objectArg) {
            return objectArg.Shared.objectId;
          } else {
            return objectArg.ImmOrOwned.objectId;
          }
        }
        return null;
      }).filter((a) => a != null);
    });
  }
  serializeMoveCallArguments(txn) {
    return __async(this, null, function* () {
      const userParams = yield this.extractNormalizedFunctionParams(
        txn.packageObjectId,
        txn.module,
        txn.function
      );
      if (userParams.length !== txn.arguments.length) {
        throw new Error(
          `${MOVE_CALL_SER_ERROR} expect ${userParams.length} arguments, received ${txn.arguments.length} arguments`
        );
      }
      return Promise.all(
        userParams.map(
          (param, i) => __async(this, null, function* () {
            return this.newCallArg(param, txn.arguments[i]);
          })
        )
      );
    });
  }
  deserializeCallArgs(txn) {
    return __async(this, null, function* () {
      const userParams = yield this.extractNormalizedFunctionParams(
        txn.Call.package,
        txn.Call.module,
        txn.Call.function
      );
      return Promise.all(
        userParams.map(
          (param, i) => __async(this, null, function* () {
            return this.deserializeCallArg(param, txn.Call.arguments[i]);
          })
        )
      );
    });
  }
  extractNormalizedFunctionParams(packageId, module2, functionName) {
    return __async(this, null, function* () {
      const normalized = yield this.provider.getNormalizedMoveFunction(
        normalizeSuiObjectId(
          typeof packageId === "string" ? packageId : packageId.objectId
        ),
        module2,
        functionName
      );
      const params = normalized.parameters;
      const hasTxContext = params.length > 0 && this.isTxContext(params.at(-1));
      return hasTxContext ? params.slice(0, params.length - 1) : params;
    });
  }
  newObjectArg(objectId) {
    return __async(this, null, function* () {
      const object12 = yield this.provider.getObject(objectId);
      const initialSharedVersion = getSharedObjectInitialVersion(object12);
      const mutable = true;
      if (initialSharedVersion) {
        return { Shared: { objectId, initialSharedVersion, mutable } };
      }
      return { ImmOrOwned: getObjectReference(object12) };
    });
  }
  newCallArg(expectedType, argVal) {
    return __async(this, null, function* () {
      if (isPureArg(argVal)) {
        return argVal;
      }
      const serType = this.getPureSerializationType(expectedType, argVal);
      const version = yield this.provider.getRpcApiVersion();
      if (serType !== void 0) {
        return {
          Pure: bcsForVersion(version).ser(serType, argVal).toBytes()
        };
      }
      const structVal = extractStructTag(expectedType);
      if (structVal != null || typeof expectedType === "object" && "TypeParameter" in expectedType) {
        if (typeof argVal !== "string") {
          throw new Error(
            `${MOVE_CALL_SER_ERROR} expect the argument to be an object id string, got ${JSON.stringify(
              argVal,
              null,
              2
            )}`
          );
        }
        return { Object: yield this.newObjectArg(argVal) };
      }
      if (typeof expectedType === "object" && "Vector" in expectedType && typeof expectedType.Vector === "object" && "Struct" in expectedType.Vector) {
        if (!Array.isArray(argVal)) {
          throw new Error(
            `Expect ${argVal} to be a array, received ${typeof argVal}`
          );
        }
        return {
          ObjVec: yield Promise.all(
            argVal.map((arg) => this.newObjectArg(arg))
          )
        };
      }
      throw new Error(
        `Unknown call arg type ${JSON.stringify(expectedType, null, 2)} for value ${JSON.stringify(argVal, null, 2)}`
      );
    });
  }
  extractIdFromObjectArg(arg) {
    if ("ImmOrOwned" in arg) {
      return arg.ImmOrOwned.objectId;
    }
    return arg.Shared.objectId;
  }
  deserializeCallArg(expectedType, argVal) {
    return __async(this, null, function* () {
      if ("Object" in argVal) {
        return this.extractIdFromObjectArg(argVal.Object);
      } else if ("ObjVec" in argVal) {
        return Array.from(argVal.ObjVec).map(
          (o) => this.extractIdFromObjectArg(o)
        );
      }
      const serType = this.getPureSerializationType(expectedType, void 0);
      const version = yield this.provider.getRpcApiVersion();
      return bcsForVersion(version).de(serType, Uint8Array.from(argVal.Pure));
    });
  }
  getPureSerializationType(normalizedType, argVal) {
    const allowedTypes = [
      "Address",
      "Bool",
      "U8",
      "U16",
      "U32",
      "U64",
      "U128",
      "U256"
    ];
    if (typeof normalizedType === "string" && allowedTypes.includes(normalizedType)) {
      if (normalizedType in ["U8", "U16", "U32", "U64", "U128", "U256"]) {
        this.checkArgVal(isTypeFunc("number"), argVal, "number");
      } else if (normalizedType === "Bool") {
        this.checkArgVal(isTypeFunc("boolean"), argVal, "boolean");
      } else if (normalizedType === "Address") {
        this.checkArgVal(
          (t) => typeof t === "string" && isValidSuiAddress(t),
          argVal,
          "valid SUI address"
        );
      }
      return normalizedType.toLowerCase();
    } else if (typeof normalizedType === "string") {
      throw new Error(
        `${MOVE_CALL_SER_ERROR} unknown pure normalized type ${JSON.stringify(
          normalizedType,
          null,
          2
        )}`
      );
    }
    if ("Vector" in normalizedType) {
      if ((argVal === void 0 || typeof argVal === "string") && normalizedType.Vector === "U8") {
        return "string";
      }
      if (argVal !== void 0 && !Array.isArray(argVal)) {
        throw new Error(
          `Expect ${argVal} to be a array, received ${typeof argVal}`
        );
      }
      const innerType = this.getPureSerializationType(
        normalizedType.Vector,
        argVal ? argVal[0] : void 0
      );
      if (innerType === void 0) {
        return void 0;
      }
      return `vector<${innerType}>`;
    }
    if ("Struct" in normalizedType) {
      if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {
        return "string";
      } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {
        return "utf8string";
      } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {
        return "address";
      } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {
        const optionToVec = {
          Vector: normalizedType.Struct.type_arguments[0]
        };
        return this.getPureSerializationType(optionToVec, argVal);
      }
    }
    return void 0;
  }
  checkArgVal(check, argVal, expectedType) {
    if (argVal === void 0) {
      return;
    }
    if (!check(argVal)) {
      throw new Error(
        `Expect ${argVal} to be ${expectedType}, received ${typeof argVal}`
      );
    }
  }
  isTxContext(param) {
    var _a;
    const struct = (_a = extractStructTag(param)) == null ? void 0 : _a.Struct;
    return extractMutableReference(param) != null && (struct == null ? void 0 : struct.address) === "0x2" && (struct == null ? void 0 : struct.module) === "tx_context" && (struct == null ? void 0 : struct.name) === "TxContext";
  }
};

// src/signers/txn-data-serializers/type-tag-serializer.ts
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: TypeTagSerializer.parseFromStr(
          vectorMatch[1],
          normalizeAddress
        )
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(
            structMatch[5],
            normalizeAddress
          )
        }
      };
    }
    throw new Error(
      `Encountered unexpected token when parsing type args for ${str}`
    );
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    const tok = [];
    let word = "";
    let nestedAngleBrackets = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === "<") {
        nestedAngleBrackets++;
      }
      if (char === ">") {
        nestedAngleBrackets--;
      }
      if (nestedAngleBrackets === 0 && char === ",") {
        tok.push(word.trim());
        word = "";
        continue;
      }
      word += char;
    }
    tok.push(word.trim());
    return tok.map(
      (tok2) => TypeTagSerializer.parseFromStr(tok2, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// src/signers/txn-data-serializers/local-txn-data-serializer.ts
var LocalTxnDataSerializer = class {
  constructor(provider) {
    this.provider = provider;
  }
  getRpcApiVersion() {
    return __async(this, null, function* () {
      return yield this.provider.getRpcApiVersion();
    });
  }
  serializeToBytes(signerAddress, txn, _mode = "Commit") {
    return __async(this, null, function* () {
      try {
        return yield this.serializeTransactionData(
          yield this.constructTransactionData(signerAddress, txn)
        );
      } catch (e) {
        throw new Error(
          `Encountered error when serializing a ${txn.kind} transaction for address ${signerAddress} for transaction ${JSON.stringify(
            txn,
            null,
            2
          )}: ${e}`
        );
      }
    });
  }
  serializeToBytesWithoutGasInfo(signerAddress, txn) {
    return __async(this, null, function* () {
      try {
        return yield this.serializeTransactionKind(
          (yield this.constructTransactionKindAndPayment(signerAddress, txn))[0]
        );
      } catch (e) {
        throw new Error(
          `Encountered error when serializing a ${txn.kind} transaction without gas info for address ${signerAddress} for transaction ${JSON.stringify(
            txn,
            null,
            2
          )}: ${e}`
        );
      }
    });
  }
  constructTransactionKindAndPayment(signerAddress, unserializedTxn) {
    return __async(this, null, function* () {
      let tx;
      let gasPayment;
      switch (unserializedTxn.kind) {
        case "transferObject":
          const t = unserializedTxn.data;
          const objectRef = yield this.provider.getObjectRef(t.objectId);
          tx = {
            TransferObject: {
              recipient: t.recipient,
              object_ref: objectRef
            }
          };
          gasPayment = t.gasPayment;
          break;
        case "transferSui":
          const transferSui = unserializedTxn.data;
          tx = {
            TransferSui: {
              recipient: transferSui.recipient,
              amount: transferSui.amount == null ? { None: null } : { Some: transferSui.amount }
            }
          };
          gasPayment = transferSui.suiObjectId;
          break;
        case "pay":
          const pay = unserializedTxn.data;
          const inputCoinRefs = (yield Promise.all(
            pay.inputCoins.map((coin) => this.provider.getObjectRef(coin))
          )).map((ref) => ref);
          tx = {
            Pay: {
              coins: inputCoinRefs,
              recipients: pay.recipients,
              amounts: pay.amounts
            }
          };
          gasPayment = pay.gasPayment;
          break;
        case "paySui":
          const paySui = unserializedTxn.data;
          const paySuiInputCoinRefs = (yield Promise.all(
            paySui.inputCoins.map((coin) => this.provider.getObjectRef(coin))
          )).map((ref) => ref);
          tx = {
            PaySui: {
              coins: paySuiInputCoinRefs,
              recipients: paySui.recipients,
              amounts: paySui.amounts
            }
          };
          gasPayment = paySui.inputCoins[0];
          break;
        case "payAllSui":
          const payAllSui = unserializedTxn.data;
          const payAllSuiInputCoinRefs = (yield Promise.all(
            payAllSui.inputCoins.map(
              (coin) => this.provider.getObjectRef(coin)
            )
          )).map((ref) => ref);
          tx = {
            PayAllSui: {
              coins: payAllSuiInputCoinRefs,
              recipient: payAllSui.recipient
            }
          };
          gasPayment = payAllSui.inputCoins[0];
          break;
        case "moveCall":
          const moveCall = unserializedTxn.data;
          const pkg = normalizeSuiObjectId(moveCall.packageObjectId);
          tx = {
            Call: {
              package: pkg,
              module: moveCall.module,
              function: moveCall.function,
              typeArguments: moveCall.typeArguments.map(
                (a) => typeof a === "string" ? TypeTagSerializer.parseFromStr(a, true) : a
              ),
              arguments: yield new CallArgSerializer(
                this.provider
              ).serializeMoveCallArguments(moveCall)
            }
          };
          gasPayment = moveCall.gasPayment;
          break;
        case "mergeCoin":
          const mergeCoin = unserializedTxn.data;
          return this.constructTransactionKindAndPayment(signerAddress, {
            kind: "moveCall",
            data: {
              packageObjectId: SUI_FRAMEWORK_ADDRESS,
              module: PAY_MODULE_NAME,
              function: PAY_JOIN_COIN_FUNC_NAME,
              typeArguments: [yield this.getCoinStructTag(mergeCoin.coinToMerge)],
              arguments: [mergeCoin.primaryCoin, mergeCoin.coinToMerge],
              gasPayment: mergeCoin.gasPayment,
              gasBudget: mergeCoin.gasBudget
            }
          });
        case "splitCoin":
          const splitCoin = unserializedTxn.data;
          return this.constructTransactionKindAndPayment(signerAddress, {
            kind: "moveCall",
            data: {
              packageObjectId: SUI_FRAMEWORK_ADDRESS,
              module: PAY_MODULE_NAME,
              function: PAY_SPLIT_COIN_VEC_FUNC_NAME,
              typeArguments: [
                yield this.getCoinStructTag(splitCoin.coinObjectId)
              ],
              arguments: [splitCoin.coinObjectId, splitCoin.splitAmounts],
              gasPayment: splitCoin.gasPayment,
              gasBudget: splitCoin.gasBudget
            }
          });
        case "publish":
          const publish = unserializedTxn.data;
          tx = {
            Publish: {
              modules: publish.compiledModules
            }
          };
          gasPayment = publish.gasPayment;
          break;
      }
      return [{ Single: tx }, gasPayment];
    });
  }
  constructTransactionData(signerAddress, unserializedTxn) {
    return __async(this, null, function* () {
      const [tx, gasPayment] = yield this.constructTransactionKindAndPayment(
        signerAddress,
        unserializedTxn
      );
      return this.constructTransactionDataHelper(
        tx,
        unserializedTxn,
        gasPayment,
        signerAddress
      );
    });
  }
  selectGasPaymentForTransaction(_0, _1) {
    return __async(this, arguments, function* (txn, signerAddress, exclude = []) {
      if (txn.kind === "bytes") {
        return void 0;
      }
      const requiredGasAmount = BigInt(txn.data.gasBudget) * BigInt(txn.data.gasPrice);
      const coins = yield this.provider.selectCoinsWithBalanceGreaterThanOrEqual(
        signerAddress,
        requiredGasAmount,
        SUI_TYPE_ARG,
        exclude.concat(yield this.extractObjectIds(txn))
      );
      return coins.length > 0 ? Coin.getID(coins[0]) : void 0;
    });
  }
  extractObjectIds(txn) {
    return __async(this, null, function* () {
      const ret = yield this.extractInputObjectIds(txn);
      if ("gasPayment" in txn.data && txn.data["gasPayment"]) {
        ret.push(txn.data["gasPayment"]);
      }
      return ret;
    });
  }
  extractInputObjectIds(txn) {
    return __async(this, null, function* () {
      switch (txn.kind) {
        case "moveCall":
          return yield new CallArgSerializer(this.provider).extractObjectIds(
            txn.data
          );
        case "transferSui":
          return [txn.data.suiObjectId];
        case "transferObject":
          return [txn.data.objectId];
        case "mergeCoin":
          return [txn.data.primaryCoin, txn.data.coinToMerge];
        case "splitCoin":
          return [txn.data.coinObjectId];
        case "pay":
          return txn.data.inputCoins;
      }
      return [];
    });
  }
  getCoinStructTag(coinId) {
    return __async(this, null, function* () {
      const coin = yield this.provider.getObject(coinId);
      const coinTypeArg = Coin.getCoinTypeArg(coin);
      if (coinTypeArg == null) {
        throw new Error(`Object ${coinId} is not a valid coin type`);
      }
      return { struct: Coin.getCoinStructTag(coinTypeArg) };
    });
  }
  constructTransactionDataHelper(tx, originalTx, gasObjectId, signerAddress) {
    return __async(this, null, function* () {
      originalTx.data.gasPrice = yield this.provider.getReferenceGasPrice();
      if (gasObjectId === void 0) {
        gasObjectId = yield this.selectGasPaymentForTransaction(
          originalTx,
          signerAddress
        );
        if (gasObjectId === void 0) {
          throw new Error(
            `Unable to select a gas object with balance greater than or equal to ${originalTx.data.gasBudget}`
          );
        }
      }
      const gasPayment = yield this.provider.getObjectRef(gasObjectId);
      if (!originalTx.data.gasBudget) {
        throw new Error(
          "Must provide a valid gas budget for contructing TransactionData"
        );
      }
      return {
        kind: tx,
        sender: signerAddress,
        gasData: {
          payment: gasPayment,
          price: originalTx.data.gasPrice,
          budget: originalTx.data.gasBudget,
          owner: signerAddress
        },
        expiration: { None: null }
      };
    });
  }
  serializeTransactionData(tx, size = 8192) {
    return __async(this, null, function* () {
      const bcs2 = bcsForVersion(yield this.provider.getRpcApiVersion());
      const dataBytes = bcs2.ser("TransactionData", tx, size).toBytes();
      return dataBytes;
    });
  }
  serializeTransactionKind(tx, size = 8192) {
    return __async(this, null, function* () {
      const bcs2 = bcsForVersion(yield this.provider.getRpcApiVersion());
      const dataBytes = bcs2.ser("TransactionKind", tx, size).toBytes();
      return dataBytes;
    });
  }
  deserializeTransactionBytesToSignableTransaction(bytes) {
    return __async(this, null, function* () {
      let version = yield this.provider.getRpcApiVersion();
      return this.transformTransactionDataToSignableTransaction(
        deserializeTransactionBytesToTransactionData(
          bcsForVersion(version),
          bytes
        )
      );
    });
  }
  transformTransactionDataToSignableTransaction(tx_data) {
    return __async(this, null, function* () {
      if ("Single" in tx_data.kind) {
        return this.transformTransactionToSignableTransaction(
          tx_data.kind.Single,
          tx_data.gasData
        );
      }
      return Promise.all(
        tx_data.kind.Batch.map(
          (t) => this.transformTransactionToSignableTransaction(t, tx_data.gasData)
        )
      );
    });
  }
  transformTransactionToSignableTransaction(tx, gasData) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      if ("Pay" in tx) {
        return {
          kind: "pay",
          data: {
            inputCoins: tx.Pay.coins.map((c) => c.objectId),
            recipients: tx.Pay.recipients,
            amounts: tx.Pay.amounts,
            gasPayment: (_a = gasData.payment) == null ? void 0 : _a.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner,
            gasPrice: gasData.price
          }
        };
      } else if ("Call" in tx) {
        return {
          kind: "moveCall",
          data: {
            packageObjectId: tx.Call.package,
            module: tx.Call.module,
            function: tx.Call.function,
            typeArguments: tx.Call.typeArguments,
            arguments: yield new CallArgSerializer(
              this.provider
            ).deserializeCallArgs(tx),
            gasPayment: (_b = gasData.payment) == null ? void 0 : _b.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner,
            gasPrice: gasData.price
          }
        };
      } else if ("TransferObject" in tx) {
        return {
          kind: "transferObject",
          data: {
            objectId: tx.TransferObject.object_ref.objectId,
            recipient: tx.TransferObject.recipient,
            gasPayment: (_c = gasData.payment) == null ? void 0 : _c.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner,
            gasPrice: gasData.price
          }
        };
      } else if ("TransferSui" in tx) {
        return {
          kind: "transferSui",
          data: {
            suiObjectId: gasData.payment.objectId,
            recipient: tx.TransferSui.recipient,
            amount: "Some" in tx.TransferSui.amount ? tx.TransferSui.amount.Some : null,
            gasBudget: gasData.budget,
            gasPrice: gasData.price
          }
        };
      } else if ("Publish" in tx) {
        return {
          kind: "publish",
          data: {
            compiledModules: tx.Publish.modules,
            gasPayment: (_d = gasData.payment) == null ? void 0 : _d.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner
          }
        };
      } else if ("PaySui" in tx) {
        return {
          kind: "paySui",
          data: {
            inputCoins: tx.PaySui.coins.map((c) => c.objectId),
            recipients: tx.PaySui.recipients,
            amounts: tx.PaySui.amounts
          }
        };
      } else if ("PayAllSui" in tx) {
        return {
          kind: "payAllSui",
          data: {
            inputCoins: tx.PayAllSui.coins.map((c) => c.objectId),
            recipient: tx.PayAllSui.recipient
          }
        };
      }
      throw new Error(`Unsupported transaction type ${tx}`);
    });
  }
};

// src/providers/json-rpc-provider.ts
var import_bcs12 = require("@mysten/bcs");

// src/rpc/connection.ts
var _options;
var Connection = class {
  constructor(options) {
    __privateAdd(this, _options, void 0);
    __privateSet(this, _options, options);
  }
  get fullnode() {
    return __privateGet(this, _options).fullnode;
  }
  get websocket() {
    return __privateGet(this, _options).websocket || __privateGet(this, _options).fullnode;
  }
  get faucet() {
    return __privateGet(this, _options).faucet;
  }
};
_options = new WeakMap();
var localnetConnection = new Connection({
  fullnode: "http://127.0.0.1:9000",
  faucet: "http://127.0.0.1:9123/gas"
});
var devnetConnection = new Connection({
  fullnode: "https://fullnode.devnet.sui.io:443/",
  faucet: "https://faucet.devnet.sui.io/gas"
});

// src/providers/json-rpc-provider.ts
var TARGETED_RPC_VERSION = "0.27.0";
var DEFAULT_OPTIONS = {
  skipDataValidation: true,
  socketOptions: DEFAULT_CLIENT_OPTIONS,
  versionCacheTimeoutInSeconds: 600
};
var JsonRpcProvider = class extends Provider {
  constructor(connection = devnetConnection, options = DEFAULT_OPTIONS) {
    var _a, _b;
    super();
    this.options = options;
    this.connection = connection;
    const opts = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), options);
    this.options = opts;
    this.client = (_a = opts.rpcClient) != null ? _a : new JsonRpcClient(this.connection.fullnode);
    this.wsClient = (_b = opts.websocketClient) != null ? _b : new WebsocketClient(
      this.connection.websocket,
      opts.skipDataValidation,
      opts.socketOptions
    );
  }
  getRpcApiVersion() {
    return __async(this, null, function* () {
      var _a;
      if (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now()) {
        return this.rpcApiVersion;
      }
      try {
        const resp = yield this.client.requestWithType(
          "rpc.discover",
          [],
          (0, import_superstruct13.any)(),
          this.options.skipDataValidation
        );
        this.rpcApiVersion = parseVersionFromString(resp.info.version);
        this.cacheExpiry = Date.now() + ((_a = this.options.versionCacheTimeoutInSeconds) != null ? _a : 0) * 1e3;
        return this.rpcApiVersion;
      } catch (err) {
        console.warn("Error fetching version number of the RPC API", err);
      }
      return void 0;
    });
  }
  requestSuiFromFaucet(recipient, httpHeaders) {
    return __async(this, null, function* () {
      if (!this.connection.faucet) {
        throw new Error("Faucet URL is not specified");
      }
      return requestSuiFromFaucet(this.connection.faucet, recipient, httpHeaders);
    });
  }
  getCoins(owner, coinType = null, cursor = null, limit = null) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getCoins",
          [owner, coinType, cursor, limit],
          PaginatedCoins,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting coins for owner ${owner}: ${err}`);
      }
    });
  }
  getAllCoins(owner, cursor = null, limit = null) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getAllCoins",
          [owner, cursor, limit],
          PaginatedCoins,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting all coins for owner ${owner}: ${err}`);
      }
    });
  }
  getBalance(owner, coinType = null) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getBalance",
          [owner, coinType],
          CoinBalance,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting balance for coin type ${coinType} for owner ${owner}: ${err}`
        );
      }
    });
  }
  getAllBalances(owner) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getAllBalances",
          [owner],
          (0, import_superstruct13.array)(CoinBalance),
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting all balances for owner ${owner}: ${err}`);
      }
    });
  }
  getCoinMetadata(coinType) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getCoinMetadata",
          [coinType],
          CoinMetadataStruct,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error fetching CoinMetadata for ${coinType}: ${err}`);
      }
    });
  }
  getTotalSupply(coinType) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getTotalSupply",
          [coinType],
          CoinSupply,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching total supply for Coin type ${coinType}: ${err}`
        );
      }
    });
  }
  call(endpoint, params) {
    return __async(this, null, function* () {
      try {
        const response = yield this.client.request(endpoint, params);
        if ((0, import_superstruct13.is)(response, ErrorResponse)) {
          throw new Error(`RPC Error: ${response.error.message}`);
        }
        return response.result;
      } catch (err) {
        throw new Error(`Error calling RPC endpoint ${endpoint}: ${err}`);
      }
    });
  }
  getMoveFunctionArgTypes(packageId, moduleName, functionName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getMoveFunctionArgTypes",
          [packageId, moduleName, functionName],
          SuiMoveFunctionArgTypes,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching Move function arg types with package object ID: ${packageId}, module name: ${moduleName}, function name: ${functionName}`
        );
      }
    });
  }
  getNormalizedMoveModulesByPackage(packageId) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveModulesByPackage",
          [packageId],
          SuiMoveNormalizedModules,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching package: ${err} for package ${packageId}`
        );
      }
    });
  }
  getNormalizedMoveModule(packageId, moduleName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveModule",
          [packageId, moduleName],
          SuiMoveNormalizedModule,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching module: ${err} for package ${packageId}, module ${moduleName}`
        );
      }
    });
  }
  getNormalizedMoveFunction(packageId, moduleName, functionName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveFunction",
          [packageId, moduleName, functionName],
          SuiMoveNormalizedFunction,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching function: ${err} for package ${packageId}, module ${moduleName} and function ${functionName}`
        );
      }
    });
  }
  getNormalizedMoveStruct(packageId, moduleName, structName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveStruct",
          [packageId, moduleName, structName],
          SuiMoveNormalizedStruct,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching struct: ${err} for package ${packageId}, module ${moduleName} and struct ${structName}`
        );
      }
    });
  }
  getObjectsOwnedByAddress(address) {
    return __async(this, null, function* () {
      try {
        if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getObjectsOwnedByAddress",
          [address],
          GetOwnedObjectsResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching owned object: ${err} for address ${address}`
        );
      }
    });
  }
  getGasObjectsOwnedByAddress(address) {
    return __async(this, null, function* () {
      const objects = yield this.getObjectsOwnedByAddress(address);
      return objects.filter((obj) => Coin.isSUI(obj));
    });
  }
  getCoinBalancesOwnedByAddress(address, typeArg) {
    return __async(this, null, function* () {
      const objects = yield this.getObjectsOwnedByAddress(address);
      const coinIds = objects.filter(
        (obj) => Coin.isCoin(obj) && (typeArg === void 0 || typeArg === Coin.getCoinTypeArg(obj))
      ).map((c) => c.objectId);
      return yield this.getObjectBatch(coinIds);
    });
  }
  selectCoinsWithBalanceGreaterThanOrEqual(_0, _1) {
    return __async(this, arguments, function* (address, amount, typeArg = SUI_TYPE_ARG, exclude = []) {
      const coinsStruct = yield this.getCoins(address, typeArg);
      const coinIds = coinsStruct.data.map((c) => c.coinObjectId);
      const coins = yield this.getObjectBatch(coinIds);
      return yield Coin.selectCoinsWithBalanceGreaterThanOrEqual(
        coins,
        amount,
        exclude
      );
    });
  }
  selectCoinSetWithCombinedBalanceGreaterThanOrEqual(_0, _1) {
    return __async(this, arguments, function* (address, amount, typeArg = SUI_TYPE_ARG, exclude = []) {
      const coinsStruct = yield this.getCoins(address, typeArg);
      const coinIds = coinsStruct.data.map((c) => c.coinObjectId);
      const coins = yield this.getObjectBatch(coinIds);
      return yield Coin.selectCoinSetWithCombinedBalanceGreaterThanOrEqual(
        coins,
        amount,
        exclude
      );
    });
  }
  getObject(objectId) {
    return __async(this, null, function* () {
      try {
        if (!objectId || !isValidSuiObjectId(normalizeSuiObjectId(objectId))) {
          throw new Error("Invalid Sui Object id");
        }
        return yield this.client.requestWithType(
          "sui_getObject",
          [objectId],
          GetObjectDataResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error fetching object info: ${err} for id ${objectId}`);
      }
    });
  }
  getObjectRef(objectId) {
    return __async(this, null, function* () {
      const resp = yield this.getObject(objectId);
      return getObjectReference(resp);
    });
  }
  getObjectBatch(objectIds) {
    return __async(this, null, function* () {
      try {
        const requests = objectIds.map((id) => {
          if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
            throw new Error(`Invalid Sui Object id ${id}`);
          }
          return {
            method: "sui_getObject",
            args: [id]
          };
        });
        return yield this.client.batchRequestWithType(
          requests,
          GetObjectDataResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching object info: ${err} for ids [${objectIds}]`
        );
      }
    });
  }
  getTransactions(query, cursor = null, limit = null, order = "descending") {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getTransactions",
          [query, cursor, limit, order === "descending"],
          PaginatedTransactionDigests,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting transactions for query: ${err} for query ${query}`
        );
      }
    });
  }
  getTransactionsForObject(objectID, descendingOrder = true) {
    return __async(this, null, function* () {
      const requests = [
        {
          method: "sui_getTransactions",
          args: [{ InputObject: objectID }, null, null, descendingOrder]
        },
        {
          method: "sui_getTransactions",
          args: [{ MutatedObject: objectID }, null, null, descendingOrder]
        }
      ];
      try {
        if (!objectID || !isValidSuiObjectId(normalizeSuiObjectId(objectID))) {
          throw new Error("Invalid Sui Object id");
        }
        const results = yield this.client.batchRequestWithType(
          requests,
          PaginatedTransactionDigests,
          this.options.skipDataValidation
        );
        return [...results[0].data, ...results[1].data];
      } catch (err) {
        throw new Error(
          `Error getting transactions for object: ${err} for id ${objectID}`
        );
      }
    });
  }
  getTransactionsForAddress(addressID, descendingOrder = true) {
    return __async(this, null, function* () {
      const requests = [
        {
          method: "sui_getTransactions",
          args: [{ ToAddress: addressID }, null, null, descendingOrder]
        },
        {
          method: "sui_getTransactions",
          args: [{ FromAddress: addressID }, null, null, descendingOrder]
        }
      ];
      try {
        if (!addressID || !isValidSuiAddress(normalizeSuiAddress(addressID))) {
          throw new Error("Invalid Sui address");
        }
        const results = yield this.client.batchRequestWithType(
          requests,
          PaginatedTransactionDigests,
          this.options.skipDataValidation
        );
        return [...results[0].data, ...results[1].data];
      } catch (err) {
        throw new Error(
          `Error getting transactions for address: ${err} for id ${addressID}`
        );
      }
    });
  }
  getTransactionWithEffects(digest) {
    return __async(this, null, function* () {
      try {
        if (!isValidTransactionDigest(digest)) {
          throw new Error("Invalid Transaction digest");
        }
        const resp = yield this.client.requestWithType(
          "sui_getTransaction",
          [digest],
          SuiTransactionResponse,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting transaction with effects: ${err} for digest ${digest}`
        );
      }
    });
  }
  getTransactionWithEffectsBatch(digests) {
    return __async(this, null, function* () {
      try {
        const requests = digests.map((d) => {
          if (!isValidTransactionDigest(d)) {
            throw new Error(`Invalid Transaction digest ${d}`);
          }
          return {
            method: "sui_getTransaction",
            args: [d]
          };
        });
        return yield this.client.batchRequestWithType(
          requests,
          SuiTransactionResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting transaction effects: ${err} for digests [${digests}]`
        );
      }
    });
  }
  executeTransaction(txnBytes, signature, requestType = "WaitForEffectsCert") {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_executeTransactionSerializedSig",
          [
            typeof txnBytes === "string" ? txnBytes : (0, import_bcs12.toB64)(txnBytes),
            signature,
            requestType
          ],
          SuiExecuteTransactionResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error executing transaction with request type: ${err}`);
      }
    });
  }
  getTotalTransactionNumber() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getTotalTransactionNumber",
          [],
          (0, import_superstruct13.number)(),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error fetching total transaction number: ${err}`);
      }
    });
  }
  getTransactionDigestsInRange(start, end) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getTransactionsInRange",
          [start, end],
          GetTxnDigestsResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching transaction digests in range: ${err} for range ${start}-${end}`
        );
      }
    });
  }
  getReferenceGasPrice() {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getReferenceGasPrice",
          [],
          (0, import_superstruct13.number)(),
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting the reference gas price ${err}`);
      }
    });
  }
  getDelegatedStakes(address) {
    return __async(this, null, function* () {
      try {
        if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
          throw new Error("Invalid Sui address");
        }
        const resp = yield this.client.requestWithType(
          "sui_getDelegatedStakes",
          [address],
          (0, import_superstruct13.array)(DelegatedStake),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error in getDelegatedStake: ${err}`);
      }
    });
  }
  getValidators() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getValidators",
          [],
          (0, import_superstruct13.array)(ValidatorMetaData),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error in getValidators: ${err}`);
      }
    });
  }
  getSuiSystemState() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getSuiSystemState",
          [],
          SuiSystemState,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error in getSuiSystemState: ${err}`);
      }
    });
  }
  getEvents(query, cursor, limit, order = "descending") {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getEvents",
          [query, cursor, limit, order === "descending"],
          PaginatedEvents,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting events for query: ${err} for query ${query}`
        );
      }
    });
  }
  subscribeEvent(filter, onMessage) {
    return __async(this, null, function* () {
      return this.wsClient.subscribeEvent(filter, onMessage);
    });
  }
  unsubscribeEvent(id) {
    return __async(this, null, function* () {
      return this.wsClient.unsubscribeEvent(id);
    });
  }
  devInspectTransaction(sender, tx, gasPrice = null, epoch = null) {
    return __async(this, null, function* () {
      try {
        let devInspectTxBytes;
        if (typeof tx === "string") {
          devInspectTxBytes = tx;
        } else if (tx instanceof Uint8Array) {
          devInspectTxBytes = (0, import_bcs12.toB64)(tx);
        } else {
          devInspectTxBytes = (0, import_bcs12.toB64)(
            yield new LocalTxnDataSerializer(this).serializeToBytesWithoutGasInfo(
              sender,
              tx
            )
          );
        }
        const resp = yield this.client.requestWithType(
          "sui_devInspectTransaction",
          [sender, devInspectTxBytes, gasPrice, epoch],
          DevInspectResults,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error dev inspect transaction with request type: ${err}`
        );
      }
    });
  }
  dryRunTransaction(txBytes) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_dryRunTransaction",
          [(0, import_bcs12.toB64)(txBytes)],
          TransactionEffects,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error dry running transaction with request type: ${err}`
        );
      }
    });
  }
  getDynamicFields(parent_object_id, cursor = null, limit = null) {
    return __async(this, null, function* () {
      try {
        if (!parent_object_id || !isValidSuiObjectId(normalizeSuiObjectId(parent_object_id))) {
          throw new Error("Invalid Sui Object id");
        }
        const resp = yield this.client.requestWithType(
          "sui_getDynamicFields",
          [parent_object_id, cursor, limit],
          DynamicFieldPage,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting dynamic fields with request type: ${err} for parent_object_id: ${parent_object_id}, cursor: ${cursor} and limit: ${limit}.`
        );
      }
    });
  }
  getDynamicFieldObject(parent_object_id, name) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getDynamicFieldObject",
          [parent_object_id, name],
          GetObjectDataResponse,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting dynamic field object with request type: ${err} for parent_object_id: ${parent_object_id} and name: ${name}.`
        );
      }
    });
  }
  getLatestCheckpointSequenceNumber() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getLatestCheckpointSequenceNumber",
          [],
          (0, import_superstruct13.number)(),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error fetching latest checkpoint sequence number: ${err}`
        );
      }
    });
  }
  getCheckpointSummary(sequence_number) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointSummary",
          [sequence_number],
          CheckpointSummary,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint summary with request type: ${err} for sequence number: ${sequence_number}.`
        );
      }
    });
  }
  getCheckpointSummaryByDigest(digest) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointSummaryByDigest",
          [digest],
          CheckpointSummary,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint summary with request type: ${err} for digest: ${digest}.`
        );
      }
    });
  }
  getCheckpointContents(sequence_number) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointContents",
          [sequence_number],
          CheckpointContents,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint contents with request type: ${err} for sequence number: ${sequence_number}.`
        );
      }
    });
  }
  getCheckpointContentsByDigest(digest) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointContentsByDigest",
          [digest],
          CheckpointContents,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint summary with request type: ${err} for digest: ${digest}.`
        );
      }
    });
  }
  getCommitteeInfo(epoch) {
    return __async(this, null, function* () {
      try {
        const committeeInfo = yield this.client.requestWithType(
          "sui_getCommitteeInfo",
          [epoch],
          CommitteeInfo
        );
        return committeeInfo;
      } catch (error) {
        throw new Error(`Error getCommitteeInfo : ${error}`);
      }
    });
  }
};

// src/providers/json-rpc-provider-with-cache.ts
var import_superstruct14 = require("superstruct");
var JsonRpcProviderWithCache = class extends JsonRpcProvider {
  constructor() {
    super(...arguments);
    this.objectRefs = /* @__PURE__ */ new Map();
  }
  getObjectsOwnedByAddress(address) {
    return __async(this, null, function* () {
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObjectsOwnedByAddress").call(this, address);
      resp.forEach((r) => this.updateObjectRefCache(r));
      return resp;
    });
  }
  getObject(objectId) {
    return __async(this, null, function* () {
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObject").call(this, objectId);
      this.updateObjectRefCache(resp);
      return resp;
    });
  }
  getObjectRef(objectId, skipCache = false) {
    return __async(this, null, function* () {
      const normalizedId = normalizeSuiObjectId(objectId);
      if (!skipCache && this.objectRefs.has(normalizedId)) {
        return this.objectRefs.get(normalizedId);
      }
      const ref = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObjectRef").call(this, objectId);
      this.updateObjectRefCache(ref);
      return ref;
    });
  }
  getObjectBatch(objectIds) {
    return __async(this, null, function* () {
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObjectBatch").call(this, objectIds);
      resp.forEach((r) => this.updateObjectRefCache(r));
      return resp;
    });
  }
  executeTransaction(txnBytes, signature, requestType = "WaitForEffectsCert") {
    return __async(this, null, function* () {
      if (requestType !== "WaitForEffectsCert") {
        console.warn(
          `It's not recommended to use JsonRpcProviderWithCache with the request type other than 'WaitForEffectsCert' for executeTransaction. Using the '${requestType}' may result in stale cache and a failure in subsequent transactions.`
        );
      }
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "executeTransaction").call(
        this,
        txnBytes,
        signature,
        requestType
      );
      const effects = getTransactionEffects(resp);
      if (effects != null) {
        this.updateObjectRefCacheFromTransactionEffects(effects);
      }
      return resp;
    });
  }
  updateObjectRefCache(newData) {
    if (newData == null) {
      return;
    }
    const ref = (0, import_superstruct14.is)(newData, SuiObjectRef) ? newData : getObjectReference(newData);
    if (ref != null) {
      this.objectRefs.set(ref.objectId, ref);
    }
  }
  updateObjectRefCacheFromTransactionEffects(effects) {
    var _a, _b, _c, _d, _e;
    (_a = effects.created) == null ? void 0 : _a.forEach((r) => this.updateObjectRefCache(r.reference));
    (_b = effects.mutated) == null ? void 0 : _b.forEach((r) => this.updateObjectRefCache(r.reference));
    (_c = effects.unwrapped) == null ? void 0 : _c.forEach((r) => this.updateObjectRefCache(r.reference));
    (_d = effects.wrapped) == null ? void 0 : _d.forEach((r) => this.updateObjectRefCache(r));
    (_e = effects.deleted) == null ? void 0 : _e.forEach((r) => this.objectRefs.delete(r.objectId));
  }
};

// src/signers/txn-data-serializers/rpc-txn-data-serializer.ts
var import_bcs13 = require("@mysten/bcs");
var RpcTxnDataSerializer = class {
  constructor(endpoint, skipDataValidation = false) {
    this.skipDataValidation = skipDataValidation;
    this.client = new JsonRpcClient(endpoint);
  }
  serializeToBytes(signerAddress, unserializedTxn, mode = "Commit") {
    return __async(this, null, function* () {
      let endpoint;
      let args;
      if (!unserializedTxn.data.gasBudget) {
        throw new Error("serializeToBytes requires a valid gas budget");
      }
      switch (unserializedTxn.kind) {
        case "transferObject":
          const t = unserializedTxn.data;
          endpoint = "sui_transferObject";
          args = [
            signerAddress,
            t.objectId,
            t.gasPayment,
            t.gasBudget,
            t.recipient
          ];
          break;
        case "transferSui":
          const transferSui = unserializedTxn.data;
          endpoint = "sui_transferSui";
          args = [
            signerAddress,
            transferSui.suiObjectId,
            transferSui.gasBudget,
            transferSui.recipient,
            transferSui.amount
          ];
          break;
        case "pay":
          const pay = unserializedTxn.data;
          endpoint = "sui_pay";
          args = [
            signerAddress,
            pay.inputCoins,
            pay.recipients,
            pay.amounts,
            pay.gasPayment,
            pay.gasBudget
          ];
          break;
        case "paySui":
          const paySui = unserializedTxn.data;
          endpoint = "sui_paySui";
          args = [
            signerAddress,
            paySui.inputCoins,
            paySui.recipients,
            paySui.amounts,
            paySui.gasBudget
          ];
          break;
        case "payAllSui":
          const payAllSui = unserializedTxn.data;
          endpoint = "sui_payAllSui";
          args = [
            signerAddress,
            payAllSui.inputCoins,
            payAllSui.recipient,
            payAllSui.gasBudget
          ];
          break;
        case "moveCall":
          const moveCall = unserializedTxn.data;
          for (const arg of moveCall.arguments) {
            if (isPureArg(arg)) {
              throw new Error(
                "PureArg is not allowed as argument in RpcTxnDataSerializer. Please use LocalTxnDataSerializer instead."
              );
            }
          }
          endpoint = "sui_moveCall";
          args = [
            signerAddress,
            moveCall.packageObjectId,
            moveCall.module,
            moveCall.function,
            moveCall.typeArguments,
            moveCall.arguments,
            moveCall.gasPayment,
            moveCall.gasBudget,
            mode
          ];
          break;
        case "mergeCoin":
          const mergeCoin = unserializedTxn.data;
          endpoint = "sui_mergeCoins";
          args = [
            signerAddress,
            mergeCoin.primaryCoin,
            mergeCoin.coinToMerge,
            mergeCoin.gasPayment,
            mergeCoin.gasBudget
          ];
          break;
        case "splitCoin":
          const splitCoin = unserializedTxn.data;
          endpoint = "sui_splitCoin";
          args = [
            signerAddress,
            splitCoin.coinObjectId,
            splitCoin.splitAmounts,
            splitCoin.gasPayment,
            splitCoin.gasBudget
          ];
          break;
        case "publish":
          const publish = unserializedTxn.data;
          endpoint = "sui_publish";
          args = [
            signerAddress,
            publish.compiledModules,
            publish.gasPayment,
            publish.gasBudget
          ];
          break;
      }
      try {
        const resp = yield this.client.requestWithType(
          endpoint,
          args,
          TransactionBytes,
          this.skipDataValidation
        );
        return (0, import_bcs13.fromB64)(resp.txBytes);
      } catch (e) {
        throw new Error(
          `Encountered error when calling RpcTxnDataSerialize for a ${unserializedTxn.kind} transaction for address ${signerAddress} for transaction ${JSON.stringify(
            unserializedTxn,
            null,
            2
          )}: ${e}`
        );
      }
    });
  }
};

// src/signers/signer-with-provider.ts
var import_bcs14 = require("@mysten/bcs");

// src/providers/void-provider.ts
var VoidProvider = class extends Provider {
  getRpcApiVersion() {
    return __async(this, null, function* () {
      throw this.newError("getRpcApiVersion");
    });
  }
  getReferenceGasPrice() {
    return __async(this, null, function* () {
      throw this.newError("getReferenceGasPrice");
    });
  }
  getSuiSystemState() {
    return __async(this, null, function* () {
      throw this.newError("getSuiSystemState");
    });
  }
  getDelegatedStakes(_address) {
    return __async(this, null, function* () {
      throw this.newError("getDelegatedStakes");
    });
  }
  getValidators() {
    return __async(this, null, function* () {
      throw this.newError("getValidators");
    });
  }
  requestSuiFromFaucet(_recipient, _httpHeaders) {
    return __async(this, null, function* () {
      throw this.newError("requestSuiFromFaucet");
    });
  }
  call(_endpoint, _params) {
    throw this.newError("call");
  }
  getCoins(_owner, _coinType, _cursor, _limit) {
    return __async(this, null, function* () {
      throw this.newError("getCoins");
    });
  }
  getAllCoins(_owner, _cursor, _limit) {
    return __async(this, null, function* () {
      throw this.newError("getAllCoins");
    });
  }
  getBalance(_owner, _coinType) {
    return __async(this, null, function* () {
      throw this.newError("getBalance");
    });
  }
  getAllBalances(_owner) {
    return __async(this, null, function* () {
      throw this.newError("getAllBalances");
    });
  }
  getCoinMetadata(_coinType) {
    return __async(this, null, function* () {
      throw new Error("getCoinMetadata");
    });
  }
  getTotalSupply(_coinType) {
    return __async(this, null, function* () {
      throw new Error("getTotalSupply");
    });
  }
  getObjectsOwnedByAddress(_address) {
    return __async(this, null, function* () {
      throw this.newError("getObjectsOwnedByAddress");
    });
  }
  getGasObjectsOwnedByAddress(_address) {
    return __async(this, null, function* () {
      throw this.newError("getGasObjectsOwnedByAddress");
    });
  }
  getCoinBalancesOwnedByAddress(_address, _typeArg) {
    return __async(this, null, function* () {
      throw this.newError("getCoinBalancesOwnedByAddress");
    });
  }
  selectCoinsWithBalanceGreaterThanOrEqual(_0, _1, _2) {
    return __async(this, arguments, function* (_address, _amount, _typeArg, _exclude = []) {
      throw this.newError("selectCoinsWithBalanceGreaterThanOrEqual");
    });
  }
  selectCoinSetWithCombinedBalanceGreaterThanOrEqual(_address, _amount, _typeArg, _exclude) {
    return __async(this, null, function* () {
      throw this.newError("selectCoinSetWithCombinedBalanceGreaterThanOrEqual");
    });
  }
  getObject(_objectId) {
    return __async(this, null, function* () {
      throw this.newError("getObject");
    });
  }
  getObjectRef(_objectId) {
    return __async(this, null, function* () {
      throw this.newError("getObjectRef");
    });
  }
  getTransaction(_digest) {
    return __async(this, null, function* () {
      throw this.newError("getTransaction");
    });
  }
  executeTransaction(_txnBytes, _signature, _requestType) {
    return __async(this, null, function* () {
      throw this.newError("executeTransaction with request Type");
    });
  }
  devInspectTransaction(_sender, _txn, _gasPrice = null, _epoch = null) {
    throw this.newError("devInspectTransaction");
  }
  dryRunTransaction(_txBytes) {
    throw this.newError("dryRunTransaction");
  }
  getDynamicFields(_parent_object_id, _cursor = null, _limit = null) {
    throw this.newError("getDynamicFields");
  }
  getDynamicFieldObject(_parent_object_id, _name) {
    throw this.newError("getDynamicFieldObject");
  }
  getTotalTransactionNumber() {
    return __async(this, null, function* () {
      throw this.newError("getTotalTransactionNumber");
    });
  }
  getTransactionDigestsInRange(_start, _end) {
    return __async(this, null, function* () {
      throw this.newError("getTransactionDigestsInRange");
    });
  }
  getMoveFunctionArgTypes(_objectId, _moduleName, _functionName) {
    return __async(this, null, function* () {
      throw this.newError("getMoveFunctionArgTypes");
    });
  }
  getNormalizedMoveModulesByPackage(_objectId) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveModulesByPackage");
    });
  }
  getNormalizedMoveModule(_objectId, _moduleName) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveModule");
    });
  }
  getNormalizedMoveFunction(_objectId, _moduleName, _functionName) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveFunction");
    });
  }
  getNormalizedMoveStruct(_objectId, _oduleName, _structName) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveStruct");
    });
  }
  syncAccountState(_address) {
    return __async(this, null, function* () {
      throw this.newError("syncAccountState");
    });
  }
  subscribeEvent(_filter, _onMessage) {
    return __async(this, null, function* () {
      throw this.newError("subscribeEvent");
    });
  }
  unsubscribeEvent(_id) {
    return __async(this, null, function* () {
      throw this.newError("unsubscribeEvent");
    });
  }
  newError(operation) {
    return new Error(`Please use a valid provider for ${operation}`);
  }
  getTransactions(_query, _cursor, _limit, _order) {
    return __async(this, null, function* () {
      throw this.newError("getTransactions");
    });
  }
  getEvents(_query, _cursor, _limit, _order) {
    return __async(this, null, function* () {
      throw this.newError("getEvents");
    });
  }
  getLatestCheckpointSequenceNumber() {
    return __async(this, null, function* () {
      throw this.newError("getLatestCheckpointSequenceNumber");
    });
  }
  getCheckpointSummary(_sequenceNumber) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointSummary");
    });
  }
  getCheckpointSummaryByDigest(_digest) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointSummaryByDigest");
    });
  }
  getCheckpointContents(_sequenceNumber) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointContents");
    });
  }
  getCheckpointContentsByDigest(_digest) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointContentsByDigest");
    });
  }
  getCommitteeInfo(_epoch) {
    return __async(this, null, function* () {
      throw this.newError("getCommitteeInfo");
    });
  }
};

// src/utils/intent.ts
var AppId = /* @__PURE__ */ ((AppId2) => {
  AppId2[AppId2["Sui"] = 0] = "Sui";
  return AppId2;
})(AppId || {});
var IntentVersion = /* @__PURE__ */ ((IntentVersion2) => {
  IntentVersion2[IntentVersion2["V0"] = 0] = "V0";
  return IntentVersion2;
})(IntentVersion || {});
var IntentScope = /* @__PURE__ */ ((IntentScope2) => {
  IntentScope2[IntentScope2["TransactionData"] = 0] = "TransactionData";
  IntentScope2[IntentScope2["TransactionEffects"] = 1] = "TransactionEffects";
  IntentScope2[IntentScope2["CheckpointSummary"] = 2] = "CheckpointSummary";
  IntentScope2[IntentScope2["PersonalMessage"] = 3] = "PersonalMessage";
  return IntentScope2;
})(IntentScope || {});
function intentWithScope(scope) {
  return [scope, 0 /* V0 */, 0 /* Sui */];
}
function messageWithIntent(scope, message) {
  const intent = intentWithScope(scope);
  const intentMessage = new Uint8Array(intent.length + message.length);
  intentMessage.set(intent);
  intentMessage.set(message, intent.length);
  return intentMessage;
}

// src/signers/signer-with-provider.ts
var SignerWithProvider = class {
  requestSuiFromFaucet(httpHeaders) {
    return __async(this, null, function* () {
      return this.provider.requestSuiFromFaucet(
        yield this.getAddress(),
        httpHeaders
      );
    });
  }
  constructor(provider, serializer) {
    this.provider = provider || new VoidProvider();
    let endpoint = "";
    let skipDataValidation = false;
    if (this.provider instanceof JsonRpcProvider) {
      endpoint = this.provider.connection.fullnode;
      skipDataValidation = this.provider.options.skipDataValidation;
    }
    this.serializer = serializer || new RpcTxnDataSerializer(endpoint, skipDataValidation);
  }
  signMessage(message) {
    return __async(this, null, function* () {
      return yield this.signData(
        messageWithIntent(3 /* PersonalMessage */, message)
      );
    });
  }
  signTransaction(transaction) {
    return __async(this, null, function* () {
      let transactionBytes;
      if (transaction instanceof Uint8Array || transaction.kind === "bytes") {
        transactionBytes = transaction instanceof Uint8Array ? transaction : transaction.data;
      } else {
        transactionBytes = yield this.serializer.serializeToBytes(
          yield this.getAddress(),
          transaction,
          "Commit"
        );
      }
      const intentMessage = messageWithIntent(
        0 /* TransactionData */,
        transactionBytes
      );
      const signature = yield this.signData(intentMessage);
      return {
        transactionBytes: (0, import_bcs14.toB64)(transactionBytes),
        signature
      };
    });
  }
  signAndExecuteTransaction(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      const { transactionBytes, signature } = yield this.signTransaction(
        transaction
      );
      return yield this.provider.executeTransaction(
        transactionBytes,
        signature,
        requestType
      );
    });
  }
  getTransactionDigest(tx) {
    return __async(this, null, function* () {
      let txBytes;
      if (tx instanceof Uint8Array || tx.kind === "bytes") {
        txBytes = tx instanceof Uint8Array ? tx : tx.data;
      } else {
        txBytes = yield this.serializer.serializeToBytes(
          yield this.getAddress(),
          tx,
          "DevInspect"
        );
      }
      const version = yield this.provider.getRpcApiVersion();
      const bcs2 = bcsForVersion(version);
      const data = deserializeTransactionBytesToTransactionData(bcs2, txBytes);
      return generateTransactionDigest(data, bcs2);
    });
  }
  devInspectTransaction(tx, gasPrice = null, epoch = null) {
    return __async(this, null, function* () {
      const address = yield this.getAddress();
      return this.provider.devInspectTransaction(address, tx, gasPrice, epoch);
    });
  }
  dryRunTransaction(tx) {
    return __async(this, null, function* () {
      const address = yield this.getAddress();
      let dryRunTxBytes;
      if (typeof tx === "string") {
        dryRunTxBytes = (0, import_bcs14.fromB64)(tx);
      } else if (tx instanceof Uint8Array) {
        dryRunTxBytes = tx;
      } else {
        switch (tx.kind) {
          case "bytes":
            dryRunTxBytes = tx.data;
            break;
          default:
            dryRunTxBytes = yield this.serializer.serializeToBytes(
              address,
              tx,
              "Commit"
            );
            break;
        }
      }
      return this.provider.dryRunTransaction(dryRunTxBytes);
    });
  }
  transferObject(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "transferObject", data: transaction },
        requestType
      );
    });
  }
  transferSui(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "transferSui", data: transaction },
        requestType
      );
    });
  }
  pay(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "pay", data: transaction },
        requestType
      );
    });
  }
  paySui(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "paySui", data: transaction },
        requestType
      );
    });
  }
  payAllSui(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "payAllSui", data: transaction },
        requestType
      );
    });
  }
  mergeCoin(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "mergeCoin", data: transaction },
        requestType
      );
    });
  }
  splitCoin(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "splitCoin", data: transaction },
        requestType
      );
    });
  }
  executeMoveCall(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "moveCall", data: transaction },
        requestType
      );
    });
  }
  publish(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "publish", data: transaction },
        requestType
      );
    });
  }
  getGasCostEstimation(...args) {
    return __async(this, null, function* () {
      const txEffects = yield this.dryRunTransaction(...args);
      const gasEstimation = getTotalGasUsedUpperBound(txEffects);
      if (typeof gasEstimation === "undefined") {
        throw new Error("Failed to estimate the gas cost from transaction");
      }
      return gasEstimation;
    });
  }
};

// src/signers/raw-signer.ts
var RawSigner = class extends SignerWithProvider {
  constructor(keypair, provider, serializer) {
    super(provider, serializer);
    this.keypair = keypair;
  }
  getAddress() {
    return __async(this, null, function* () {
      return this.keypair.getPublicKey().toSuiAddress();
    });
  }
  signData(data) {
    return __async(this, null, function* () {
      const pubkey = this.keypair.getPublicKey();
      const signature = this.keypair.signData(data, false);
      const signatureScheme = this.keypair.getKeyScheme();
      return toSerializedSignature({
        signatureScheme,
        signature,
        pubKey: pubkey
      });
    });
  }
  connect(provider) {
    return new RawSigner(this.keypair, provider);
  }
};

// src/utils/format.ts
var ELLIPSIS = "\u2026";
function formatAddress(address) {
  const offset = address.startsWith("0x") ? 2 : 0;
  return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(
    -4
  )}`;
}
function formatDigest(digest) {
  return `${digest.slice(0, 10)}${ELLIPSIS}`;
}

// src/utils/verify.ts
var import_bcs15 = require("@mysten/bcs");
var import_tweetnacl3 = __toESM(require("tweetnacl"));
var secp2 = __toESM(require("@noble/secp256k1"));
function verifyMessage(message, serializedSignature) {
  return __async(this, null, function* () {
    const signature = fromSerializedSignature(serializedSignature);
    const messageBytes = messageWithIntent(
      3 /* PersonalMessage */,
      typeof message === "string" ? (0, import_bcs15.fromB64)(message) : message
    );
    switch (signature.signatureScheme) {
      case "ED25519":
        return import_tweetnacl3.default.sign.detached.verify(
          messageBytes,
          signature.signature,
          signature.pubKey.toBytes()
        );
      case "Secp256k1":
        return secp2.verify(
          secp2.Signature.fromCompact(signature.signature),
          yield secp2.utils.sha256(messageBytes),
          signature.pubKey.toBytes()
        );
      default:
        throw new Error(
          `Unknown signature scheme: "${signature.signatureScheme}"`
        );
    }
  });
}

// src/framework/sui-system-state.ts
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiAddress("0x5");
var SUI_SYSTEM_MODULE_NAME = "sui_system";
var ADD_DELEGATION_MUL_COIN_FUN_NAME = "request_add_delegation_mul_coin";
var ADD_DELEGATION_LOCKED_COIN_FUN_NAME = "request_add_delegation_mul_locked_coin";
var WITHDRAW_DELEGATION_FUN_NAME = "request_withdraw_delegation";
var SuiSystemStateUtil = class {
  static newRequestAddDelegationTxn(coins, amount, validatorAddress, gasBudget, gasPayment, gasPrice) {
    return __async(this, null, function* () {
      return {
        kind: "moveCall",
        data: {
          packageObjectId: SUI_FRAMEWORK_ADDRESS,
          module: SUI_SYSTEM_MODULE_NAME,
          function: ADD_DELEGATION_MUL_COIN_FUN_NAME,
          typeArguments: [],
          arguments: [
            SUI_SYSTEM_STATE_OBJECT_ID,
            coins,
            [String(amount)],
            validatorAddress
          ],
          gasBudget,
          gasPayment,
          gasPrice
        }
      };
    });
  }
  static newRequestWithdrawlDelegationTxn(delegation, stakedCoinId, gasBudget, gasPayment, gasPrice) {
    return __async(this, null, function* () {
      return {
        kind: "moveCall",
        data: {
          packageObjectId: SUI_FRAMEWORK_ADDRESS,
          module: SUI_SYSTEM_MODULE_NAME,
          function: WITHDRAW_DELEGATION_FUN_NAME,
          typeArguments: [],
          arguments: [SUI_SYSTEM_STATE_OBJECT_ID, delegation, stakedCoinId],
          gasBudget,
          gasPayment,
          gasPrice
        }
      };
    });
  }
};

// src/index.ts
var import_bcs16 = require("@mysten/bcs");
var import_superstruct15 = require("superstruct");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ADD_DELEGATION_LOCKED_COIN_FUN_NAME,
  ADD_DELEGATION_MUL_COIN_FUN_NAME,
  ActiveDelegationStatus,
  ActiveFields,
  AppId,
  AuthorityName,
  AuthorityQuorumSignInfo,
  AuthoritySignature,
  Balance,
  BalanceChangeType,
  COIN_TYPE_ARG_REGEX,
  CertifiedTransaction,
  CheckPointContentsDigest,
  CheckpointContents,
  CheckpointDigest,
  CheckpointEvent,
  CheckpointSummary,
  Coin,
  CoinBalance,
  CoinBalanceChangeEvent,
  CoinMetadataStruct,
  CoinStruct,
  CoinSupply,
  CommitteeInfo,
  Connection,
  Contents,
  ContentsFields,
  ContentsFieldsWithdraw,
  DEFAULT_CLIENT_OPTIONS,
  DEFAULT_ED25519_DERIVATION_PATH,
  DEFAULT_SECP256K1_DERIVATION_PATH,
  DelegatedStake,
  Delegation,
  DelegationStakingPool,
  DelegationStakingPoolFields,
  DeleteObjectEvent,
  DevInspectResults,
  Ed25519Keypair,
  Ed25519PublicKey,
  EpochChangeEvent,
  EpochId,
  ErrorResponse,
  EventId,
  ExecutionStatus,
  ExecutionStatusType,
  FaucetRateLimitError,
  GasCostSummary,
  GenericAuthoritySignature,
  Genesis,
  GetObjectDataResponse,
  GetOwnedObjectsResponse,
  GetTxnDigestsResponse,
  ID_STRUCT_NAME,
  IntentScope,
  IntentVersion,
  JsonRpcClient,
  JsonRpcProvider,
  JsonRpcProviderWithCache,
  LEGACY_PRIVATE_KEY_SIZE,
  LocalTxnDataSerializer,
  MIST_PER_SUI,
  MOVE_STDLIB_ADDRESS,
  MoveActiveValidator,
  MoveActiveValidatorFields,
  MoveCall,
  MoveDelegationStakingPoolFields,
  MoveEvent,
  MoveNextEpochValidatorFields,
  MovePackageContent,
  MoveSuiSystemObject,
  MoveSuiSystemObjectFields,
  MoveValidatorsFieldsClass,
  MutateObjectEvent,
  NewObjectEvent,
  OBJECT_MODULE_NAME,
  ObjectContentFields,
  ObjectId,
  ObjectOwner,
  ObjectStatus,
  ObjectType,
  OwnedObjectRef,
  PAY_JOIN_COIN_FUNC_NAME,
  PAY_MODULE_NAME,
  PAY_SPLIT_COIN_VEC_FUNC_NAME,
  PRIVATE_KEY_SIZE,
  PaginatedCoins,
  PaginatedEvents,
  PaginatedTransactionDigests,
  Parameters,
  ParametersFields,
  Pay,
  PayAllSui,
  PaySui,
  PendingWithdawFields,
  Provider,
  PublishEvent,
  RawSigner,
  RpcTxnDataSerializer,
  SIGNATURE_FLAG_TO_SCHEME,
  SIGNATURE_SCHEME_TO_FLAG,
  SUI_ADDRESS_LENGTH,
  SUI_FRAMEWORK_ADDRESS,
  SUI_SYSTEM_MODULE_NAME,
  SUI_SYSTEM_STATE_OBJECT_ID,
  SUI_TYPE_ARG,
  Secp256k1Keypair,
  Secp256k1PublicKey,
  SequenceNumber,
  SignerWithProvider,
  StakeSubsidy,
  StakeSubsidyFields,
  StakedSui,
  SubscriptionEvent,
  SubscriptionId,
  SuiAddress,
  SuiCertifiedTransactionEffects,
  SuiChangeEpoch,
  SuiConsensusCommitPrologue,
  SuiData,
  SuiEffectsFinalityInfo,
  SuiEvent,
  SuiEventEnvelope,
  SuiExecuteTransactionResponse,
  SuiFinalizedEffects,
  SuiGasData,
  SuiJsonValue,
  SuiMoveAbilitySet,
  SuiMoveFunctionArgType,
  SuiMoveFunctionArgTypes,
  SuiMoveModuleId,
  SuiMoveNormalizedField,
  SuiMoveNormalizedFunction,
  SuiMoveNormalizedModule,
  SuiMoveNormalizedModules,
  SuiMoveNormalizedStruct,
  SuiMoveNormalizedStructType,
  SuiMoveNormalizedType,
  SuiMoveNormalizedTypeParameterType,
  SuiMoveObject,
  SuiMovePackage,
  SuiMoveStructTypeParameter,
  SuiMoveVisibility,
  SuiObject,
  SuiObjectInfo,
  SuiObjectRef,
  SuiPackage,
  SuiParsedMergeCoinResponse,
  SuiParsedPublishResponse,
  SuiParsedSplitCoinResponse,
  SuiParsedTransactionResponse,
  SuiSupplyFields,
  SuiSystemState,
  SuiSystemStateUtil,
  SuiTransaction,
  SuiTransactionData,
  SuiTransactionKind,
  SuiTransactionResponse,
  SuiTransferSui,
  SystemParameters,
  TARGETED_RPC_VERSION,
  TRANSACTION_DATA_TYPE_TAG,
  TransactionBytes,
  TransactionDigest,
  TransactionEffects,
  TransactionEffectsDigest,
  TransferObject,
  TransferObjectEvent,
  TypeTagSerializer,
  UID_STRUCT_NAME,
  ValidResponse,
  Validator,
  ValidatorMetaData,
  ValidatorPair,
  ValidatorSet,
  WITHDRAW_DELEGATION_FUN_NAME,
  WebsocketClient,
  assert,
  bcs,
  bcsForVersion,
  bytesEqual,
  deserializeTransactionBytesToTransactionData,
  devnetConnection,
  extractMutableReference,
  extractReference,
  extractStructTag,
  formatAddress,
  formatDigest,
  fromB64,
  fromExportedKeypair,
  fromSerializedSignature,
  generateTransactionDigest,
  getCertifiedTransaction,
  getChangeEpochTransaction,
  getCoinAfterMerge,
  getCoinAfterSplit,
  getConsensusCommitPrologueTransaction,
  getCreatedObjects,
  getEvents,
  getExecutionStatus,
  getExecutionStatusError,
  getExecutionStatusGasSummary,
  getExecutionStatusType,
  getGasData,
  getMoveCallTransaction,
  getMoveObject,
  getMoveObjectType,
  getMovePackageContent,
  getNewlyCreatedCoinRefsAfterSplit,
  getNewlyCreatedCoinsAfterSplit,
  getObjectDeletedResponse,
  getObjectExistsResponse,
  getObjectFields,
  getObjectId,
  getObjectNotExistsResponse,
  getObjectOwner,
  getObjectPreviousTransactionDigest,
  getObjectReference,
  getObjectType,
  getObjectVersion,
  getParsedMergeCoinResponse,
  getParsedPublishResponse,
  getParsedSplitCoinResponse,
  getPayAllSuiTransaction,
  getPaySuiTransaction,
  getPayTransaction,
  getPublishTransaction,
  getSharedObjectInitialVersion,
  getTimestampFromTransactionResponse,
  getTotalGasUsed,
  getTotalGasUsedUpperBound,
  getTransactionData,
  getTransactionDigest,
  getTransactionEffects,
  getTransactionGasBudget,
  getTransactionGasObject,
  getTransactionGasPrice,
  getTransactionKindName,
  getTransactionSender,
  getTransactionSignature,
  getTransactions,
  getTransferObjectTransaction,
  getTransferSuiAmount,
  getTransferSuiTransaction,
  getWebsocketUrl,
  hasPublicTransfer,
  is,
  isImmutableObject,
  isPureArg,
  isSharedObject,
  isValidBIP32Path,
  isValidHardenedPath,
  isValidSuiAddress,
  isValidSuiObjectId,
  isValidTransactionDigest,
  localnetConnection,
  messageWithIntent,
  mnemonicToSeed,
  mnemonicToSeedHex,
  normalizeSuiAddress,
  normalizeSuiObjectId,
  parseVersionFromString,
  publicKeyFromSerialized,
  requestSuiFromFaucet,
  toB64,
  toSerializedSignature,
  verifyMessage,
  versionToString
});
//# sourceMappingURL=index.js.map