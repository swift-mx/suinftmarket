var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/cryptography/ed25519-keypair.ts
import nacl2 from "tweetnacl";

// src/cryptography/keypair.ts
import { fromB64 as fromB644 } from "@mysten/bcs";

// src/cryptography/secp256k1-keypair.ts
import * as secp from "@noble/secp256k1";
import { hmac } from "@noble/hashes/hmac";
import { sha256 } from "@noble/hashes/sha256";

// src/cryptography/secp256k1-publickey.ts
import { fromB64 as fromB643, toB64 as toB643 } from "@mysten/bcs";
import sha32 from "js-sha3";

// src/cryptography/ed25519-publickey.ts
import sha3 from "js-sha3";
import { fromB64 as fromB642, toB64 as toB642 } from "@mysten/bcs";

// src/cryptography/signature.ts
import { fromB64, toB64 } from "@mysten/bcs";
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1"
};
function toSerializedSignature({
  signature,
  signatureScheme,
  pubKey
}) {
  const serializedSignature = new Uint8Array(
    1 + signature.length + pubKey.toBytes().length
  );
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKey.toBytes(), 1 + signature.length);
  return toB64(serializedSignature);
}
function fromSerializedSignature(serializedSignature) {
  const bytes = fromB64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  const PublicKey2 = signatureScheme === "ED25519" ? Ed25519PublicKey : Secp256k1PublicKey;
  const signature = bytes.slice(1, bytes.length - PublicKey2.SIZE);
  const pubkeyBytes = bytes.slice(1 + signature.length);
  const pubKey = new PublicKey2(pubkeyBytes);
  return {
    signatureScheme,
    signature,
    pubKey
  };
}

// src/cryptography/ed25519-publickey.ts
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class {
  constructor(value) {
    if (typeof value === "string") {
      this.data = fromB642(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  equals(publicKey) {
    return bytesEqual(this.toBytes(), publicKey.toBytes());
  }
  toBase64() {
    return toB642(this.toBytes());
  }
  toBytes() {
    return this.data;
  }
  toString() {
    return this.toBase64();
  }
  toSuiAddress() {
    let tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["ED25519"]]);
    tmp.set(this.toBytes(), 1);
    return sha3.sha3_256(tmp).slice(0, 40);
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;

// src/cryptography/publickey.ts
function bytesEqual(a, b) {
  if (a === b)
    return true;
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function publicKeyFromSerialized(schema, pubKey) {
  if (schema === "ED25519") {
    return new Ed25519PublicKey(pubKey);
  }
  if (schema === "Secp256k1") {
    return new Secp256k1PublicKey(pubKey);
  }
  throw new Error("Unknown public key schema");
}

// src/cryptography/secp256k1-publickey.ts
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class {
  constructor(value) {
    if (typeof value === "string") {
      this.data = fromB643(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  equals(publicKey) {
    return bytesEqual(this.toBytes(), publicKey.toBytes());
  }
  toBase64() {
    return toB643(this.toBytes());
  }
  toBytes() {
    return this.data;
  }
  toString() {
    return this.toBase64();
  }
  toSuiAddress() {
    let tmp = new Uint8Array(SECP256K1_PUBLIC_KEY_SIZE + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["Secp256k1"]]);
    tmp.set(this.toBytes(), 1);
    return sha32.sha3_256(tmp).slice(0, 40);
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;

// src/cryptography/secp256k1-keypair.ts
import { Signature } from "@noble/secp256k1";

// src/cryptography/mnemonics.ts
import { toHEX } from "@mysten/bcs";
import { mnemonicToSeedSync as bip39MnemonicToSeedSync } from "@scure/bip39";
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function isValidBIP32Path(path) {
  if (!new RegExp("^m\\/54'\\/784'\\/[0-9]+'\\/[0-9]+\\/[0-9]+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return bip39MnemonicToSeedSync(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return toHEX(mnemonicToSeed(mnemonics));
}

// src/cryptography/secp256k1-keypair.ts
import { HDKey } from "@scure/bip32";
import { toB64 as toB644 } from "@mysten/bcs";
var DEFAULT_SECP256K1_DERIVATION_PATH = "m/54'/784'/0'/0/0";
secp.utils.hmacSha256Sync = (key, ...msgs) => {
  const h = hmac.create(sha256, key);
  msgs.forEach((msg) => h.update(msg));
  return h.digest();
};
var Secp256k1Keypair = class {
  constructor(keypair) {
    if (keypair) {
      this.keypair = keypair;
    } else {
      const secretKey = secp.utils.randomPrivateKey();
      const publicKey = secp.getPublicKey(secretKey, true);
      this.keypair = { publicKey, secretKey };
    }
  }
  getKeyScheme() {
    return "Secp256k1";
  }
  static generate() {
    const secretKey = secp.utils.randomPrivateKey();
    const publicKey = secp.getPublicKey(secretKey, true);
    return new Secp256k1Keypair({ publicKey, secretKey });
  }
  static fromSecretKey(secretKey, options) {
    const publicKey = secp.getPublicKey(secretKey, true);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const msgHash = sha256(signData);
      const signature = secp.signSync(msgHash, secretKey);
      if (!secp.verify(signature, msgHash, publicKey, { strict: true })) {
        throw new Error("Provided secretKey is invalid");
      }
    }
    return new Secp256k1Keypair({ publicKey, secretKey });
  }
  static fromSeed(seed) {
    let publicKey = secp.getPublicKey(seed, true);
    return new Secp256k1Keypair({ publicKey, secretKey: seed });
  }
  getPublicKey() {
    return new Secp256k1PublicKey(this.keypair.publicKey);
  }
  signData(data, useRecoverable) {
    const msgHash = sha256(data);
    if (useRecoverable) {
      const [sig, rec_id] = secp.signSync(msgHash, this.keypair.secretKey, {
        canonical: true,
        recovered: true
      });
      var recoverable_sig = new Uint8Array(65);
      recoverable_sig.set(Signature.fromDER(sig).toCompactRawBytes());
      recoverable_sig.set([rec_id], 64);
      return recoverable_sig;
    } else {
      const sig = secp.signSync(msgHash, this.keypair.secretKey, {
        canonical: true,
        recovered: false
      });
      return Signature.fromDER(sig).toCompactRawBytes();
    }
  }
  static deriveKeypair(path, mnemonics) {
    if (!isValidBIP32Path(path)) {
      throw new Error("Invalid derivation path");
    }
    const key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);
    if (key.publicKey == null || key.privateKey == null) {
      throw new Error("Invalid key");
    }
    return new Secp256k1Keypair({
      publicKey: key.publicKey,
      secretKey: key.privateKey
    });
  }
  export() {
    return {
      schema: "Secp256k1",
      privateKey: toB644(this.keypair.secretKey)
    };
  }
};

// src/cryptography/keypair.ts
var PRIVATE_KEY_SIZE = 32;
var LEGACY_PRIVATE_KEY_SIZE = 64;
function fromExportedKeypair(keypair) {
  const secretKey = fromB644(keypair.privateKey);
  switch (keypair.schema) {
    case "ED25519":
      let pureSecretKey = secretKey;
      if (secretKey.length === LEGACY_PRIVATE_KEY_SIZE) {
        pureSecretKey = secretKey.slice(0, PRIVATE_KEY_SIZE);
      }
      return Ed25519Keypair.fromSecretKey(pureSecretKey);
    case "Secp256k1":
      return Secp256k1Keypair.fromSecretKey(secretKey);
    default:
      throw new Error(`Invalid keypair schema ${keypair.schema}`);
  }
}

// src/utils/ed25519-hd-key.ts
import { sha512 } from "@noble/hashes/sha512";
import { hmac as hmac2 } from "@noble/hashes/hmac";
import nacl from "tweetnacl";
import { fromHEX } from "@mysten/bcs";
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h = hmac2.create(sha512, ED25519_CURVE);
  const I = h.update(fromHEX(seed)).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key, 1);
  data.set(
    new Uint8Array(indexBuffer, 0, indexBuffer.byteLength),
    key.length + 1
  );
  const I = hmac2.create(sha512, chainCode).update(data).digest();
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(isNaN);
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce(
    (parentKeys, segment) => CKDPriv(parentKeys, segment + offset),
    { key, chainCode }
  );
};

// src/cryptography/ed25519-keypair.ts
import { toB64 as toB645 } from "@mysten/bcs";
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class {
  constructor(keypair) {
    if (keypair) {
      this.keypair = keypair;
    } else {
      this.keypair = nacl2.sign.keyPair();
    }
  }
  getKeyScheme() {
    return "ED25519";
  }
  static generate() {
    return new Ed25519Keypair(nacl2.sign.keyPair());
  }
  static fromSecretKey(secretKey, options) {
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = nacl2.sign.keyPair.fromSeed(secretKey);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = nacl2.sign.detached(signData, keypair.secretKey);
      if (!nacl2.sign.detached.verify(signData, signature, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new Ed25519Keypair(keypair);
  }
  getPublicKey() {
    return new Ed25519PublicKey(this.keypair.publicKey);
  }
  signData(data, _useRecoverable = false) {
    return nacl2.sign.detached(data, this.keypair.secretKey);
  }
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return Ed25519Keypair.fromSecretKey(key);
  }
  export() {
    return {
      schema: "ED25519",
      privateKey: toB645(this.keypair.secretKey)
    };
  }
};

// src/providers/provider.ts
var Provider = class {
};

// src/rpc/client.ts
import RpcClient from "jayson/lib/client/browser/index.js";
import fetch from "cross-fetch";
import {
  any,
  is,
  literal,
  object,
  optional,
  string,
  validate
} from "superstruct";

// src/pkg-version.ts
var pkgVersion = "0.29.1";

// src/rpc/client.ts
var TYPE_MISMATCH_ERROR = `The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server. Please update your SDK version to the latest. `;
var ValidResponse = object({
  jsonrpc: literal("2.0"),
  id: string(),
  result: any()
});
var ErrorResponse = object({
  jsonrpc: literal("2.0"),
  id: string(),
  error: object({
    code: any(),
    message: string(),
    data: optional(any())
  })
});
var JsonRpcClient = class {
  constructor(url, httpHeaders) {
    this.rpcClient = new RpcClient(
      (request, callback) => __async(this, null, function* () {
        const options = {
          method: "POST",
          body: request,
          headers: __spreadValues({
            "Content-Type": "application/json",
            "Client-Sdk-Type": "typescript",
            "Client-Sdk-Version": pkgVersion,
            "Client-Target-Api-Version": TARGETED_RPC_VERSION
          }, httpHeaders)
        };
        try {
          let res = yield fetch(url, options);
          const result = yield res.text();
          if (res.ok) {
            callback(null, result);
          } else {
            const isHtml = res.headers.get("content-type") === "text/html";
            callback(
              new Error(
                `${res.status} ${res.statusText}${isHtml ? "" : `: ${result}`}`
              )
            );
          }
        } catch (err) {
          if (err instanceof Error)
            callback(err);
        }
      }),
      {}
    );
  }
  requestWithType(method, args, struct, skipDataValidation = false) {
    return __async(this, null, function* () {
      const response = yield this.request(method, args);
      if (is(response, ErrorResponse)) {
        throw new Error(`RPC Error: ${response.error.message}`);
      } else if (is(response, ValidResponse)) {
        const err = validate(response.result, struct)[0];
        const errMsg = TYPE_MISMATCH_ERROR + `Result received was: ${JSON.stringify(
          response.result
        )}. Debug info: ${err}`;
        if (skipDataValidation && err) {
          console.warn(errMsg);
          return response.result;
        } else if (err) {
          throw new Error(`RPC Error: ${errMsg}`);
        }
        return response.result;
      }
      throw new Error(`Unexpected RPC Response: ${response}`);
    });
  }
  request(method, args) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        this.rpcClient.request(method, args, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    });
  }
  batchRequestWithType(requests, struct, skipDataValidation = false) {
    return __async(this, null, function* () {
      const responses = yield this.batchRequest(requests);
      const validResponses = responses.filter(
        (response) => is(response, ValidResponse) && (skipDataValidation || is(response.result, struct))
      );
      if (responses.length > validResponses.length) {
        console.warn(
          `Batch request contains invalid responses. ${responses.length - validResponses.length} of the ${responses.length} requests has invalid schema.`
        );
        const exampleTypeMismatch = responses.find(
          (r) => !is(r.result, struct)
        );
        const exampleInvalidResponseIndex = responses.findIndex(
          (r) => !is(r, ValidResponse)
        );
        if (exampleTypeMismatch) {
          console.warn(
            TYPE_MISMATCH_ERROR + `One example mismatch is: ${JSON.stringify(
              exampleTypeMismatch.result
            )}`
          );
        }
        if (exampleInvalidResponseIndex !== -1) {
          console.warn(
            `The request ${JSON.stringify(
              requests[exampleInvalidResponseIndex]
            )} within a batch request returns an invalid response ${JSON.stringify(
              responses[exampleInvalidResponseIndex]
            )}`
          );
        }
      }
      return validResponses.map(
        (response) => response.result
      );
    });
  }
  batchRequest(requests) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        if (requests.length === 0)
          resolve([]);
        const batch = requests.map((params) => {
          return this.rpcClient.request(params.method, params.args);
        });
        this.rpcClient.request(batch, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    });
  }
};

// src/types/common.ts
import {
  literal as literal2,
  number,
  object as object2,
  string as string2,
  union,
  unknown
} from "superstruct";

// src/cryptography/hash.ts
import { fromHEX as fromHEX2 } from "@mysten/bcs";
import sha33 from "js-sha3";
function sha256Hash(typeTag, data) {
  const hash = sha33.sha3_256.create();
  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  hash.update(dataWithTag);
  return fromHEX2(hash.hex());
}

// src/types/common.ts
import { fromB58, toB58 } from "@mysten/bcs";
var TransactionDigest = string2();
var TransactionEffectsDigest = string2();
var ObjectId = string2();
var SuiAddress = string2();
var SequenceNumber = number();
var ObjectOwner = union([
  object2({
    AddressOwner: SuiAddress
  }),
  object2({
    ObjectOwner: SuiAddress
  }),
  object2({
    Shared: object2({
      initial_shared_version: number()
    })
  }),
  literal2("Immutable")
]);
var SuiJsonValue = unknown();
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = fromB58(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH = 20;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function generateTransactionDigest(data, bcs2) {
  const txBytes = bcs2.ser("TransactionData", data).toBytes();
  const hash = sha256Hash("TransactionData", txBytes);
  return toB58(hash);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}

// src/types/objects.ts
import {
  any as any2,
  array,
  assign,
  boolean,
  literal as literal3,
  number as number2,
  object as object3,
  optional as optional2,
  record,
  string as string3,
  union as union2
} from "superstruct";
var ObjectType = union2([literal3("moveObject"), literal3("package")]);
var SuiObjectRef = object3({
  digest: TransactionDigest,
  objectId: string3(),
  version: number2()
});
var SuiGasData = object3({
  payment: SuiObjectRef,
  owner: string3(),
  price: number2(),
  budget: number2()
});
var SuiObjectInfo = assign(
  SuiObjectRef,
  object3({
    type: string3(),
    owner: ObjectOwner,
    previousTransaction: TransactionDigest
  })
);
var ObjectContentFields = record(string3(), any2());
var MovePackageContent = record(string3(), string3());
var SuiMoveObject = object3({
  type: string3(),
  fields: ObjectContentFields,
  has_public_transfer: optional2(boolean())
});
var SuiMovePackage = object3({
  disassembled: MovePackageContent
});
var SuiData = union2([
  assign(SuiMoveObject, object3({ dataType: literal3("moveObject") })),
  assign(SuiMovePackage, object3({ dataType: literal3("package") }))
]);
var MIST_PER_SUI = BigInt(1e9);
var SuiObject = object3({
  data: SuiData,
  owner: ObjectOwner,
  previousTransaction: TransactionDigest,
  storageRebate: number2(),
  reference: SuiObjectRef
});
var ObjectStatus = union2([
  literal3("Exists"),
  literal3("NotExists"),
  literal3("Deleted")
]);
var GetOwnedObjectsResponse = array(SuiObjectInfo);
var GetObjectDataResponse = object3({
  status: ObjectStatus,
  details: union2([SuiObject, ObjectId, SuiObjectRef])
});
function getObjectExistsResponse(resp) {
  return resp.status !== "Exists" ? void 0 : resp.details;
}
function getObjectDeletedResponse(resp) {
  return resp.status !== "Deleted" ? void 0 : resp.details;
}
function getObjectNotExistsResponse(resp) {
  return resp.status !== "NotExists" ? void 0 : resp.details;
}
function getObjectReference(resp) {
  var _a;
  return ((_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.reference) || getObjectDeletedResponse(resp);
}
function getObjectId(data) {
  var _a, _b;
  if ("objectId" in data) {
    return data.objectId;
  }
  return (_b = (_a = getObjectReference(data)) == null ? void 0 : _a.objectId) != null ? _b : getObjectNotExistsResponse(data);
}
function getObjectVersion(data) {
  var _a;
  if ("version" in data) {
    return data.version;
  }
  return (_a = getObjectReference(data)) == null ? void 0 : _a.version;
}
function getObjectType(resp) {
  var _a;
  return (_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.data.dataType;
}
function getObjectPreviousTransactionDigest(resp) {
  var _a;
  return (_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.previousTransaction;
}
function getObjectOwner(resp) {
  var _a;
  return (_a = getObjectExistsResponse(resp)) == null ? void 0 : _a.owner;
}
function getSharedObjectInitialVersion(resp) {
  const owner = getObjectOwner(resp);
  if (typeof owner === "object" && "Shared" in owner) {
    return owner.Shared.initial_shared_version;
  } else {
    return void 0;
  }
}
function isSharedObject(resp) {
  const owner = getObjectOwner(resp);
  return typeof owner === "object" && "Shared" in owner;
}
function isImmutableObject(resp) {
  const owner = getObjectOwner(resp);
  return owner === "Immutable";
}
function getMoveObjectType(resp) {
  var _a;
  return (_a = getMoveObject(resp)) == null ? void 0 : _a.type;
}
function getObjectFields(resp) {
  var _a;
  if ("fields" in resp) {
    return resp.fields;
  }
  return (_a = getMoveObject(resp)) == null ? void 0 : _a.fields;
}
function getMoveObject(data) {
  const suiObject = "data" in data ? data : getObjectExistsResponse(data);
  if ((suiObject == null ? void 0 : suiObject.data.dataType) !== "moveObject") {
    return void 0;
  }
  return suiObject.data;
}
function hasPublicTransfer(data) {
  var _a, _b;
  return (_b = (_a = getMoveObject(data)) == null ? void 0 : _a.has_public_transfer) != null ? _b : false;
}
function getMovePackageContent(data) {
  if ("disassembled" in data) {
    return data.disassembled;
  }
  const suiObject = getObjectExistsResponse(data);
  if ((suiObject == null ? void 0 : suiObject.data.dataType) !== "package") {
    return void 0;
  }
  return suiObject.data.disassembled;
}

// src/types/events.ts
import {
  object as object4,
  number as number3,
  string as string4,
  bigint,
  union as union3,
  literal as literal4,
  array as array2,
  record as record2,
  any as any3,
  optional as optional3
} from "superstruct";
var BalanceChangeType = union3([
  literal4("Gas"),
  literal4("Pay"),
  literal4("Receive")
]);
var MoveEvent = object4({
  packageId: ObjectId,
  transactionModule: string4(),
  sender: SuiAddress,
  type: string4(),
  fields: record2(string4(), any3()),
  bcs: string4()
});
var PublishEvent = object4({
  sender: SuiAddress,
  packageId: ObjectId,
  version: optional3(number3()),
  digest: optional3(string4())
});
var CoinBalanceChangeEvent = object4({
  packageId: ObjectId,
  transactionModule: string4(),
  sender: SuiAddress,
  owner: ObjectOwner,
  changeType: BalanceChangeType,
  coinType: string4(),
  coinObjectId: ObjectId,
  version: SequenceNumber,
  amount: number3()
});
var TransferObjectEvent = object4({
  packageId: ObjectId,
  transactionModule: string4(),
  sender: SuiAddress,
  recipient: ObjectOwner,
  objectType: string4(),
  objectId: ObjectId,
  version: SequenceNumber
});
var MutateObjectEvent = object4({
  packageId: ObjectId,
  transactionModule: string4(),
  sender: SuiAddress,
  objectType: string4(),
  objectId: ObjectId,
  version: SequenceNumber
});
var DeleteObjectEvent = object4({
  packageId: ObjectId,
  transactionModule: string4(),
  sender: SuiAddress,
  objectId: ObjectId,
  version: SequenceNumber
});
var NewObjectEvent = object4({
  packageId: ObjectId,
  transactionModule: string4(),
  sender: SuiAddress,
  recipient: ObjectOwner,
  objectType: string4(),
  objectId: ObjectId,
  version: SequenceNumber
});
var EpochChangeEvent = union3([bigint(), number3()]);
var CheckpointEvent = union3([bigint(), number3()]);
var SuiEvent = union3([
  object4({ moveEvent: MoveEvent }),
  object4({ publish: PublishEvent }),
  object4({ coinBalanceChange: CoinBalanceChangeEvent }),
  object4({ transferObject: TransferObjectEvent }),
  object4({ mutateObject: MutateObjectEvent }),
  object4({ deleteObject: DeleteObjectEvent }),
  object4({ newObject: NewObjectEvent }),
  object4({ epochChange: EpochChangeEvent }),
  object4({ checkpoint: CheckpointEvent })
]);
var EventId = object4({
  txDigest: TransactionDigest,
  eventSeq: number3()
});
var SuiEventEnvelope = object4({
  timestamp: number3(),
  txDigest: TransactionDigest,
  id: EventId,
  event: SuiEvent
});
var PaginatedEvents = object4({
  data: array2(SuiEventEnvelope),
  nextCursor: union3([EventId, literal4(null)])
});
var SubscriptionId = number3();
var SubscriptionEvent = object4({
  subscription: SubscriptionId,
  result: SuiEventEnvelope
});

// src/types/transactions.ts
import {
  is as is2,
  array as array3,
  literal as literal5,
  number as number4,
  object as object5,
  optional as optional4,
  string as string5,
  union as union4,
  unknown as unknown2,
  boolean as boolean2,
  tuple
} from "superstruct";
var EpochId = number4();
var TransferObject = object5({
  recipient: SuiAddress,
  objectRef: SuiObjectRef
});
var SuiTransferSui = object5({
  recipient: SuiAddress,
  amount: union4([number4(), literal5(null)])
});
var SuiChangeEpoch = object5({
  epoch: EpochId,
  storage_charge: number4(),
  computation_charge: number4(),
  storage_rebate: optional4(number4()),
  epoch_start_timestamp_ms: optional4(number4())
});
var SuiConsensusCommitPrologue = object5({
  checkpoint_start_timestamp_ms: number4()
});
var Pay = object5({
  coins: array3(SuiObjectRef),
  recipients: array3(SuiAddress),
  amounts: array3(number4())
});
var PaySui = object5({
  coins: array3(SuiObjectRef),
  recipients: array3(SuiAddress),
  amounts: array3(number4())
});
var PayAllSui = object5({
  coins: array3(SuiObjectRef),
  recipient: SuiAddress
});
var MoveCall = object5({
  package: string5(),
  module: string5(),
  function: string5(),
  typeArguments: optional4(array3(string5())),
  arguments: optional4(array3(SuiJsonValue))
});
var Genesis = object5({
  objects: array3(ObjectId)
});
var SuiTransactionKind = union4([
  object5({ TransferObject }),
  object5({ Publish: SuiMovePackage }),
  object5({ Call: MoveCall }),
  object5({ TransferSui: SuiTransferSui }),
  object5({ ChangeEpoch: SuiChangeEpoch }),
  object5({ ConsensusCommitPrologue: SuiConsensusCommitPrologue }),
  object5({ Pay }),
  object5({ PaySui }),
  object5({ PayAllSui }),
  object5({ Genesis })
]);
var SuiTransactionData = object5({
  transactions: array3(SuiTransactionKind),
  sender: SuiAddress,
  gasData: SuiGasData
});
var AuthoritySignature = string5();
var GenericAuthoritySignature = union4([
  AuthoritySignature,
  array3(AuthoritySignature)
]);
var AuthorityQuorumSignInfo = object5({
  epoch: EpochId,
  signature: GenericAuthoritySignature,
  signers_map: array3(number4())
});
var CertifiedTransaction = object5({
  transactionDigest: TransactionDigest,
  data: SuiTransactionData,
  txSignatures: array3(string5()),
  authSignInfo: AuthorityQuorumSignInfo
});
var GasCostSummary = object5({
  computationCost: number4(),
  storageCost: number4(),
  storageRebate: number4()
});
var ExecutionStatusType = union4([
  literal5("success"),
  literal5("failure")
]);
var ExecutionStatus = object5({
  status: ExecutionStatusType,
  error: optional4(string5())
});
var OwnedObjectRef = object5({
  owner: ObjectOwner,
  reference: SuiObjectRef
});
var TransactionEffects = object5({
  status: ExecutionStatus,
  executedEpoch: optional4(EpochId),
  gasUsed: GasCostSummary,
  sharedObjects: optional4(array3(SuiObjectRef)),
  transactionDigest: TransactionDigest,
  created: optional4(array3(OwnedObjectRef)),
  mutated: optional4(array3(OwnedObjectRef)),
  unwrapped: optional4(array3(OwnedObjectRef)),
  deleted: optional4(array3(SuiObjectRef)),
  unwrapped_then_deleted: optional4(array3(SuiObjectRef)),
  wrapped: optional4(array3(SuiObjectRef)),
  gasObject: OwnedObjectRef,
  events: optional4(array3(SuiEvent)),
  dependencies: optional4(array3(TransactionDigest))
});
var ReturnValueType = tuple([array3(number4()), string5()]);
var MutableReferenceOutputType = tuple([number4(), array3(number4()), string5()]);
var ExecutionResultType = object5({
  mutableReferenceOutputs: optional4(array3(MutableReferenceOutputType)),
  returnValues: optional4(array3(ReturnValueType))
});
var DevInspectResultTupleType = tuple([number4(), ExecutionResultType]);
var DevInspectResultsType = union4([
  object5({ Ok: array3(DevInspectResultTupleType) }),
  object5({ Err: string5() })
]);
var DevInspectResults = object5({
  effects: TransactionEffects,
  results: DevInspectResultsType
});
var SuiCertifiedTransactionEffects = object5({
  transactionEffectsDigest: string5(),
  authSignInfo: AuthorityQuorumSignInfo,
  effects: TransactionEffects
});
var SuiEffectsFinalityInfo = union4([
  object5({ certified: AuthorityQuorumSignInfo }),
  object5({ checkpointed: tuple([number4(), number4()]) })
]);
var SuiFinalizedEffects = object5({
  transactionEffectsDigest: string5(),
  effects: TransactionEffects,
  finalityInfo: SuiEffectsFinalityInfo
});
var GetTxnDigestsResponse = array3(TransactionDigest);
var PaginatedTransactionDigests = object5({
  data: array3(TransactionDigest),
  nextCursor: union4([TransactionDigest, literal5(null)])
});
var AuthorityName = string5();
var TransactionBytes = object5({
  txBytes: string5(),
  gas: SuiObjectRef,
  inputObjects: unknown2()
});
var SuiParsedMergeCoinResponse = object5({
  updatedCoin: SuiObject,
  updatedGas: SuiObject
});
var SuiParsedSplitCoinResponse = object5({
  updatedCoin: SuiObject,
  newCoins: array3(SuiObject),
  updatedGas: SuiObject
});
var SuiPackage = object5({
  digest: string5(),
  objectId: string5(),
  version: number4()
});
var SuiParsedPublishResponse = object5({
  createdObjects: array3(SuiObject),
  package: SuiPackage,
  updatedGas: SuiObject
});
var SuiParsedTransactionResponse = union4([
  object5({ SplitCoin: SuiParsedSplitCoinResponse }),
  object5({ MergeCoin: SuiParsedMergeCoinResponse }),
  object5({ Publish: SuiParsedPublishResponse })
]);
var SuiTransaction = object5({
  data: SuiTransactionData,
  txSignatures: array3(string5())
});
var SuiTransactionResponse = object5({
  transaction: optional4(SuiTransaction),
  certificate: optional4(CertifiedTransaction),
  effects: TransactionEffects,
  timestamp_ms: optional4(union4([number4(), literal5(null)])),
  timestampMs: optional4(union4([number4(), literal5(null)])),
  checkpoint: optional4(union4([number4(), literal5(null)])),
  confirmedLocalExecution: optional4(boolean2()),
  parsed_data: optional4(union4([SuiParsedTransactionResponse, literal5(null)]))
});
var SuiExecuteTransactionResponse = union4([
  object5({
    EffectsCert: object5({
      certificate: CertifiedTransaction,
      effects: SuiCertifiedTransactionEffects,
      confirmed_local_execution: boolean2()
    })
  }),
  object5({
    certificate: optional4(CertifiedTransaction),
    effects: SuiFinalizedEffects,
    confirmed_local_execution: boolean2()
  }),
  SuiTransactionResponse
]);
function getCertifiedTransaction(tx) {
  if ("certificate" in tx) {
    return tx.certificate;
  } else if ("EffectsCert" in tx) {
    return tx.EffectsCert.certificate;
  }
  return void 0;
}
function getTransactionDigest(tx) {
  if ("transactionDigest" in tx) {
    return tx.transactionDigest;
  }
  const effects = getTransactionEffects(tx);
  return effects.transactionDigest;
}
function getTransactionSignature(tx) {
  const certificateOrTx = "certificate" in tx ? tx.certificate : "transaction" in tx ? tx.transaction : tx;
  if ("txSignatures" in certificateOrTx) {
    return certificateOrTx.txSignatures;
  }
  return [];
}
function getTransactionData(tx) {
  return tx.data;
}
function getTransactionSender(tx) {
  return tx.certificate ? tx.certificate.data.sender : tx.transaction.data.sender;
}
function getGasData(tx) {
  if ("data" in tx) {
    return tx.data.gasData;
  }
  if ("certificate" in tx) {
    return tx.certificate.data.gasData;
  }
  return tx.transaction.data.gasData;
}
function getTransactionGasObject(tx) {
  return getGasData(tx).payment;
}
function getTransactionGasPrice(tx) {
  return getGasData(tx).price;
}
function getTransactionGasBudget(tx) {
  return getGasData(tx).budget;
}
function getTransferObjectTransaction(data) {
  return "TransferObject" in data ? data.TransferObject : void 0;
}
function getPublishTransaction(data) {
  return "Publish" in data ? data.Publish : void 0;
}
function getMoveCallTransaction(data) {
  return "Call" in data ? data.Call : void 0;
}
function getTransferSuiTransaction(data) {
  return "TransferSui" in data ? data.TransferSui : void 0;
}
function getPayTransaction(data) {
  return "Pay" in data ? data.Pay : void 0;
}
function getPaySuiTransaction(data) {
  return "PaySui" in data ? data.PaySui : void 0;
}
function getPayAllSuiTransaction(data) {
  return "PayAllSui" in data ? data.PayAllSui : void 0;
}
function getChangeEpochTransaction(data) {
  return "ChangeEpoch" in data ? data.ChangeEpoch : void 0;
}
function getConsensusCommitPrologueTransaction(data) {
  return "ConsensusCommitPrologue" in data ? data.ConsensusCommitPrologue : void 0;
}
function getTransactions(data) {
  return data.certificate ? data.certificate.data.transactions : data.transaction.data.transactions;
}
function getTransferSuiAmount(data) {
  return "TransferSui" in data && data.TransferSui.amount ? BigInt(data.TransferSui.amount) : null;
}
function getTransactionKindName(data) {
  return Object.keys(data)[0];
}
function getExecutionStatusType(data) {
  var _a;
  return (_a = getExecutionStatus(data)) == null ? void 0 : _a.status;
}
function getExecutionStatus(data) {
  var _a;
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.status;
}
function getExecutionStatusError(data) {
  var _a;
  return (_a = getExecutionStatus(data)) == null ? void 0 : _a.error;
}
function getExecutionStatusGasSummary(data) {
  var _a;
  if (is2(data, TransactionEffects)) {
    return data.gasUsed;
  }
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.gasUsed;
}
function getTotalGasUsed(data) {
  const gasSummary = getExecutionStatusGasSummary(data);
  return gasSummary ? gasSummary.computationCost + gasSummary.storageCost - gasSummary.storageRebate : void 0;
}
function getTotalGasUsedUpperBound(data) {
  const gasSummary = getExecutionStatusGasSummary(data);
  return gasSummary ? gasSummary.computationCost + gasSummary.storageCost : void 0;
}
function getTransactionEffects(data) {
  if ("effects" in data) {
    return `effects` in data.effects ? data.effects.effects : data.effects;
  }
  return "EffectsCert" in data ? data.EffectsCert.effects.effects : void 0;
}
function getEvents(data) {
  var _a;
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.events;
}
function getCreatedObjects(data) {
  var _a;
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.created;
}
function getTimestampFromTransactionResponse(data) {
  var _a;
  return "timestamp_ms" in data || "timestampMs" in data ? (_a = data.timestamp_ms || data.timestampMs) != null ? _a : void 0 : void 0;
}
function getParsedSplitCoinResponse(data) {
  const parsed = data.parsed_data;
  return parsed && "SplitCoin" in parsed ? parsed.SplitCoin : void 0;
}
function getParsedMergeCoinResponse(data) {
  const parsed = data.parsed_data;
  return parsed && "MergeCoin" in parsed ? parsed.MergeCoin : void 0;
}
function getParsedPublishResponse(data) {
  const parsed = data.parsed_data;
  return parsed && "Publish" in parsed ? parsed.Publish : void 0;
}
function getCoinAfterMerge(data) {
  var _a;
  return (_a = getParsedMergeCoinResponse(data)) == null ? void 0 : _a.updatedCoin;
}
function getCoinAfterSplit(data) {
  var _a;
  return (_a = getParsedSplitCoinResponse(data)) == null ? void 0 : _a.updatedCoin;
}
function getNewlyCreatedCoinsAfterSplit(data) {
  var _a;
  return (_a = getParsedSplitCoinResponse(data)) == null ? void 0 : _a.newCoins;
}
function getNewlyCreatedCoinRefsAfterSplit(data) {
  var _a, _b;
  if ("EffectsCert" in data) {
    const effects = data.EffectsCert.effects.effects;
    return (_a = effects.created) == null ? void 0 : _a.map((c) => c.reference);
  }
  if ("effects" in data) {
    const effects = "effects" in data.effects ? data.effects.effects : data.effects;
    return (_b = effects.created) == null ? void 0 : _b.map((c) => c.reference);
  }
  return void 0;
}

// src/types/option.ts
function getOption(option) {
  if (typeof option === "object" && option !== null && "type" in option && option.type.startsWith("0x1::option::Option<")) {
    return void 0;
  }
  return option;
}

// src/framework/framework.ts
import { literal as literal6, number as number5, object as object6, string as string6, union as union5 } from "superstruct";
var SUI_FRAMEWORK_ADDRESS = "0x2";
var MOVE_STDLIB_ADDRESS = "0x1";
var OBJECT_MODULE_NAME = "object";
var UID_STRUCT_NAME = "UID";
var ID_STRUCT_NAME = "ID";
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var PAY_MODULE_NAME = "pay";
var PAY_SPLIT_COIN_VEC_FUNC_NAME = "split_vec";
var PAY_JOIN_COIN_FUNC_NAME = "join";
var COIN_TYPE_ARG_REGEX = /^0x2::coin::Coin<(.+)>$/;
var CoinMetadataStruct = object6({
  decimals: number5(),
  name: string6(),
  symbol: string6(),
  description: string6(),
  iconUrl: union5([string6(), literal6(null)]),
  id: union5([ObjectId, literal6(null)])
});
var Coin = class {
  static isCoin(data) {
    var _a;
    return ((_a = Coin.getType(data)) == null ? void 0 : _a.match(COIN_TYPE_ARG_REGEX)) != null;
  }
  static getCoinType(type) {
    var _a;
    const [, res] = (_a = type.match(COIN_TYPE_ARG_REGEX)) != null ? _a : [];
    return res || null;
  }
  static getCoinTypeArg(obj) {
    const type = Coin.getType(obj);
    return type ? Coin.getCoinType(type) : null;
  }
  static isSUI(obj) {
    const arg = Coin.getCoinTypeArg(obj);
    return arg ? Coin.getCoinSymbol(arg) === "SUI" : false;
  }
  static getCoinSymbol(coinTypeArg) {
    return coinTypeArg.substring(coinTypeArg.lastIndexOf(":") + 1);
  }
  static getCoinStructTag(coinTypeArg) {
    return {
      address: normalizeSuiObjectId(coinTypeArg.split("::")[0]),
      module: coinTypeArg.split("::")[1],
      name: coinTypeArg.split("::")[2],
      typeParams: []
    };
  }
  static getID(obj) {
    if ("fields" in obj) {
      return obj.fields.id.id;
    }
    return getObjectId(obj);
  }
  static selectCoinsWithBalanceGreaterThanOrEqual(coins, amount, exclude = []) {
    return Coin.sortByBalance(
      coins.filter(
        (c) => !exclude.includes(Coin.getID(c)) && Coin.getBalance(c) >= amount
      )
    );
  }
  static selectCoinWithBalanceGreaterThanOrEqual(coins, amount, exclude = []) {
    return coins.find(
      (c) => !exclude.includes(Coin.getID(c)) && Coin.getBalance(c) >= amount
    );
  }
  static selectCoinSetWithCombinedBalanceGreaterThanOrEqual(coins, amount, exclude = []) {
    const sortedCoins = Coin.sortByBalance(
      coins.filter((c) => !exclude.includes(Coin.getID(c)))
    );
    const total = Coin.totalBalance(sortedCoins);
    if (total < amount) {
      return [];
    } else if (total === amount) {
      return sortedCoins;
    }
    let sum = BigInt(0);
    let ret = [];
    while (sum < total) {
      const target = amount - sum;
      const coinWithSmallestSufficientBalance = sortedCoins.find(
        (c) => Coin.getBalance(c) >= target
      );
      if (coinWithSmallestSufficientBalance) {
        ret.push(coinWithSmallestSufficientBalance);
        break;
      }
      const coinWithLargestBalance = sortedCoins.pop();
      ret.push(coinWithLargestBalance);
      sum += Coin.getBalance(coinWithLargestBalance);
    }
    return Coin.sortByBalance(ret);
  }
  static totalBalance(coins) {
    return coins.reduce(
      (partialSum, c) => partialSum + Coin.getBalance(c),
      BigInt(0)
    );
  }
  static sortByBalance(coins) {
    return [...coins].sort(
      (a, b) => Coin.getBalance(a) < Coin.getBalance(b) ? -1 : Coin.getBalance(a) > Coin.getBalance(b) ? 1 : 0
    );
  }
  static getBalance(data) {
    var _a;
    if (!Coin.isCoin(data)) {
      return void 0;
    }
    const balance = (_a = getObjectFields(data)) == null ? void 0 : _a.balance;
    return BigInt(balance);
  }
  static getZero() {
    return BigInt(0);
  }
  static getType(data) {
    if ("status" in data) {
      return getMoveObjectType(data);
    }
    return data.type;
  }
  static newPayTransaction(allCoins, coinTypeArg, amountToSend, recipient, gasBudget) {
    return __async(this, null, function* () {
      const isSuiTransfer = coinTypeArg === SUI_TYPE_ARG;
      const coinsOfTransferType = allCoins.filter(
        (aCoin) => Coin.getCoinTypeArg(aCoin) === coinTypeArg
      );
      const coinsOfGas = isSuiTransfer ? coinsOfTransferType : allCoins.filter((aCoin) => Coin.isSUI(aCoin));
      const gasCoin = Coin.selectCoinWithBalanceGreaterThanOrEqual(
        coinsOfGas,
        BigInt(gasBudget)
      );
      if (!gasCoin) {
        throw new Error(
          `Unable to find a coin to cover the gas budget ${gasBudget}`
        );
      }
      const totalAmountIncludingGas = amountToSend + BigInt(
        isSuiTransfer ? BigInt(gasBudget) - BigInt(Coin.getBalance(gasCoin) || 0) : 0
      );
      const inputCoinObjs = totalAmountIncludingGas > 0 ? yield Coin.selectCoinSetWithCombinedBalanceGreaterThanOrEqual(
        coinsOfTransferType,
        totalAmountIncludingGas,
        isSuiTransfer ? [Coin.getID(gasCoin)] : []
      ) : [];
      if (totalAmountIncludingGas > 0 && !inputCoinObjs.length) {
        const totalBalanceOfTransferType = Coin.totalBalance(coinsOfTransferType);
        const suggestedAmountToSend = totalBalanceOfTransferType - BigInt(isSuiTransfer ? gasBudget : 0);
        throw new Error(
          `Coin balance ${totalBalanceOfTransferType} is not sufficient to cover the transfer amount ${amountToSend}. Try reducing the transfer amount to ${suggestedAmountToSend}.`
        );
      }
      if (isSuiTransfer) {
        inputCoinObjs.unshift(gasCoin);
      }
      return {
        kind: isSuiTransfer ? "paySui" : "pay",
        data: {
          inputCoins: inputCoinObjs.map(Coin.getID),
          recipients: [recipient],
          amounts: [Number(amountToSend)],
          gasBudget: Number(gasBudget)
        }
      };
    });
  }
};
var _Delegation = class {
  static isDelegationSuiObject(obj) {
    return "type" in obj.data && obj.data.type === _Delegation.SUI_OBJECT_TYPE;
  }
  constructor(obj) {
    this.suiObject = obj;
  }
  nextRewardUnclaimedEpoch() {
    return this.suiObject.data.fields.next_reward_unclaimed_epoch;
  }
  activeDelegation() {
    return BigInt(getOption(this.suiObject.data.fields.active_delegation) || 0);
  }
  delegateAmount() {
    return this.suiObject.data.fields.delegate_amount;
  }
  endingEpoch() {
    return getOption(this.suiObject.data.fields.ending_epoch);
  }
  validatorAddress() {
    return this.suiObject.data.fields.validator_address;
  }
  isActive() {
    return this.activeDelegation() > 0 && !this.endingEpoch();
  }
  hasUnclaimedRewards(epoch) {
    return this.nextRewardUnclaimedEpoch() <= epoch && (this.isActive() || (this.endingEpoch() || 0) > epoch);
  }
};
var Delegation = _Delegation;
Delegation.SUI_OBJECT_TYPE = "0x2::delegation::Delegation";

// src/types/sui-bcs.ts
import { BCS as BCS2, getSuiMoveConfig } from "@mysten/bcs";
function registerUTF8String(bcs2) {
  bcs2.registerType(
    "utf8string",
    (writer, str) => {
      const bytes = Array.from(new TextEncoder().encode(str));
      return writer.writeVec(bytes, (writer2, el) => writer2.write8(el));
    },
    (reader) => {
      let bytes = reader.readVec((reader2) => reader2.read8());
      return new TextDecoder().decode(new Uint8Array(bytes));
    }
  );
}
function isPureArg(arg) {
  return arg.Pure !== void 0;
}
var TRANSACTION_DATA_TYPE_TAG = Array.from("TransactionData::").map(
  (e) => e.charCodeAt(0)
);
function deserializeTransactionBytesToTransactionData(bcs2, bytes) {
  return bcs2.de("TransactionData", bytes);
}
var BCS_SPEC = {
  enums: {
    "Option<T>": {
      None: null,
      Some: "T"
    },
    ObjectArg: {
      ImmOrOwned: "SuiObjectRef",
      Shared: "SharedObjectRef"
    },
    CallArg: {
      Pure: "vector<u8>",
      Object: "ObjectArg",
      ObjVec: "vector<ObjectArg>"
    },
    TypeTag: {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: "TypeTag",
      struct: "StructTag",
      u16: null,
      u32: null,
      u256: null
    },
    Transaction: {
      TransferObject: "TransferObjectTx",
      Publish: "PublishTx",
      Call: "MoveCallTx",
      TransferSui: "TransferSuiTx",
      Pay: "PayTx",
      PaySui: "PaySuiTx",
      PayAllSui: "PayAllSuiTx"
    },
    TransactionKind: {
      Single: "Transaction",
      Batch: "vector<Transaction>"
    },
    TransactionExpiration: {
      None: null,
      Epoch: BCS2.U64
    }
  },
  structs: {
    SuiObjectRef: {
      objectId: BCS2.ADDRESS,
      version: BCS2.U64,
      digest: "ObjectDigest"
    },
    TransferObjectTx: {
      recipient: BCS2.ADDRESS,
      object_ref: "SuiObjectRef"
    },
    PayTx: {
      coins: "vector<SuiObjectRef>",
      recipients: "vector<address>",
      amounts: "vector<u64>"
    },
    PaySuiTx: {
      coins: "vector<SuiObjectRef>",
      recipients: "vector<address>",
      amounts: "vector<u64>"
    },
    PayAllSuiTx: {
      coins: "vector<SuiObjectRef>",
      recipient: BCS2.ADDRESS
    },
    TransferSuiTx: {
      recipient: BCS2.ADDRESS,
      amount: "Option<u64>"
    },
    PublishTx: {
      modules: "vector<vector<u8>>"
    },
    SharedObjectRef: {
      objectId: BCS2.ADDRESS,
      initialSharedVersion: BCS2.U64,
      mutable: BCS2.BOOL
    },
    StructTag: {
      address: BCS2.ADDRESS,
      module: BCS2.STRING,
      name: BCS2.STRING,
      typeParams: "vector<TypeTag>"
    },
    MoveCallTx: {
      package: BCS2.ADDRESS,
      module: BCS2.STRING,
      function: BCS2.STRING,
      typeArguments: "vector<TypeTag>",
      arguments: "vector<CallArg>"
    },
    TransactionData: {
      kind: "TransactionKind",
      sender: BCS2.ADDRESS,
      gasData: "GasData",
      expiration: "TransactionExpiration"
    },
    GasData: {
      payment: "SuiObjectRef",
      owner: BCS2.ADDRESS,
      price: BCS2.U64,
      budget: BCS2.U64
    },
    SenderSignedData: {
      data: "TransactionData",
      txSignatures: "vector<vector<u8>>"
    }
  },
  aliases: {
    ObjectDigest: BCS2.BASE64
  }
};
var BCS_0_27_SPEC = {
  structs: __spreadProps(__spreadValues({}, BCS_SPEC.structs), {
    TransactionData: {
      kind: "TransactionKind",
      sender: BCS2.ADDRESS,
      gasData: "GasData"
    },
    SenderSignedData: {
      data: "TransactionData",
      txSignature: "vector<u8>"
    }
  }),
  enums: BCS_SPEC.enums,
  aliases: {
    ObjectDigest: BCS2.BASE64
  }
};
var bcs = new BCS2(__spreadProps(__spreadValues({}, getSuiMoveConfig()), { types: BCS_SPEC }));
registerUTF8String(bcs);
var bcs_0_27 = new BCS2(__spreadProps(__spreadValues({}, getSuiMoveConfig()), { types: BCS_0_27_SPEC }));
registerUTF8String(bcs_0_27);
function bcsForVersion(v) {
  if ((v == null ? void 0 : v.major) === 0 && (v == null ? void 0 : v.minor) <= 27) {
    return bcs_0_27;
  }
  return bcs;
}

// src/types/version.ts
import { parse } from "@suchipi/femver";
function parseVersionFromString(version) {
  return parse(version);
}
function versionToString(version) {
  const { major, minor, patch } = version;
  return `${major}.${minor}.${patch}`;
}

// src/types/normalized.ts
import {
  array as array4,
  object as object7,
  string as string7,
  union as union6,
  boolean as boolean3,
  define,
  number as number6,
  literal as literal7,
  record as record3,
  is as is3
} from "superstruct";
var SuiMoveFunctionArgType = union6([
  string7(),
  object7({ Object: string7() })
]);
var SuiMoveFunctionArgTypes = array4(SuiMoveFunctionArgType);
var SuiMoveModuleId = object7({
  address: string7(),
  name: string7()
});
var SuiMoveVisibility = union6([
  literal7("Private"),
  literal7("Public"),
  literal7("Friend")
]);
var SuiMoveAbilitySet = object7({
  abilities: array4(string7())
});
var SuiMoveStructTypeParameter = object7({
  constraints: SuiMoveAbilitySet,
  is_phantom: boolean3()
});
var SuiMoveNormalizedTypeParameterType = object7({
  TypeParameter: number6()
});
function isSuiMoveNormalizedType(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return true;
  if (is3(value, SuiMoveNormalizedTypeParameterType))
    return true;
  if (isSuiMoveNormalizedStructType(value))
    return true;
  if (typeof value !== "object")
    return false;
  const valueProperties = value;
  if (is3(valueProperties.Reference, SuiMoveNormalizedType))
    return true;
  if (is3(valueProperties.MutableReference, SuiMoveNormalizedType))
    return true;
  if (is3(valueProperties.Vector, SuiMoveNormalizedType))
    return true;
  return false;
}
var SuiMoveNormalizedType = define(
  "SuiMoveNormalizedType",
  isSuiMoveNormalizedType
);
function isSuiMoveNormalizedStructType(value) {
  if (!value || typeof value !== "object")
    return false;
  const valueProperties = value;
  if (!valueProperties.Struct || typeof valueProperties.Struct !== "object")
    return false;
  const structProperties = valueProperties.Struct;
  if (typeof structProperties.address !== "string" || typeof structProperties.module !== "string" || typeof structProperties.name !== "string" || !Array.isArray(structProperties.type_arguments) || !structProperties.type_arguments.every(
    (value2) => isSuiMoveNormalizedType(value2)
  )) {
    return false;
  }
  return true;
}
var SuiMoveNormalizedStructType = define(
  "SuiMoveNormalizedStructType",
  isSuiMoveNormalizedStructType
);
var SuiMoveNormalizedFunction = object7({
  visibility: SuiMoveVisibility,
  is_entry: boolean3(),
  type_parameters: array4(SuiMoveAbilitySet),
  parameters: array4(SuiMoveNormalizedType),
  return_: array4(SuiMoveNormalizedType)
});
var SuiMoveNormalizedField = object7({
  name: string7(),
  type_: SuiMoveNormalizedType
});
var SuiMoveNormalizedStruct = object7({
  abilities: SuiMoveAbilitySet,
  type_parameters: array4(SuiMoveStructTypeParameter),
  fields: array4(SuiMoveNormalizedField)
});
var SuiMoveNormalizedModule = object7({
  file_format_version: number6(),
  address: string7(),
  name: string7(),
  friends: array4(SuiMoveModuleId),
  structs: record3(string7(), SuiMoveNormalizedStruct),
  exposed_functions: record3(string7(), SuiMoveNormalizedFunction)
});
var SuiMoveNormalizedModules = record3(
  string7(),
  SuiMoveNormalizedModule
);
function extractMutableReference(normalizedType) {
  return typeof normalizedType === "object" && "MutableReference" in normalizedType ? normalizedType.MutableReference : void 0;
}
function extractReference(normalizedType) {
  return typeof normalizedType === "object" && "Reference" in normalizedType ? normalizedType.Reference : void 0;
}
function extractStructTag(normalizedType) {
  if (typeof normalizedType === "object" && "Struct" in normalizedType) {
    return normalizedType;
  }
  const ref = extractReference(normalizedType);
  const mutRef = extractMutableReference(normalizedType);
  if (typeof ref === "object" && "Struct" in ref) {
    return ref;
  }
  if (typeof mutRef === "object" && "Struct" in mutRef) {
    return mutRef;
  }
  return void 0;
}

// src/types/validator.ts
import {
  any as any4,
  array as array5,
  boolean as boolean4,
  literal as literal8,
  number as number7,
  object as object8,
  string as string8,
  union as union7,
  nullable,
  tuple as tuple2,
  optional as optional5
} from "superstruct";
var ValidatorMetaData = object8({
  sui_address: SuiAddress,
  pubkey_bytes: array5(number7()),
  network_pubkey_bytes: array5(number7()),
  worker_pubkey_bytes: array5(number7()),
  proof_of_possession_bytes: array5(number7()),
  name: union7([string8(), array5(number7())]),
  description: union7([string8(), nullable(array5(number7()))]),
  image_url: union7([string8(), nullable(array5(number7()))]),
  project_url: union7([string8(), nullable(array5(number7()))]),
  net_address: array5(number7()),
  consensus_address: array5(number7()),
  worker_address: array5(number7()),
  next_epoch_stake: number7(),
  next_epoch_delegation: number7(),
  next_epoch_gas_price: number7(),
  next_epoch_commission_rate: number7()
});
var Balance = object8({
  value: number7()
});
var StakedSui = object8({
  id: object8({
    id: string8()
  }),
  validator_address: SuiAddress,
  pool_starting_epoch: number7(),
  delegation_request_epoch: number7(),
  principal: Balance,
  sui_token_lock: union7([number7(), literal8(null)])
});
var ActiveFields = object8({
  id: object8({
    id: string8()
  }),
  staked_sui_id: SuiAddress,
  principal_sui_amount: number7(),
  pool_tokens: Balance
});
var ActiveDelegationStatus = object8({
  Active: ActiveFields
});
var DelegatedStake = object8({
  staked_sui: StakedSui,
  delegation_status: union7([literal8("Pending"), ActiveDelegationStatus])
});
var ParametersFields = object8({
  max_validator_candidate_count: string8(),
  min_validator_stake: string8(),
  storage_gas_price: optional5(string8())
});
var Parameters = object8({
  type: string8(),
  fields: ParametersFields
});
var StakeSubsidyFields = object8({
  balance: object8({ value: number7() }),
  current_epoch_amount: number7(),
  epoch_counter: number7()
});
var StakeSubsidy = object8({
  type: string8(),
  fields: StakeSubsidyFields
});
var SuiSupplyFields = object8({
  value: number7()
});
var ContentsFields = object8({
  id: string8(),
  size: number7(),
  head: object8({ vec: array5() }),
  tail: object8({ vec: array5() })
});
var ContentsFieldsWithdraw = object8({
  id: string8(),
  size: number7()
});
var Contents = object8({
  type: string8(),
  fields: ContentsFields
});
var PendingWithdawFields = object8({
  contents: ContentsFieldsWithdraw
});
var DelegationStakingPoolFields = object8({
  delegation_token_supply: SuiSupplyFields,
  pending_delegations: ContentsFields,
  pending_withdraws: PendingWithdawFields,
  rewards_pool: object8({ value: number7() }),
  starting_epoch: number7(),
  sui_balance: number7(),
  validator_address: string8()
});
var DelegationStakingPool = object8({
  type: string8(),
  fields: DelegationStakingPoolFields
});
var CommitteeInfo = object8({
  epoch: number7(),
  protocol_version: optional5(number7()),
  committee_info: optional5(array5(tuple2([AuthorityName, number7()])))
});
var SystemParameters = object8({
  min_validator_stake: number7(),
  max_validator_candidate_count: number7(),
  storage_gas_price: optional5(number7())
});
var Validator = object8({
  metadata: ValidatorMetaData,
  voting_power: number7(),
  stake_amount: number7(),
  pending_stake: number7(),
  pending_withdraw: number7(),
  gas_price: number7(),
  delegation_staking_pool: DelegationStakingPoolFields,
  commission_rate: number7()
});
var ValidatorPair = object8({
  from: SuiAddress,
  to: SuiAddress
});
var ValidatorSet = object8({
  validator_stake: number7(),
  delegation_stake: number7(),
  active_validators: array5(Validator),
  pending_validators: array5(Validator),
  pending_removals: array5(number7()),
  next_epoch_validators: array5(ValidatorMetaData),
  pending_delegation_switches: optional5(
    object8({ contents: array5(ValidatorPair) })
  )
});
var SuiSystemState = object8({
  info: object8({ id: string8() }),
  epoch: number7(),
  protocol_version: optional5(number7()),
  validators: ValidatorSet,
  treasury_cap: SuiSupplyFields,
  storage_fund: Balance,
  parameters: SystemParameters,
  reference_gas_price: number7(),
  validator_report_records: object8({ contents: array5() }),
  stake_subsidy: StakeSubsidyFields,
  safe_mode: boolean4(),
  epoch_start_timestamp_ms: optional5(number7())
});
var MovePendingWithdrawals = object8({
  type: string8(),
  fields: object8({
    contents: object8({
      type: string8(),
      fields: object8({
        id: object8({
          id: string8()
        }),
        size: string8()
      })
    })
  })
});
var MovePendingDelegations = object8({
  type: string8(),
  fields: object8({
    id: object8({
      id: string8()
    }),
    head: nullable(string8()),
    size: string8(),
    tail: nullable(string8())
  })
});
var MoveDelegationStakingPoolFields = object8({
  delegation_token_supply: object8({
    type: string8(),
    fields: object8({
      value: string8()
    })
  }),
  pending_delegations: MovePendingDelegations,
  pending_withdraws: MovePendingWithdrawals,
  rewards_pool: string8(),
  starting_epoch: string8(),
  sui_balance: string8(),
  validator_address: string8()
});
var ValidatorReportRecords = object8({
  type: string8(),
  fields: object8({
    contents: array5(any4())
  })
});
var MoveNextEpochValidatorFields = object8({
  consensus_address: array5(number7()),
  name: union7([string8(), array5(number7())]),
  description: optional5(union7([string8(), array5(number7())])),
  image_url: optional5(union7([string8(), array5(number7())])),
  project_url: optional5(union7([string8(), array5(number7())])),
  net_address: array5(number7()),
  network_pubkey_bytes: array5(number7()),
  next_epoch_commission_rate: string8(),
  next_epoch_delegation: string8(),
  next_epoch_gas_price: string8(),
  next_epoch_stake: string8(),
  proof_of_possession: array5(number7()),
  pubkey_bytes: array5(number7()),
  sui_address: string8(),
  worker_address: array5(number7()),
  worker_pubkey_bytes: array5(number7())
});
var MoveNextEpochValidator = object8({
  type: string8(),
  fields: MoveNextEpochValidatorFields
});
var MoveActiveValidatorFields = object8({
  commission_rate: string8(),
  delegation_staking_pool: object8({
    type: string8(),
    fields: MoveDelegationStakingPoolFields
  }),
  gas_price: string8(),
  metadata: MoveNextEpochValidator,
  pending_stake: string8(),
  pending_withdraw: string8(),
  stake_amount: string8(),
  voting_power: nullable(string8())
});
var MoveActiveValidator = object8({
  type: string8(),
  fields: MoveActiveValidatorFields
});
var MoveValidatorsFieldsClass = object8({
  active_validators: array5(MoveActiveValidator),
  next_epoch_validators: array5(MoveNextEpochValidator),
  pending_delegation_switches: optional5(ValidatorReportRecords),
  pending_removals: array5(number7()),
  pending_validators: array5(number7()),
  quorum_stake_threshold: optional5(string8()),
  total_delegation_stake: string8(),
  total_validator_stake: string8()
});
var MoveSuiSystemObjectFields = object8({
  chain_id: optional5(number7()),
  epoch: string8(),
  protocol_version: optional5(string8()),
  epoch_start_timestamp_ms: optional5(string8()),
  safe_mode: boolean4(),
  id: object8({
    id: string8()
  }),
  parameters: Parameters,
  reference_gas_price: string8(),
  stake_subsidy: object8({
    type: string8(),
    fields: object8({
      balance: string8(),
      current_epoch_amount: string8(),
      epoch_counter: string8()
    })
  }),
  storage_fund: string8(),
  sui_supply: object8({
    type: string8(),
    fields: object8({
      value: string8()
    })
  }),
  validator_report_records: ValidatorReportRecords,
  validators: object8({
    type: string8(),
    fields: MoveValidatorsFieldsClass
  })
});
var MoveSuiSystemObject = object8({
  dataType: literal8("moveObject"),
  type: string8(),
  has_public_transfer: boolean4(),
  fields: MoveSuiSystemObjectFields
});

// src/types/coin.ts
import {
  array as array6,
  literal as literal9,
  nullable as nullable2,
  number as number8,
  object as object9,
  optional as optional6,
  string as string9,
  union as union8
} from "superstruct";
var CoinStruct = object9({
  coinType: string9(),
  coinObjectId: ObjectId,
  version: number8(),
  digest: TransactionDigest,
  balance: number8(),
  lockedUntilEpoch: nullable2(number8()),
  previousTransaction: optional6(TransactionDigest)
});
var PaginatedCoins = object9({
  data: array6(CoinStruct),
  nextCursor: union8([ObjectId, literal9(null)])
});
var CoinBalance = object9({
  coinType: string9(),
  coinObjectCount: number8(),
  totalBalance: number8(),
  lockedBalance: object9({
    epochId: optional6(number8()),
    number: optional6(number8())
  })
});
var CoinSupply = object9({
  value: number8()
});

// src/types/checkpoints.ts
import {
  array as array7,
  literal as literal10,
  number as number9,
  object as object10,
  string as string10,
  union as union9,
  tuple as tuple3,
  optional as optional7
} from "superstruct";
var GasCostSummary2 = object10({
  computation_cost: number9(),
  storage_cost: number9(),
  storage_rebate: number9()
});
var CheckPointContentsDigest = string10();
var CheckpointDigest = string10();
var EndOfEpochData = object10({
  next_epoch_committee: array7(tuple3([string10(), number9()])),
  next_epoch_protocol_version: number9(),
  root_state_digest: optional7(array7(number9()))
});
var CheckpointSummary = object10({
  epoch: number9(),
  sequence_number: number9(),
  network_total_transactions: number9(),
  content_digest: CheckPointContentsDigest,
  previous_digest: union9([CheckpointDigest, literal10(null)]),
  epoch_rolling_gas_cost_summary: GasCostSummary2,
  end_of_epoch_data: union9([EndOfEpochData, literal10(null)]),
  timestamp_ms: union9([number9(), literal10(null)]),
  version_specific_data: optional7(array7(number9()))
});
var ExecutionDigests = object10({
  transaction: TransactionDigest,
  effects: TransactionEffectsDigest
});
var CheckpointContents = object10({
  transactions: array7(ExecutionDigests),
  user_signatures: array7(string10())
});

// src/types/dynamic_fields.ts
import {
  any as any5,
  array as array8,
  literal as literal11,
  number as number10,
  object as object11,
  string as string11,
  union as union10
} from "superstruct";
var DynamicFieldType = union10([
  literal11("DynamicField"),
  literal11("DynamicObject")
]);
var DynamicFieldName = object11({
  type: string11(),
  value: any5()
});
var DynamicFieldInfo = object11({
  name: union10([DynamicFieldName, string11()]),
  type: DynamicFieldType,
  objectType: string11(),
  objectId: ObjectId,
  version: number10(),
  digest: string11()
});
var DynamicFieldPage = object11({
  data: array8(DynamicFieldInfo),
  nextCursor: union10([ObjectId, literal11(null)])
});

// src/rpc/websocket-client.ts
import { is as is4 } from "superstruct";
import { Client as WsRpcClient } from "rpc-websockets";
var getWebsocketUrl = (httpUrl, port) => {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  if (port) {
    url.port = port.toString();
  }
  return url.toString();
};
var isMinimumSubscriptionMessage = (msg) => msg && "subscription" in msg && typeof msg["subscription"] === "number" && "result" in msg && typeof msg["result"] === "object";
var DEFAULT_CLIENT_OPTIONS = {
  connectTimeout: 15e3,
  callTimeout: 3e4,
  reconnectInterval: 3e3,
  maxReconnects: 5
};
var SUBSCRIBE_EVENT_METHOD = "sui_subscribeEvent";
var UNSUBSCRIBE_EVENT_METHOD = "sui_unsubscribeEvent";
var WebsocketClient = class {
  constructor(endpoint, skipValidation, options = DEFAULT_CLIENT_OPTIONS) {
    this.endpoint = endpoint;
    this.skipValidation = skipValidation;
    this.options = options;
    this.connectionState = 0 /* NotConnected */;
    this.connectionTimeout = null;
    this.isSetup = false;
    this.connectionPromise = null;
    this.eventSubscriptions = /* @__PURE__ */ new Map();
    if (this.endpoint.startsWith("http"))
      this.endpoint = getWebsocketUrl(this.endpoint);
    this.rpcClient = new WsRpcClient(this.endpoint, {
      reconnect_interval: this.options.reconnectInterval,
      max_reconnects: this.options.maxReconnects,
      autoconnect: false
    });
  }
  setupSocket() {
    if (this.isSetup)
      return;
    this.rpcClient.on("open", () => {
      if (this.connectionTimeout) {
        clearTimeout(this.connectionTimeout);
        this.connectionTimeout = null;
      }
      this.connectionState = 2 /* Connected */;
      this.rpcClient.socket.on(
        "message",
        this.onSocketMessage.bind(this)
      );
    });
    this.rpcClient.on("close", () => {
      this.connectionState = 0 /* NotConnected */;
    });
    this.rpcClient.on("error", console.error);
    this.isSetup = true;
  }
  onSocketMessage(rawMessage) {
    const msg = JSON.parse(rawMessage);
    const params = msg.params;
    if (msg.method === SUBSCRIBE_EVENT_METHOD) {
      if (this.skipValidation && isMinimumSubscriptionMessage(params)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      } else if (is4(params, SubscriptionEvent)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      }
    }
  }
  connect() {
    return __async(this, null, function* () {
      if (this.connectionPromise)
        return this.connectionPromise;
      if (this.connectionState === 2 /* Connected */)
        return Promise.resolve();
      this.setupSocket();
      this.rpcClient.connect();
      this.connectionState = 1 /* Connecting */;
      this.connectionPromise = new Promise((resolve, reject) => {
        this.connectionTimeout = setTimeout(
          () => reject(new Error("timeout")),
          this.options.connectTimeout
        );
        this.rpcClient.once("open", () => {
          this.refreshSubscriptions();
          this.connectionPromise = null;
          resolve();
        });
        this.rpcClient.once("error", (err) => {
          this.connectionPromise = null;
          reject(err);
        });
      });
      return this.connectionPromise;
    });
  }
  refreshSubscriptions() {
    return __async(this, null, function* () {
      if (this.eventSubscriptions.size === 0)
        return;
      try {
        let newSubs = /* @__PURE__ */ new Map();
        let newSubsArr = yield Promise.all(
          Array.from(this.eventSubscriptions.values()).map((sub) => __async(this, null, function* () {
            const onMessage = sub.onMessage;
            const filter = sub.filter;
            if (!filter || !onMessage)
              return Promise.resolve(null);
            const id = yield this.subscribeEvent(filter, onMessage);
            return { id, onMessage, filter };
          }))
        );
        newSubsArr.forEach((entry) => {
          if (entry === null)
            return;
          const filter = entry.filter;
          const onMessage = entry.onMessage;
          newSubs.set(entry.id, { filter, onMessage });
        });
        this.eventSubscriptions = newSubs;
      } catch (err) {
        throw new Error(`error refreshing event subscriptions: ${err}`);
      }
    });
  }
  subscribeEvent(filter, onMessage) {
    return __async(this, null, function* () {
      try {
        if (this.connectionState !== 2 /* Connected */)
          yield this.connect();
        let subId = yield this.rpcClient.call(
          SUBSCRIBE_EVENT_METHOD,
          [filter],
          this.options.callTimeout
        );
        this.eventSubscriptions.set(subId, { filter, onMessage });
        return subId;
      } catch (err) {
        throw new Error(
          `Error subscribing to event: ${JSON.stringify(
            err,
            null,
            2
          )}, filter: ${JSON.stringify(filter)}`
        );
      }
    });
  }
  unsubscribeEvent(id) {
    return __async(this, null, function* () {
      try {
        if (this.connectionState !== 2 /* Connected */)
          yield this.connect();
        let removedOnNode = yield this.rpcClient.call(
          UNSUBSCRIBE_EVENT_METHOD,
          [id],
          this.options.callTimeout
        );
        return this.eventSubscriptions.delete(id) || removedOnNode;
      } catch (err) {
        throw new Error(
          `Error unsubscribing from event: ${err}, subscription: ${id}`
        );
      }
    });
  }
};

// src/rpc/faucet-client.ts
import fetch2 from "cross-fetch";
var FaucetRateLimitError = class extends Error {
};
function requestSuiFromFaucet(endpoint, recipient, httpHeaders) {
  return __async(this, null, function* () {
    const res = yield fetch2(endpoint, {
      method: "POST",
      body: JSON.stringify({
        FixedAmountRequest: {
          recipient
        }
      }),
      headers: __spreadValues({
        "Content-Type": "application/json"
      }, httpHeaders || {})
    });
    if (res.status === 429) {
      throw new FaucetRateLimitError(
        `Too many requests from this client have been sent to the faucet. Please retry later`
      );
    }
    let parsed;
    try {
      parsed = yield res.json();
    } catch (e) {
      throw new Error(
        `Ecountered error when parsing response from faucet, error: ${e}, status ${res.status}, response ${res}`
      );
    }
    if (parsed.error) {
      throw new Error(`Faucet returns error: ${parsed.error}`);
    }
    return parsed;
  });
}

// src/providers/json-rpc-provider.ts
import { any as any6, is as is5, number as number11, array as array9 } from "superstruct";

// src/signers/txn-data-serializers/call-arg-serializer.ts
var MOVE_CALL_SER_ERROR = "Move call argument serialization error:";
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
var RESOLVED_SUI_ID = {
  address: SUI_FRAMEWORK_ADDRESS,
  module: OBJECT_MODULE_NAME,
  name: ID_STRUCT_NAME
};
var RESOLVED_ASCII_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_ASCII_MODULE_NAME,
  name: STD_ASCII_STRUCT_NAME
};
var RESOLVED_UTF8_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_UTF8_MODULE_NAME,
  name: STD_UTF8_STRUCT_NAME
};
var RESOLVED_STD_OPTION = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_OPTION_MODULE_NAME,
  name: STD_OPTION_STRUCT_NAME
};
var isTypeFunc = (type) => (t) => typeof t === type;
var isSameStruct = (a, b) => a.address === b.address && a.module === b.module && a.name === b.name;
var CallArgSerializer = class {
  constructor(provider) {
    this.provider = provider;
  }
  extractObjectIds(txn) {
    return __async(this, null, function* () {
      const args = yield this.serializeMoveCallArguments(txn);
      return args.map(
        (arg) => "ObjVec" in arg ? Array.from(arg.ObjVec).map((a) => ({
          Object: a
        })) : arg
      ).flat().map((arg) => {
        if ("Object" in arg) {
          const objectArg = arg.Object;
          if ("Shared" in objectArg) {
            return objectArg.Shared.objectId;
          } else {
            return objectArg.ImmOrOwned.objectId;
          }
        }
        return null;
      }).filter((a) => a != null);
    });
  }
  serializeMoveCallArguments(txn) {
    return __async(this, null, function* () {
      const userParams = yield this.extractNormalizedFunctionParams(
        txn.packageObjectId,
        txn.module,
        txn.function
      );
      if (userParams.length !== txn.arguments.length) {
        throw new Error(
          `${MOVE_CALL_SER_ERROR} expect ${userParams.length} arguments, received ${txn.arguments.length} arguments`
        );
      }
      return Promise.all(
        userParams.map(
          (param, i) => __async(this, null, function* () {
            return this.newCallArg(param, txn.arguments[i]);
          })
        )
      );
    });
  }
  deserializeCallArgs(txn) {
    return __async(this, null, function* () {
      const userParams = yield this.extractNormalizedFunctionParams(
        txn.Call.package,
        txn.Call.module,
        txn.Call.function
      );
      return Promise.all(
        userParams.map(
          (param, i) => __async(this, null, function* () {
            return this.deserializeCallArg(param, txn.Call.arguments[i]);
          })
        )
      );
    });
  }
  extractNormalizedFunctionParams(packageId, module, functionName) {
    return __async(this, null, function* () {
      const normalized = yield this.provider.getNormalizedMoveFunction(
        normalizeSuiObjectId(
          typeof packageId === "string" ? packageId : packageId.objectId
        ),
        module,
        functionName
      );
      const params = normalized.parameters;
      const hasTxContext = params.length > 0 && this.isTxContext(params.at(-1));
      return hasTxContext ? params.slice(0, params.length - 1) : params;
    });
  }
  newObjectArg(objectId) {
    return __async(this, null, function* () {
      const object12 = yield this.provider.getObject(objectId);
      const initialSharedVersion = getSharedObjectInitialVersion(object12);
      const mutable = true;
      if (initialSharedVersion) {
        return { Shared: { objectId, initialSharedVersion, mutable } };
      }
      return { ImmOrOwned: getObjectReference(object12) };
    });
  }
  newCallArg(expectedType, argVal) {
    return __async(this, null, function* () {
      if (isPureArg(argVal)) {
        return argVal;
      }
      const serType = this.getPureSerializationType(expectedType, argVal);
      const version = yield this.provider.getRpcApiVersion();
      if (serType !== void 0) {
        return {
          Pure: bcsForVersion(version).ser(serType, argVal).toBytes()
        };
      }
      const structVal = extractStructTag(expectedType);
      if (structVal != null || typeof expectedType === "object" && "TypeParameter" in expectedType) {
        if (typeof argVal !== "string") {
          throw new Error(
            `${MOVE_CALL_SER_ERROR} expect the argument to be an object id string, got ${JSON.stringify(
              argVal,
              null,
              2
            )}`
          );
        }
        return { Object: yield this.newObjectArg(argVal) };
      }
      if (typeof expectedType === "object" && "Vector" in expectedType && typeof expectedType.Vector === "object" && "Struct" in expectedType.Vector) {
        if (!Array.isArray(argVal)) {
          throw new Error(
            `Expect ${argVal} to be a array, received ${typeof argVal}`
          );
        }
        return {
          ObjVec: yield Promise.all(
            argVal.map((arg) => this.newObjectArg(arg))
          )
        };
      }
      throw new Error(
        `Unknown call arg type ${JSON.stringify(expectedType, null, 2)} for value ${JSON.stringify(argVal, null, 2)}`
      );
    });
  }
  extractIdFromObjectArg(arg) {
    if ("ImmOrOwned" in arg) {
      return arg.ImmOrOwned.objectId;
    }
    return arg.Shared.objectId;
  }
  deserializeCallArg(expectedType, argVal) {
    return __async(this, null, function* () {
      if ("Object" in argVal) {
        return this.extractIdFromObjectArg(argVal.Object);
      } else if ("ObjVec" in argVal) {
        return Array.from(argVal.ObjVec).map(
          (o) => this.extractIdFromObjectArg(o)
        );
      }
      const serType = this.getPureSerializationType(expectedType, void 0);
      const version = yield this.provider.getRpcApiVersion();
      return bcsForVersion(version).de(serType, Uint8Array.from(argVal.Pure));
    });
  }
  getPureSerializationType(normalizedType, argVal) {
    const allowedTypes = [
      "Address",
      "Bool",
      "U8",
      "U16",
      "U32",
      "U64",
      "U128",
      "U256"
    ];
    if (typeof normalizedType === "string" && allowedTypes.includes(normalizedType)) {
      if (normalizedType in ["U8", "U16", "U32", "U64", "U128", "U256"]) {
        this.checkArgVal(isTypeFunc("number"), argVal, "number");
      } else if (normalizedType === "Bool") {
        this.checkArgVal(isTypeFunc("boolean"), argVal, "boolean");
      } else if (normalizedType === "Address") {
        this.checkArgVal(
          (t) => typeof t === "string" && isValidSuiAddress(t),
          argVal,
          "valid SUI address"
        );
      }
      return normalizedType.toLowerCase();
    } else if (typeof normalizedType === "string") {
      throw new Error(
        `${MOVE_CALL_SER_ERROR} unknown pure normalized type ${JSON.stringify(
          normalizedType,
          null,
          2
        )}`
      );
    }
    if ("Vector" in normalizedType) {
      if ((argVal === void 0 || typeof argVal === "string") && normalizedType.Vector === "U8") {
        return "string";
      }
      if (argVal !== void 0 && !Array.isArray(argVal)) {
        throw new Error(
          `Expect ${argVal} to be a array, received ${typeof argVal}`
        );
      }
      const innerType = this.getPureSerializationType(
        normalizedType.Vector,
        argVal ? argVal[0] : void 0
      );
      if (innerType === void 0) {
        return void 0;
      }
      return `vector<${innerType}>`;
    }
    if ("Struct" in normalizedType) {
      if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {
        return "string";
      } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {
        return "utf8string";
      } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {
        return "address";
      } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {
        const optionToVec = {
          Vector: normalizedType.Struct.type_arguments[0]
        };
        return this.getPureSerializationType(optionToVec, argVal);
      }
    }
    return void 0;
  }
  checkArgVal(check, argVal, expectedType) {
    if (argVal === void 0) {
      return;
    }
    if (!check(argVal)) {
      throw new Error(
        `Expect ${argVal} to be ${expectedType}, received ${typeof argVal}`
      );
    }
  }
  isTxContext(param) {
    var _a;
    const struct = (_a = extractStructTag(param)) == null ? void 0 : _a.Struct;
    return extractMutableReference(param) != null && (struct == null ? void 0 : struct.address) === "0x2" && (struct == null ? void 0 : struct.module) === "tx_context" && (struct == null ? void 0 : struct.name) === "TxContext";
  }
};

// src/signers/txn-data-serializers/type-tag-serializer.ts
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: TypeTagSerializer.parseFromStr(
          vectorMatch[1],
          normalizeAddress
        )
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(
            structMatch[5],
            normalizeAddress
          )
        }
      };
    }
    throw new Error(
      `Encountered unexpected token when parsing type args for ${str}`
    );
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    const tok = [];
    let word = "";
    let nestedAngleBrackets = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === "<") {
        nestedAngleBrackets++;
      }
      if (char === ">") {
        nestedAngleBrackets--;
      }
      if (nestedAngleBrackets === 0 && char === ",") {
        tok.push(word.trim());
        word = "";
        continue;
      }
      word += char;
    }
    tok.push(word.trim());
    return tok.map(
      (tok2) => TypeTagSerializer.parseFromStr(tok2, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// src/signers/txn-data-serializers/local-txn-data-serializer.ts
var LocalTxnDataSerializer = class {
  constructor(provider) {
    this.provider = provider;
  }
  getRpcApiVersion() {
    return __async(this, null, function* () {
      return yield this.provider.getRpcApiVersion();
    });
  }
  serializeToBytes(signerAddress, txn, _mode = "Commit") {
    return __async(this, null, function* () {
      try {
        return yield this.serializeTransactionData(
          yield this.constructTransactionData(signerAddress, txn)
        );
      } catch (e) {
        throw new Error(
          `Encountered error when serializing a ${txn.kind} transaction for address ${signerAddress} for transaction ${JSON.stringify(
            txn,
            null,
            2
          )}: ${e}`
        );
      }
    });
  }
  serializeToBytesWithoutGasInfo(signerAddress, txn) {
    return __async(this, null, function* () {
      try {
        return yield this.serializeTransactionKind(
          (yield this.constructTransactionKindAndPayment(signerAddress, txn))[0]
        );
      } catch (e) {
        throw new Error(
          `Encountered error when serializing a ${txn.kind} transaction without gas info for address ${signerAddress} for transaction ${JSON.stringify(
            txn,
            null,
            2
          )}: ${e}`
        );
      }
    });
  }
  constructTransactionKindAndPayment(signerAddress, unserializedTxn) {
    return __async(this, null, function* () {
      let tx;
      let gasPayment;
      switch (unserializedTxn.kind) {
        case "transferObject":
          const t = unserializedTxn.data;
          const objectRef = yield this.provider.getObjectRef(t.objectId);
          tx = {
            TransferObject: {
              recipient: t.recipient,
              object_ref: objectRef
            }
          };
          gasPayment = t.gasPayment;
          break;
        case "transferSui":
          const transferSui = unserializedTxn.data;
          tx = {
            TransferSui: {
              recipient: transferSui.recipient,
              amount: transferSui.amount == null ? { None: null } : { Some: transferSui.amount }
            }
          };
          gasPayment = transferSui.suiObjectId;
          break;
        case "pay":
          const pay = unserializedTxn.data;
          const inputCoinRefs = (yield Promise.all(
            pay.inputCoins.map((coin) => this.provider.getObjectRef(coin))
          )).map((ref) => ref);
          tx = {
            Pay: {
              coins: inputCoinRefs,
              recipients: pay.recipients,
              amounts: pay.amounts
            }
          };
          gasPayment = pay.gasPayment;
          break;
        case "paySui":
          const paySui = unserializedTxn.data;
          const paySuiInputCoinRefs = (yield Promise.all(
            paySui.inputCoins.map((coin) => this.provider.getObjectRef(coin))
          )).map((ref) => ref);
          tx = {
            PaySui: {
              coins: paySuiInputCoinRefs,
              recipients: paySui.recipients,
              amounts: paySui.amounts
            }
          };
          gasPayment = paySui.inputCoins[0];
          break;
        case "payAllSui":
          const payAllSui = unserializedTxn.data;
          const payAllSuiInputCoinRefs = (yield Promise.all(
            payAllSui.inputCoins.map(
              (coin) => this.provider.getObjectRef(coin)
            )
          )).map((ref) => ref);
          tx = {
            PayAllSui: {
              coins: payAllSuiInputCoinRefs,
              recipient: payAllSui.recipient
            }
          };
          gasPayment = payAllSui.inputCoins[0];
          break;
        case "moveCall":
          const moveCall = unserializedTxn.data;
          const pkg = normalizeSuiObjectId(moveCall.packageObjectId);
          tx = {
            Call: {
              package: pkg,
              module: moveCall.module,
              function: moveCall.function,
              typeArguments: moveCall.typeArguments.map(
                (a) => typeof a === "string" ? TypeTagSerializer.parseFromStr(a, true) : a
              ),
              arguments: yield new CallArgSerializer(
                this.provider
              ).serializeMoveCallArguments(moveCall)
            }
          };
          gasPayment = moveCall.gasPayment;
          break;
        case "mergeCoin":
          const mergeCoin = unserializedTxn.data;
          return this.constructTransactionKindAndPayment(signerAddress, {
            kind: "moveCall",
            data: {
              packageObjectId: SUI_FRAMEWORK_ADDRESS,
              module: PAY_MODULE_NAME,
              function: PAY_JOIN_COIN_FUNC_NAME,
              typeArguments: [yield this.getCoinStructTag(mergeCoin.coinToMerge)],
              arguments: [mergeCoin.primaryCoin, mergeCoin.coinToMerge],
              gasPayment: mergeCoin.gasPayment,
              gasBudget: mergeCoin.gasBudget
            }
          });
        case "splitCoin":
          const splitCoin = unserializedTxn.data;
          return this.constructTransactionKindAndPayment(signerAddress, {
            kind: "moveCall",
            data: {
              packageObjectId: SUI_FRAMEWORK_ADDRESS,
              module: PAY_MODULE_NAME,
              function: PAY_SPLIT_COIN_VEC_FUNC_NAME,
              typeArguments: [
                yield this.getCoinStructTag(splitCoin.coinObjectId)
              ],
              arguments: [splitCoin.coinObjectId, splitCoin.splitAmounts],
              gasPayment: splitCoin.gasPayment,
              gasBudget: splitCoin.gasBudget
            }
          });
        case "publish":
          const publish = unserializedTxn.data;
          tx = {
            Publish: {
              modules: publish.compiledModules
            }
          };
          gasPayment = publish.gasPayment;
          break;
      }
      return [{ Single: tx }, gasPayment];
    });
  }
  constructTransactionData(signerAddress, unserializedTxn) {
    return __async(this, null, function* () {
      const [tx, gasPayment] = yield this.constructTransactionKindAndPayment(
        signerAddress,
        unserializedTxn
      );
      return this.constructTransactionDataHelper(
        tx,
        unserializedTxn,
        gasPayment,
        signerAddress
      );
    });
  }
  selectGasPaymentForTransaction(_0, _1) {
    return __async(this, arguments, function* (txn, signerAddress, exclude = []) {
      if (txn.kind === "bytes") {
        return void 0;
      }
      const requiredGasAmount = BigInt(txn.data.gasBudget) * BigInt(txn.data.gasPrice);
      const coins = yield this.provider.selectCoinsWithBalanceGreaterThanOrEqual(
        signerAddress,
        requiredGasAmount,
        SUI_TYPE_ARG,
        exclude.concat(yield this.extractObjectIds(txn))
      );
      return coins.length > 0 ? Coin.getID(coins[0]) : void 0;
    });
  }
  extractObjectIds(txn) {
    return __async(this, null, function* () {
      const ret = yield this.extractInputObjectIds(txn);
      if ("gasPayment" in txn.data && txn.data["gasPayment"]) {
        ret.push(txn.data["gasPayment"]);
      }
      return ret;
    });
  }
  extractInputObjectIds(txn) {
    return __async(this, null, function* () {
      switch (txn.kind) {
        case "moveCall":
          return yield new CallArgSerializer(this.provider).extractObjectIds(
            txn.data
          );
        case "transferSui":
          return [txn.data.suiObjectId];
        case "transferObject":
          return [txn.data.objectId];
        case "mergeCoin":
          return [txn.data.primaryCoin, txn.data.coinToMerge];
        case "splitCoin":
          return [txn.data.coinObjectId];
        case "pay":
          return txn.data.inputCoins;
      }
      return [];
    });
  }
  getCoinStructTag(coinId) {
    return __async(this, null, function* () {
      const coin = yield this.provider.getObject(coinId);
      const coinTypeArg = Coin.getCoinTypeArg(coin);
      if (coinTypeArg == null) {
        throw new Error(`Object ${coinId} is not a valid coin type`);
      }
      return { struct: Coin.getCoinStructTag(coinTypeArg) };
    });
  }
  constructTransactionDataHelper(tx, originalTx, gasObjectId, signerAddress) {
    return __async(this, null, function* () {
      originalTx.data.gasPrice = yield this.provider.getReferenceGasPrice();
      if (gasObjectId === void 0) {
        gasObjectId = yield this.selectGasPaymentForTransaction(
          originalTx,
          signerAddress
        );
        if (gasObjectId === void 0) {
          throw new Error(
            `Unable to select a gas object with balance greater than or equal to ${originalTx.data.gasBudget}`
          );
        }
      }
      const gasPayment = yield this.provider.getObjectRef(gasObjectId);
      if (!originalTx.data.gasBudget) {
        throw new Error(
          "Must provide a valid gas budget for contructing TransactionData"
        );
      }
      return {
        kind: tx,
        sender: signerAddress,
        gasData: {
          payment: gasPayment,
          price: originalTx.data.gasPrice,
          budget: originalTx.data.gasBudget,
          owner: signerAddress
        },
        expiration: { None: null }
      };
    });
  }
  serializeTransactionData(tx, size = 8192) {
    return __async(this, null, function* () {
      const bcs2 = bcsForVersion(yield this.provider.getRpcApiVersion());
      const dataBytes = bcs2.ser("TransactionData", tx, size).toBytes();
      return dataBytes;
    });
  }
  serializeTransactionKind(tx, size = 8192) {
    return __async(this, null, function* () {
      const bcs2 = bcsForVersion(yield this.provider.getRpcApiVersion());
      const dataBytes = bcs2.ser("TransactionKind", tx, size).toBytes();
      return dataBytes;
    });
  }
  deserializeTransactionBytesToSignableTransaction(bytes) {
    return __async(this, null, function* () {
      let version = yield this.provider.getRpcApiVersion();
      return this.transformTransactionDataToSignableTransaction(
        deserializeTransactionBytesToTransactionData(
          bcsForVersion(version),
          bytes
        )
      );
    });
  }
  transformTransactionDataToSignableTransaction(tx_data) {
    return __async(this, null, function* () {
      if ("Single" in tx_data.kind) {
        return this.transformTransactionToSignableTransaction(
          tx_data.kind.Single,
          tx_data.gasData
        );
      }
      return Promise.all(
        tx_data.kind.Batch.map(
          (t) => this.transformTransactionToSignableTransaction(t, tx_data.gasData)
        )
      );
    });
  }
  transformTransactionToSignableTransaction(tx, gasData) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      if ("Pay" in tx) {
        return {
          kind: "pay",
          data: {
            inputCoins: tx.Pay.coins.map((c) => c.objectId),
            recipients: tx.Pay.recipients,
            amounts: tx.Pay.amounts,
            gasPayment: (_a = gasData.payment) == null ? void 0 : _a.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner,
            gasPrice: gasData.price
          }
        };
      } else if ("Call" in tx) {
        return {
          kind: "moveCall",
          data: {
            packageObjectId: tx.Call.package,
            module: tx.Call.module,
            function: tx.Call.function,
            typeArguments: tx.Call.typeArguments,
            arguments: yield new CallArgSerializer(
              this.provider
            ).deserializeCallArgs(tx),
            gasPayment: (_b = gasData.payment) == null ? void 0 : _b.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner,
            gasPrice: gasData.price
          }
        };
      } else if ("TransferObject" in tx) {
        return {
          kind: "transferObject",
          data: {
            objectId: tx.TransferObject.object_ref.objectId,
            recipient: tx.TransferObject.recipient,
            gasPayment: (_c = gasData.payment) == null ? void 0 : _c.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner,
            gasPrice: gasData.price
          }
        };
      } else if ("TransferSui" in tx) {
        return {
          kind: "transferSui",
          data: {
            suiObjectId: gasData.payment.objectId,
            recipient: tx.TransferSui.recipient,
            amount: "Some" in tx.TransferSui.amount ? tx.TransferSui.amount.Some : null,
            gasBudget: gasData.budget,
            gasPrice: gasData.price
          }
        };
      } else if ("Publish" in tx) {
        return {
          kind: "publish",
          data: {
            compiledModules: tx.Publish.modules,
            gasPayment: (_d = gasData.payment) == null ? void 0 : _d.objectId,
            gasBudget: gasData.budget,
            gasOwner: gasData.owner
          }
        };
      } else if ("PaySui" in tx) {
        return {
          kind: "paySui",
          data: {
            inputCoins: tx.PaySui.coins.map((c) => c.objectId),
            recipients: tx.PaySui.recipients,
            amounts: tx.PaySui.amounts
          }
        };
      } else if ("PayAllSui" in tx) {
        return {
          kind: "payAllSui",
          data: {
            inputCoins: tx.PayAllSui.coins.map((c) => c.objectId),
            recipient: tx.PayAllSui.recipient
          }
        };
      }
      throw new Error(`Unsupported transaction type ${tx}`);
    });
  }
};

// src/providers/json-rpc-provider.ts
import { toB64 as toB646 } from "@mysten/bcs";

// src/rpc/connection.ts
var _options;
var Connection = class {
  constructor(options) {
    __privateAdd(this, _options, void 0);
    __privateSet(this, _options, options);
  }
  get fullnode() {
    return __privateGet(this, _options).fullnode;
  }
  get websocket() {
    return __privateGet(this, _options).websocket || __privateGet(this, _options).fullnode;
  }
  get faucet() {
    return __privateGet(this, _options).faucet;
  }
};
_options = new WeakMap();
var localnetConnection = new Connection({
  fullnode: "http://127.0.0.1:9000",
  faucet: "http://127.0.0.1:9123/gas"
});
var devnetConnection = new Connection({
  fullnode: "https://fullnode.devnet.sui.io:443/",
  faucet: "https://faucet.devnet.sui.io/gas"
});

// src/providers/json-rpc-provider.ts
var TARGETED_RPC_VERSION = "0.27.0";
var DEFAULT_OPTIONS = {
  skipDataValidation: true,
  socketOptions: DEFAULT_CLIENT_OPTIONS,
  versionCacheTimeoutInSeconds: 600
};
var JsonRpcProvider = class extends Provider {
  constructor(connection = devnetConnection, options = DEFAULT_OPTIONS) {
    var _a, _b;
    super();
    this.options = options;
    this.connection = connection;
    const opts = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), options);
    this.options = opts;
    this.client = (_a = opts.rpcClient) != null ? _a : new JsonRpcClient(this.connection.fullnode);
    this.wsClient = (_b = opts.websocketClient) != null ? _b : new WebsocketClient(
      this.connection.websocket,
      opts.skipDataValidation,
      opts.socketOptions
    );
  }
  getRpcApiVersion() {
    return __async(this, null, function* () {
      var _a;
      if (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now()) {
        return this.rpcApiVersion;
      }
      try {
        const resp = yield this.client.requestWithType(
          "rpc.discover",
          [],
          any6(),
          this.options.skipDataValidation
        );
        this.rpcApiVersion = parseVersionFromString(resp.info.version);
        this.cacheExpiry = Date.now() + ((_a = this.options.versionCacheTimeoutInSeconds) != null ? _a : 0) * 1e3;
        return this.rpcApiVersion;
      } catch (err) {
        console.warn("Error fetching version number of the RPC API", err);
      }
      return void 0;
    });
  }
  requestSuiFromFaucet(recipient, httpHeaders) {
    return __async(this, null, function* () {
      if (!this.connection.faucet) {
        throw new Error("Faucet URL is not specified");
      }
      return requestSuiFromFaucet(this.connection.faucet, recipient, httpHeaders);
    });
  }
  getCoins(owner, coinType = null, cursor = null, limit = null) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getCoins",
          [owner, coinType, cursor, limit],
          PaginatedCoins,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting coins for owner ${owner}: ${err}`);
      }
    });
  }
  getAllCoins(owner, cursor = null, limit = null) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getAllCoins",
          [owner, cursor, limit],
          PaginatedCoins,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting all coins for owner ${owner}: ${err}`);
      }
    });
  }
  getBalance(owner, coinType = null) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getBalance",
          [owner, coinType],
          CoinBalance,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting balance for coin type ${coinType} for owner ${owner}: ${err}`
        );
      }
    });
  }
  getAllBalances(owner) {
    return __async(this, null, function* () {
      try {
        if (!owner || !isValidSuiAddress(normalizeSuiAddress(owner))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getAllBalances",
          [owner],
          array9(CoinBalance),
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting all balances for owner ${owner}: ${err}`);
      }
    });
  }
  getCoinMetadata(coinType) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getCoinMetadata",
          [coinType],
          CoinMetadataStruct,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error fetching CoinMetadata for ${coinType}: ${err}`);
      }
    });
  }
  getTotalSupply(coinType) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getTotalSupply",
          [coinType],
          CoinSupply,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching total supply for Coin type ${coinType}: ${err}`
        );
      }
    });
  }
  call(endpoint, params) {
    return __async(this, null, function* () {
      try {
        const response = yield this.client.request(endpoint, params);
        if (is5(response, ErrorResponse)) {
          throw new Error(`RPC Error: ${response.error.message}`);
        }
        return response.result;
      } catch (err) {
        throw new Error(`Error calling RPC endpoint ${endpoint}: ${err}`);
      }
    });
  }
  getMoveFunctionArgTypes(packageId, moduleName, functionName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getMoveFunctionArgTypes",
          [packageId, moduleName, functionName],
          SuiMoveFunctionArgTypes,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching Move function arg types with package object ID: ${packageId}, module name: ${moduleName}, function name: ${functionName}`
        );
      }
    });
  }
  getNormalizedMoveModulesByPackage(packageId) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveModulesByPackage",
          [packageId],
          SuiMoveNormalizedModules,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching package: ${err} for package ${packageId}`
        );
      }
    });
  }
  getNormalizedMoveModule(packageId, moduleName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveModule",
          [packageId, moduleName],
          SuiMoveNormalizedModule,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching module: ${err} for package ${packageId}, module ${moduleName}`
        );
      }
    });
  }
  getNormalizedMoveFunction(packageId, moduleName, functionName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveFunction",
          [packageId, moduleName, functionName],
          SuiMoveNormalizedFunction,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching function: ${err} for package ${packageId}, module ${moduleName} and function ${functionName}`
        );
      }
    });
  }
  getNormalizedMoveStruct(packageId, moduleName, structName) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getNormalizedMoveStruct",
          [packageId, moduleName, structName],
          SuiMoveNormalizedStruct,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching struct: ${err} for package ${packageId}, module ${moduleName} and struct ${structName}`
        );
      }
    });
  }
  getObjectsOwnedByAddress(address) {
    return __async(this, null, function* () {
      try {
        if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
          throw new Error("Invalid Sui address");
        }
        return yield this.client.requestWithType(
          "sui_getObjectsOwnedByAddress",
          [address],
          GetOwnedObjectsResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching owned object: ${err} for address ${address}`
        );
      }
    });
  }
  getGasObjectsOwnedByAddress(address) {
    return __async(this, null, function* () {
      const objects = yield this.getObjectsOwnedByAddress(address);
      return objects.filter((obj) => Coin.isSUI(obj));
    });
  }
  getCoinBalancesOwnedByAddress(address, typeArg) {
    return __async(this, null, function* () {
      const objects = yield this.getObjectsOwnedByAddress(address);
      const coinIds = objects.filter(
        (obj) => Coin.isCoin(obj) && (typeArg === void 0 || typeArg === Coin.getCoinTypeArg(obj))
      ).map((c) => c.objectId);
      return yield this.getObjectBatch(coinIds);
    });
  }
  selectCoinsWithBalanceGreaterThanOrEqual(_0, _1) {
    return __async(this, arguments, function* (address, amount, typeArg = SUI_TYPE_ARG, exclude = []) {
      const coinsStruct = yield this.getCoins(address, typeArg);
      const coinIds = coinsStruct.data.map((c) => c.coinObjectId);
      const coins = yield this.getObjectBatch(coinIds);
      return yield Coin.selectCoinsWithBalanceGreaterThanOrEqual(
        coins,
        amount,
        exclude
      );
    });
  }
  selectCoinSetWithCombinedBalanceGreaterThanOrEqual(_0, _1) {
    return __async(this, arguments, function* (address, amount, typeArg = SUI_TYPE_ARG, exclude = []) {
      const coinsStruct = yield this.getCoins(address, typeArg);
      const coinIds = coinsStruct.data.map((c) => c.coinObjectId);
      const coins = yield this.getObjectBatch(coinIds);
      return yield Coin.selectCoinSetWithCombinedBalanceGreaterThanOrEqual(
        coins,
        amount,
        exclude
      );
    });
  }
  getObject(objectId) {
    return __async(this, null, function* () {
      try {
        if (!objectId || !isValidSuiObjectId(normalizeSuiObjectId(objectId))) {
          throw new Error("Invalid Sui Object id");
        }
        return yield this.client.requestWithType(
          "sui_getObject",
          [objectId],
          GetObjectDataResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error fetching object info: ${err} for id ${objectId}`);
      }
    });
  }
  getObjectRef(objectId) {
    return __async(this, null, function* () {
      const resp = yield this.getObject(objectId);
      return getObjectReference(resp);
    });
  }
  getObjectBatch(objectIds) {
    return __async(this, null, function* () {
      try {
        const requests = objectIds.map((id) => {
          if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
            throw new Error(`Invalid Sui Object id ${id}`);
          }
          return {
            method: "sui_getObject",
            args: [id]
          };
        });
        return yield this.client.batchRequestWithType(
          requests,
          GetObjectDataResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching object info: ${err} for ids [${objectIds}]`
        );
      }
    });
  }
  getTransactions(query, cursor = null, limit = null, order = "descending") {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getTransactions",
          [query, cursor, limit, order === "descending"],
          PaginatedTransactionDigests,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting transactions for query: ${err} for query ${query}`
        );
      }
    });
  }
  getTransactionsForObject(objectID, descendingOrder = true) {
    return __async(this, null, function* () {
      const requests = [
        {
          method: "sui_getTransactions",
          args: [{ InputObject: objectID }, null, null, descendingOrder]
        },
        {
          method: "sui_getTransactions",
          args: [{ MutatedObject: objectID }, null, null, descendingOrder]
        }
      ];
      try {
        if (!objectID || !isValidSuiObjectId(normalizeSuiObjectId(objectID))) {
          throw new Error("Invalid Sui Object id");
        }
        const results = yield this.client.batchRequestWithType(
          requests,
          PaginatedTransactionDigests,
          this.options.skipDataValidation
        );
        return [...results[0].data, ...results[1].data];
      } catch (err) {
        throw new Error(
          `Error getting transactions for object: ${err} for id ${objectID}`
        );
      }
    });
  }
  getTransactionsForAddress(addressID, descendingOrder = true) {
    return __async(this, null, function* () {
      const requests = [
        {
          method: "sui_getTransactions",
          args: [{ ToAddress: addressID }, null, null, descendingOrder]
        },
        {
          method: "sui_getTransactions",
          args: [{ FromAddress: addressID }, null, null, descendingOrder]
        }
      ];
      try {
        if (!addressID || !isValidSuiAddress(normalizeSuiAddress(addressID))) {
          throw new Error("Invalid Sui address");
        }
        const results = yield this.client.batchRequestWithType(
          requests,
          PaginatedTransactionDigests,
          this.options.skipDataValidation
        );
        return [...results[0].data, ...results[1].data];
      } catch (err) {
        throw new Error(
          `Error getting transactions for address: ${err} for id ${addressID}`
        );
      }
    });
  }
  getTransactionWithEffects(digest) {
    return __async(this, null, function* () {
      try {
        if (!isValidTransactionDigest(digest)) {
          throw new Error("Invalid Transaction digest");
        }
        const resp = yield this.client.requestWithType(
          "sui_getTransaction",
          [digest],
          SuiTransactionResponse,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting transaction with effects: ${err} for digest ${digest}`
        );
      }
    });
  }
  getTransactionWithEffectsBatch(digests) {
    return __async(this, null, function* () {
      try {
        const requests = digests.map((d) => {
          if (!isValidTransactionDigest(d)) {
            throw new Error(`Invalid Transaction digest ${d}`);
          }
          return {
            method: "sui_getTransaction",
            args: [d]
          };
        });
        return yield this.client.batchRequestWithType(
          requests,
          SuiTransactionResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting transaction effects: ${err} for digests [${digests}]`
        );
      }
    });
  }
  executeTransaction(txnBytes, signature, requestType = "WaitForEffectsCert") {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_executeTransactionSerializedSig",
          [
            typeof txnBytes === "string" ? txnBytes : toB646(txnBytes),
            signature,
            requestType
          ],
          SuiExecuteTransactionResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error executing transaction with request type: ${err}`);
      }
    });
  }
  getTotalTransactionNumber() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getTotalTransactionNumber",
          [],
          number11(),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error fetching total transaction number: ${err}`);
      }
    });
  }
  getTransactionDigestsInRange(start, end) {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getTransactionsInRange",
          [start, end],
          GetTxnDigestsResponse,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error fetching transaction digests in range: ${err} for range ${start}-${end}`
        );
      }
    });
  }
  getReferenceGasPrice() {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getReferenceGasPrice",
          [],
          number11(),
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(`Error getting the reference gas price ${err}`);
      }
    });
  }
  getDelegatedStakes(address) {
    return __async(this, null, function* () {
      try {
        if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {
          throw new Error("Invalid Sui address");
        }
        const resp = yield this.client.requestWithType(
          "sui_getDelegatedStakes",
          [address],
          array9(DelegatedStake),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error in getDelegatedStake: ${err}`);
      }
    });
  }
  getValidators() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getValidators",
          [],
          array9(ValidatorMetaData),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error in getValidators: ${err}`);
      }
    });
  }
  getSuiSystemState() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getSuiSystemState",
          [],
          SuiSystemState,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(`Error in getSuiSystemState: ${err}`);
      }
    });
  }
  getEvents(query, cursor, limit, order = "descending") {
    return __async(this, null, function* () {
      try {
        return yield this.client.requestWithType(
          "sui_getEvents",
          [query, cursor, limit, order === "descending"],
          PaginatedEvents,
          this.options.skipDataValidation
        );
      } catch (err) {
        throw new Error(
          `Error getting events for query: ${err} for query ${query}`
        );
      }
    });
  }
  subscribeEvent(filter, onMessage) {
    return __async(this, null, function* () {
      return this.wsClient.subscribeEvent(filter, onMessage);
    });
  }
  unsubscribeEvent(id) {
    return __async(this, null, function* () {
      return this.wsClient.unsubscribeEvent(id);
    });
  }
  devInspectTransaction(sender, tx, gasPrice = null, epoch = null) {
    return __async(this, null, function* () {
      try {
        let devInspectTxBytes;
        if (typeof tx === "string") {
          devInspectTxBytes = tx;
        } else if (tx instanceof Uint8Array) {
          devInspectTxBytes = toB646(tx);
        } else {
          devInspectTxBytes = toB646(
            yield new LocalTxnDataSerializer(this).serializeToBytesWithoutGasInfo(
              sender,
              tx
            )
          );
        }
        const resp = yield this.client.requestWithType(
          "sui_devInspectTransaction",
          [sender, devInspectTxBytes, gasPrice, epoch],
          DevInspectResults,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error dev inspect transaction with request type: ${err}`
        );
      }
    });
  }
  dryRunTransaction(txBytes) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_dryRunTransaction",
          [toB646(txBytes)],
          TransactionEffects,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error dry running transaction with request type: ${err}`
        );
      }
    });
  }
  getDynamicFields(parent_object_id, cursor = null, limit = null) {
    return __async(this, null, function* () {
      try {
        if (!parent_object_id || !isValidSuiObjectId(normalizeSuiObjectId(parent_object_id))) {
          throw new Error("Invalid Sui Object id");
        }
        const resp = yield this.client.requestWithType(
          "sui_getDynamicFields",
          [parent_object_id, cursor, limit],
          DynamicFieldPage,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting dynamic fields with request type: ${err} for parent_object_id: ${parent_object_id}, cursor: ${cursor} and limit: ${limit}.`
        );
      }
    });
  }
  getDynamicFieldObject(parent_object_id, name) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getDynamicFieldObject",
          [parent_object_id, name],
          GetObjectDataResponse,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting dynamic field object with request type: ${err} for parent_object_id: ${parent_object_id} and name: ${name}.`
        );
      }
    });
  }
  getLatestCheckpointSequenceNumber() {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getLatestCheckpointSequenceNumber",
          [],
          number11(),
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error fetching latest checkpoint sequence number: ${err}`
        );
      }
    });
  }
  getCheckpointSummary(sequence_number) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointSummary",
          [sequence_number],
          CheckpointSummary,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint summary with request type: ${err} for sequence number: ${sequence_number}.`
        );
      }
    });
  }
  getCheckpointSummaryByDigest(digest) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointSummaryByDigest",
          [digest],
          CheckpointSummary,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint summary with request type: ${err} for digest: ${digest}.`
        );
      }
    });
  }
  getCheckpointContents(sequence_number) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointContents",
          [sequence_number],
          CheckpointContents,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint contents with request type: ${err} for sequence number: ${sequence_number}.`
        );
      }
    });
  }
  getCheckpointContentsByDigest(digest) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.client.requestWithType(
          "sui_getCheckpointContentsByDigest",
          [digest],
          CheckpointContents,
          this.options.skipDataValidation
        );
        return resp;
      } catch (err) {
        throw new Error(
          `Error getting checkpoint summary with request type: ${err} for digest: ${digest}.`
        );
      }
    });
  }
  getCommitteeInfo(epoch) {
    return __async(this, null, function* () {
      try {
        const committeeInfo = yield this.client.requestWithType(
          "sui_getCommitteeInfo",
          [epoch],
          CommitteeInfo
        );
        return committeeInfo;
      } catch (error) {
        throw new Error(`Error getCommitteeInfo : ${error}`);
      }
    });
  }
};

// src/providers/json-rpc-provider-with-cache.ts
import { is as is6 } from "superstruct";
var JsonRpcProviderWithCache = class extends JsonRpcProvider {
  constructor() {
    super(...arguments);
    this.objectRefs = /* @__PURE__ */ new Map();
  }
  getObjectsOwnedByAddress(address) {
    return __async(this, null, function* () {
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObjectsOwnedByAddress").call(this, address);
      resp.forEach((r) => this.updateObjectRefCache(r));
      return resp;
    });
  }
  getObject(objectId) {
    return __async(this, null, function* () {
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObject").call(this, objectId);
      this.updateObjectRefCache(resp);
      return resp;
    });
  }
  getObjectRef(objectId, skipCache = false) {
    return __async(this, null, function* () {
      const normalizedId = normalizeSuiObjectId(objectId);
      if (!skipCache && this.objectRefs.has(normalizedId)) {
        return this.objectRefs.get(normalizedId);
      }
      const ref = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObjectRef").call(this, objectId);
      this.updateObjectRefCache(ref);
      return ref;
    });
  }
  getObjectBatch(objectIds) {
    return __async(this, null, function* () {
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "getObjectBatch").call(this, objectIds);
      resp.forEach((r) => this.updateObjectRefCache(r));
      return resp;
    });
  }
  executeTransaction(txnBytes, signature, requestType = "WaitForEffectsCert") {
    return __async(this, null, function* () {
      if (requestType !== "WaitForEffectsCert") {
        console.warn(
          `It's not recommended to use JsonRpcProviderWithCache with the request type other than 'WaitForEffectsCert' for executeTransaction. Using the '${requestType}' may result in stale cache and a failure in subsequent transactions.`
        );
      }
      const resp = yield __superGet(JsonRpcProviderWithCache.prototype, this, "executeTransaction").call(
        this,
        txnBytes,
        signature,
        requestType
      );
      const effects = getTransactionEffects(resp);
      if (effects != null) {
        this.updateObjectRefCacheFromTransactionEffects(effects);
      }
      return resp;
    });
  }
  updateObjectRefCache(newData) {
    if (newData == null) {
      return;
    }
    const ref = is6(newData, SuiObjectRef) ? newData : getObjectReference(newData);
    if (ref != null) {
      this.objectRefs.set(ref.objectId, ref);
    }
  }
  updateObjectRefCacheFromTransactionEffects(effects) {
    var _a, _b, _c, _d, _e;
    (_a = effects.created) == null ? void 0 : _a.forEach((r) => this.updateObjectRefCache(r.reference));
    (_b = effects.mutated) == null ? void 0 : _b.forEach((r) => this.updateObjectRefCache(r.reference));
    (_c = effects.unwrapped) == null ? void 0 : _c.forEach((r) => this.updateObjectRefCache(r.reference));
    (_d = effects.wrapped) == null ? void 0 : _d.forEach((r) => this.updateObjectRefCache(r));
    (_e = effects.deleted) == null ? void 0 : _e.forEach((r) => this.objectRefs.delete(r.objectId));
  }
};

// src/signers/txn-data-serializers/rpc-txn-data-serializer.ts
import { fromB64 as fromB645 } from "@mysten/bcs";
var RpcTxnDataSerializer = class {
  constructor(endpoint, skipDataValidation = false) {
    this.skipDataValidation = skipDataValidation;
    this.client = new JsonRpcClient(endpoint);
  }
  serializeToBytes(signerAddress, unserializedTxn, mode = "Commit") {
    return __async(this, null, function* () {
      let endpoint;
      let args;
      if (!unserializedTxn.data.gasBudget) {
        throw new Error("serializeToBytes requires a valid gas budget");
      }
      switch (unserializedTxn.kind) {
        case "transferObject":
          const t = unserializedTxn.data;
          endpoint = "sui_transferObject";
          args = [
            signerAddress,
            t.objectId,
            t.gasPayment,
            t.gasBudget,
            t.recipient
          ];
          break;
        case "transferSui":
          const transferSui = unserializedTxn.data;
          endpoint = "sui_transferSui";
          args = [
            signerAddress,
            transferSui.suiObjectId,
            transferSui.gasBudget,
            transferSui.recipient,
            transferSui.amount
          ];
          break;
        case "pay":
          const pay = unserializedTxn.data;
          endpoint = "sui_pay";
          args = [
            signerAddress,
            pay.inputCoins,
            pay.recipients,
            pay.amounts,
            pay.gasPayment,
            pay.gasBudget
          ];
          break;
        case "paySui":
          const paySui = unserializedTxn.data;
          endpoint = "sui_paySui";
          args = [
            signerAddress,
            paySui.inputCoins,
            paySui.recipients,
            paySui.amounts,
            paySui.gasBudget
          ];
          break;
        case "payAllSui":
          const payAllSui = unserializedTxn.data;
          endpoint = "sui_payAllSui";
          args = [
            signerAddress,
            payAllSui.inputCoins,
            payAllSui.recipient,
            payAllSui.gasBudget
          ];
          break;
        case "moveCall":
          const moveCall = unserializedTxn.data;
          for (const arg of moveCall.arguments) {
            if (isPureArg(arg)) {
              throw new Error(
                "PureArg is not allowed as argument in RpcTxnDataSerializer. Please use LocalTxnDataSerializer instead."
              );
            }
          }
          endpoint = "sui_moveCall";
          args = [
            signerAddress,
            moveCall.packageObjectId,
            moveCall.module,
            moveCall.function,
            moveCall.typeArguments,
            moveCall.arguments,
            moveCall.gasPayment,
            moveCall.gasBudget,
            mode
          ];
          break;
        case "mergeCoin":
          const mergeCoin = unserializedTxn.data;
          endpoint = "sui_mergeCoins";
          args = [
            signerAddress,
            mergeCoin.primaryCoin,
            mergeCoin.coinToMerge,
            mergeCoin.gasPayment,
            mergeCoin.gasBudget
          ];
          break;
        case "splitCoin":
          const splitCoin = unserializedTxn.data;
          endpoint = "sui_splitCoin";
          args = [
            signerAddress,
            splitCoin.coinObjectId,
            splitCoin.splitAmounts,
            splitCoin.gasPayment,
            splitCoin.gasBudget
          ];
          break;
        case "publish":
          const publish = unserializedTxn.data;
          endpoint = "sui_publish";
          args = [
            signerAddress,
            publish.compiledModules,
            publish.gasPayment,
            publish.gasBudget
          ];
          break;
      }
      try {
        const resp = yield this.client.requestWithType(
          endpoint,
          args,
          TransactionBytes,
          this.skipDataValidation
        );
        return fromB645(resp.txBytes);
      } catch (e) {
        throw new Error(
          `Encountered error when calling RpcTxnDataSerialize for a ${unserializedTxn.kind} transaction for address ${signerAddress} for transaction ${JSON.stringify(
            unserializedTxn,
            null,
            2
          )}: ${e}`
        );
      }
    });
  }
};

// src/signers/signer-with-provider.ts
import { fromB64 as fromB646, toB64 as toB647 } from "@mysten/bcs";

// src/providers/void-provider.ts
var VoidProvider = class extends Provider {
  getRpcApiVersion() {
    return __async(this, null, function* () {
      throw this.newError("getRpcApiVersion");
    });
  }
  getReferenceGasPrice() {
    return __async(this, null, function* () {
      throw this.newError("getReferenceGasPrice");
    });
  }
  getSuiSystemState() {
    return __async(this, null, function* () {
      throw this.newError("getSuiSystemState");
    });
  }
  getDelegatedStakes(_address) {
    return __async(this, null, function* () {
      throw this.newError("getDelegatedStakes");
    });
  }
  getValidators() {
    return __async(this, null, function* () {
      throw this.newError("getValidators");
    });
  }
  requestSuiFromFaucet(_recipient, _httpHeaders) {
    return __async(this, null, function* () {
      throw this.newError("requestSuiFromFaucet");
    });
  }
  call(_endpoint, _params) {
    throw this.newError("call");
  }
  getCoins(_owner, _coinType, _cursor, _limit) {
    return __async(this, null, function* () {
      throw this.newError("getCoins");
    });
  }
  getAllCoins(_owner, _cursor, _limit) {
    return __async(this, null, function* () {
      throw this.newError("getAllCoins");
    });
  }
  getBalance(_owner, _coinType) {
    return __async(this, null, function* () {
      throw this.newError("getBalance");
    });
  }
  getAllBalances(_owner) {
    return __async(this, null, function* () {
      throw this.newError("getAllBalances");
    });
  }
  getCoinMetadata(_coinType) {
    return __async(this, null, function* () {
      throw new Error("getCoinMetadata");
    });
  }
  getTotalSupply(_coinType) {
    return __async(this, null, function* () {
      throw new Error("getTotalSupply");
    });
  }
  getObjectsOwnedByAddress(_address) {
    return __async(this, null, function* () {
      throw this.newError("getObjectsOwnedByAddress");
    });
  }
  getGasObjectsOwnedByAddress(_address) {
    return __async(this, null, function* () {
      throw this.newError("getGasObjectsOwnedByAddress");
    });
  }
  getCoinBalancesOwnedByAddress(_address, _typeArg) {
    return __async(this, null, function* () {
      throw this.newError("getCoinBalancesOwnedByAddress");
    });
  }
  selectCoinsWithBalanceGreaterThanOrEqual(_0, _1, _2) {
    return __async(this, arguments, function* (_address, _amount, _typeArg, _exclude = []) {
      throw this.newError("selectCoinsWithBalanceGreaterThanOrEqual");
    });
  }
  selectCoinSetWithCombinedBalanceGreaterThanOrEqual(_address, _amount, _typeArg, _exclude) {
    return __async(this, null, function* () {
      throw this.newError("selectCoinSetWithCombinedBalanceGreaterThanOrEqual");
    });
  }
  getObject(_objectId) {
    return __async(this, null, function* () {
      throw this.newError("getObject");
    });
  }
  getObjectRef(_objectId) {
    return __async(this, null, function* () {
      throw this.newError("getObjectRef");
    });
  }
  getTransaction(_digest) {
    return __async(this, null, function* () {
      throw this.newError("getTransaction");
    });
  }
  executeTransaction(_txnBytes, _signature, _requestType) {
    return __async(this, null, function* () {
      throw this.newError("executeTransaction with request Type");
    });
  }
  devInspectTransaction(_sender, _txn, _gasPrice = null, _epoch = null) {
    throw this.newError("devInspectTransaction");
  }
  dryRunTransaction(_txBytes) {
    throw this.newError("dryRunTransaction");
  }
  getDynamicFields(_parent_object_id, _cursor = null, _limit = null) {
    throw this.newError("getDynamicFields");
  }
  getDynamicFieldObject(_parent_object_id, _name) {
    throw this.newError("getDynamicFieldObject");
  }
  getTotalTransactionNumber() {
    return __async(this, null, function* () {
      throw this.newError("getTotalTransactionNumber");
    });
  }
  getTransactionDigestsInRange(_start, _end) {
    return __async(this, null, function* () {
      throw this.newError("getTransactionDigestsInRange");
    });
  }
  getMoveFunctionArgTypes(_objectId, _moduleName, _functionName) {
    return __async(this, null, function* () {
      throw this.newError("getMoveFunctionArgTypes");
    });
  }
  getNormalizedMoveModulesByPackage(_objectId) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveModulesByPackage");
    });
  }
  getNormalizedMoveModule(_objectId, _moduleName) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveModule");
    });
  }
  getNormalizedMoveFunction(_objectId, _moduleName, _functionName) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveFunction");
    });
  }
  getNormalizedMoveStruct(_objectId, _oduleName, _structName) {
    return __async(this, null, function* () {
      throw this.newError("getNormalizedMoveStruct");
    });
  }
  syncAccountState(_address) {
    return __async(this, null, function* () {
      throw this.newError("syncAccountState");
    });
  }
  subscribeEvent(_filter, _onMessage) {
    return __async(this, null, function* () {
      throw this.newError("subscribeEvent");
    });
  }
  unsubscribeEvent(_id) {
    return __async(this, null, function* () {
      throw this.newError("unsubscribeEvent");
    });
  }
  newError(operation) {
    return new Error(`Please use a valid provider for ${operation}`);
  }
  getTransactions(_query, _cursor, _limit, _order) {
    return __async(this, null, function* () {
      throw this.newError("getTransactions");
    });
  }
  getEvents(_query, _cursor, _limit, _order) {
    return __async(this, null, function* () {
      throw this.newError("getEvents");
    });
  }
  getLatestCheckpointSequenceNumber() {
    return __async(this, null, function* () {
      throw this.newError("getLatestCheckpointSequenceNumber");
    });
  }
  getCheckpointSummary(_sequenceNumber) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointSummary");
    });
  }
  getCheckpointSummaryByDigest(_digest) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointSummaryByDigest");
    });
  }
  getCheckpointContents(_sequenceNumber) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointContents");
    });
  }
  getCheckpointContentsByDigest(_digest) {
    return __async(this, null, function* () {
      throw this.newError("getCheckpointContentsByDigest");
    });
  }
  getCommitteeInfo(_epoch) {
    return __async(this, null, function* () {
      throw this.newError("getCommitteeInfo");
    });
  }
};

// src/utils/intent.ts
var AppId = /* @__PURE__ */ ((AppId2) => {
  AppId2[AppId2["Sui"] = 0] = "Sui";
  return AppId2;
})(AppId || {});
var IntentVersion = /* @__PURE__ */ ((IntentVersion2) => {
  IntentVersion2[IntentVersion2["V0"] = 0] = "V0";
  return IntentVersion2;
})(IntentVersion || {});
var IntentScope = /* @__PURE__ */ ((IntentScope2) => {
  IntentScope2[IntentScope2["TransactionData"] = 0] = "TransactionData";
  IntentScope2[IntentScope2["TransactionEffects"] = 1] = "TransactionEffects";
  IntentScope2[IntentScope2["CheckpointSummary"] = 2] = "CheckpointSummary";
  IntentScope2[IntentScope2["PersonalMessage"] = 3] = "PersonalMessage";
  return IntentScope2;
})(IntentScope || {});
function intentWithScope(scope) {
  return [scope, 0 /* V0 */, 0 /* Sui */];
}
function messageWithIntent(scope, message) {
  const intent = intentWithScope(scope);
  const intentMessage = new Uint8Array(intent.length + message.length);
  intentMessage.set(intent);
  intentMessage.set(message, intent.length);
  return intentMessage;
}

// src/signers/signer-with-provider.ts
var SignerWithProvider = class {
  requestSuiFromFaucet(httpHeaders) {
    return __async(this, null, function* () {
      return this.provider.requestSuiFromFaucet(
        yield this.getAddress(),
        httpHeaders
      );
    });
  }
  constructor(provider, serializer) {
    this.provider = provider || new VoidProvider();
    let endpoint = "";
    let skipDataValidation = false;
    if (this.provider instanceof JsonRpcProvider) {
      endpoint = this.provider.connection.fullnode;
      skipDataValidation = this.provider.options.skipDataValidation;
    }
    this.serializer = serializer || new RpcTxnDataSerializer(endpoint, skipDataValidation);
  }
  signMessage(message) {
    return __async(this, null, function* () {
      return yield this.signData(
        messageWithIntent(3 /* PersonalMessage */, message)
      );
    });
  }
  signTransaction(transaction) {
    return __async(this, null, function* () {
      let transactionBytes;
      if (transaction instanceof Uint8Array || transaction.kind === "bytes") {
        transactionBytes = transaction instanceof Uint8Array ? transaction : transaction.data;
      } else {
        transactionBytes = yield this.serializer.serializeToBytes(
          yield this.getAddress(),
          transaction,
          "Commit"
        );
      }
      const intentMessage = messageWithIntent(
        0 /* TransactionData */,
        transactionBytes
      );
      const signature = yield this.signData(intentMessage);
      return {
        transactionBytes: toB647(transactionBytes),
        signature
      };
    });
  }
  signAndExecuteTransaction(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      const { transactionBytes, signature } = yield this.signTransaction(
        transaction
      );
      return yield this.provider.executeTransaction(
        transactionBytes,
        signature,
        requestType
      );
    });
  }
  getTransactionDigest(tx) {
    return __async(this, null, function* () {
      let txBytes;
      if (tx instanceof Uint8Array || tx.kind === "bytes") {
        txBytes = tx instanceof Uint8Array ? tx : tx.data;
      } else {
        txBytes = yield this.serializer.serializeToBytes(
          yield this.getAddress(),
          tx,
          "DevInspect"
        );
      }
      const version = yield this.provider.getRpcApiVersion();
      const bcs2 = bcsForVersion(version);
      const data = deserializeTransactionBytesToTransactionData(bcs2, txBytes);
      return generateTransactionDigest(data, bcs2);
    });
  }
  devInspectTransaction(tx, gasPrice = null, epoch = null) {
    return __async(this, null, function* () {
      const address = yield this.getAddress();
      return this.provider.devInspectTransaction(address, tx, gasPrice, epoch);
    });
  }
  dryRunTransaction(tx) {
    return __async(this, null, function* () {
      const address = yield this.getAddress();
      let dryRunTxBytes;
      if (typeof tx === "string") {
        dryRunTxBytes = fromB646(tx);
      } else if (tx instanceof Uint8Array) {
        dryRunTxBytes = tx;
      } else {
        switch (tx.kind) {
          case "bytes":
            dryRunTxBytes = tx.data;
            break;
          default:
            dryRunTxBytes = yield this.serializer.serializeToBytes(
              address,
              tx,
              "Commit"
            );
            break;
        }
      }
      return this.provider.dryRunTransaction(dryRunTxBytes);
    });
  }
  transferObject(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "transferObject", data: transaction },
        requestType
      );
    });
  }
  transferSui(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "transferSui", data: transaction },
        requestType
      );
    });
  }
  pay(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "pay", data: transaction },
        requestType
      );
    });
  }
  paySui(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "paySui", data: transaction },
        requestType
      );
    });
  }
  payAllSui(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "payAllSui", data: transaction },
        requestType
      );
    });
  }
  mergeCoin(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "mergeCoin", data: transaction },
        requestType
      );
    });
  }
  splitCoin(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "splitCoin", data: transaction },
        requestType
      );
    });
  }
  executeMoveCall(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "moveCall", data: transaction },
        requestType
      );
    });
  }
  publish(transaction, requestType = "WaitForLocalExecution") {
    return __async(this, null, function* () {
      return this.signAndExecuteTransaction(
        { kind: "publish", data: transaction },
        requestType
      );
    });
  }
  getGasCostEstimation(...args) {
    return __async(this, null, function* () {
      const txEffects = yield this.dryRunTransaction(...args);
      const gasEstimation = getTotalGasUsedUpperBound(txEffects);
      if (typeof gasEstimation === "undefined") {
        throw new Error("Failed to estimate the gas cost from transaction");
      }
      return gasEstimation;
    });
  }
};

// src/signers/raw-signer.ts
var RawSigner = class extends SignerWithProvider {
  constructor(keypair, provider, serializer) {
    super(provider, serializer);
    this.keypair = keypair;
  }
  getAddress() {
    return __async(this, null, function* () {
      return this.keypair.getPublicKey().toSuiAddress();
    });
  }
  signData(data) {
    return __async(this, null, function* () {
      const pubkey = this.keypair.getPublicKey();
      const signature = this.keypair.signData(data, false);
      const signatureScheme = this.keypair.getKeyScheme();
      return toSerializedSignature({
        signatureScheme,
        signature,
        pubKey: pubkey
      });
    });
  }
  connect(provider) {
    return new RawSigner(this.keypair, provider);
  }
};

// src/utils/format.ts
var ELLIPSIS = "\u2026";
function formatAddress(address) {
  const offset = address.startsWith("0x") ? 2 : 0;
  return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(
    -4
  )}`;
}
function formatDigest(digest) {
  return `${digest.slice(0, 10)}${ELLIPSIS}`;
}

// src/utils/verify.ts
import { fromB64 as fromB647 } from "@mysten/bcs";
import nacl3 from "tweetnacl";
import * as secp2 from "@noble/secp256k1";
function verifyMessage(message, serializedSignature) {
  return __async(this, null, function* () {
    const signature = fromSerializedSignature(serializedSignature);
    const messageBytes = messageWithIntent(
      3 /* PersonalMessage */,
      typeof message === "string" ? fromB647(message) : message
    );
    switch (signature.signatureScheme) {
      case "ED25519":
        return nacl3.sign.detached.verify(
          messageBytes,
          signature.signature,
          signature.pubKey.toBytes()
        );
      case "Secp256k1":
        return secp2.verify(
          secp2.Signature.fromCompact(signature.signature),
          yield secp2.utils.sha256(messageBytes),
          signature.pubKey.toBytes()
        );
      default:
        throw new Error(
          `Unknown signature scheme: "${signature.signatureScheme}"`
        );
    }
  });
}

// src/framework/sui-system-state.ts
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiAddress("0x5");
var SUI_SYSTEM_MODULE_NAME = "sui_system";
var ADD_DELEGATION_MUL_COIN_FUN_NAME = "request_add_delegation_mul_coin";
var ADD_DELEGATION_LOCKED_COIN_FUN_NAME = "request_add_delegation_mul_locked_coin";
var WITHDRAW_DELEGATION_FUN_NAME = "request_withdraw_delegation";
var SuiSystemStateUtil = class {
  static newRequestAddDelegationTxn(coins, amount, validatorAddress, gasBudget, gasPayment, gasPrice) {
    return __async(this, null, function* () {
      return {
        kind: "moveCall",
        data: {
          packageObjectId: SUI_FRAMEWORK_ADDRESS,
          module: SUI_SYSTEM_MODULE_NAME,
          function: ADD_DELEGATION_MUL_COIN_FUN_NAME,
          typeArguments: [],
          arguments: [
            SUI_SYSTEM_STATE_OBJECT_ID,
            coins,
            [String(amount)],
            validatorAddress
          ],
          gasBudget,
          gasPayment,
          gasPrice
        }
      };
    });
  }
  static newRequestWithdrawlDelegationTxn(delegation, stakedCoinId, gasBudget, gasPayment, gasPrice) {
    return __async(this, null, function* () {
      return {
        kind: "moveCall",
        data: {
          packageObjectId: SUI_FRAMEWORK_ADDRESS,
          module: SUI_SYSTEM_MODULE_NAME,
          function: WITHDRAW_DELEGATION_FUN_NAME,
          typeArguments: [],
          arguments: [SUI_SYSTEM_STATE_OBJECT_ID, delegation, stakedCoinId],
          gasBudget,
          gasPayment,
          gasPrice
        }
      };
    });
  }
};

// src/index.ts
import { fromB64 as fromB648, toB64 as toB648 } from "@mysten/bcs";
import { is as is7, assert } from "superstruct";
export {
  ADD_DELEGATION_LOCKED_COIN_FUN_NAME,
  ADD_DELEGATION_MUL_COIN_FUN_NAME,
  ActiveDelegationStatus,
  ActiveFields,
  AppId,
  AuthorityName,
  AuthorityQuorumSignInfo,
  AuthoritySignature,
  Balance,
  BalanceChangeType,
  COIN_TYPE_ARG_REGEX,
  CertifiedTransaction,
  CheckPointContentsDigest,
  CheckpointContents,
  CheckpointDigest,
  CheckpointEvent,
  CheckpointSummary,
  Coin,
  CoinBalance,
  CoinBalanceChangeEvent,
  CoinMetadataStruct,
  CoinStruct,
  CoinSupply,
  CommitteeInfo,
  Connection,
  Contents,
  ContentsFields,
  ContentsFieldsWithdraw,
  DEFAULT_CLIENT_OPTIONS,
  DEFAULT_ED25519_DERIVATION_PATH,
  DEFAULT_SECP256K1_DERIVATION_PATH,
  DelegatedStake,
  Delegation,
  DelegationStakingPool,
  DelegationStakingPoolFields,
  DeleteObjectEvent,
  DevInspectResults,
  Ed25519Keypair,
  Ed25519PublicKey,
  EpochChangeEvent,
  EpochId,
  ErrorResponse,
  EventId,
  ExecutionStatus,
  ExecutionStatusType,
  FaucetRateLimitError,
  GasCostSummary2 as GasCostSummary,
  GenericAuthoritySignature,
  Genesis,
  GetObjectDataResponse,
  GetOwnedObjectsResponse,
  GetTxnDigestsResponse,
  ID_STRUCT_NAME,
  IntentScope,
  IntentVersion,
  JsonRpcClient,
  JsonRpcProvider,
  JsonRpcProviderWithCache,
  LEGACY_PRIVATE_KEY_SIZE,
  LocalTxnDataSerializer,
  MIST_PER_SUI,
  MOVE_STDLIB_ADDRESS,
  MoveActiveValidator,
  MoveActiveValidatorFields,
  MoveCall,
  MoveDelegationStakingPoolFields,
  MoveEvent,
  MoveNextEpochValidatorFields,
  MovePackageContent,
  MoveSuiSystemObject,
  MoveSuiSystemObjectFields,
  MoveValidatorsFieldsClass,
  MutateObjectEvent,
  NewObjectEvent,
  OBJECT_MODULE_NAME,
  ObjectContentFields,
  ObjectId,
  ObjectOwner,
  ObjectStatus,
  ObjectType,
  OwnedObjectRef,
  PAY_JOIN_COIN_FUNC_NAME,
  PAY_MODULE_NAME,
  PAY_SPLIT_COIN_VEC_FUNC_NAME,
  PRIVATE_KEY_SIZE,
  PaginatedCoins,
  PaginatedEvents,
  PaginatedTransactionDigests,
  Parameters,
  ParametersFields,
  Pay,
  PayAllSui,
  PaySui,
  PendingWithdawFields,
  Provider,
  PublishEvent,
  RawSigner,
  RpcTxnDataSerializer,
  SIGNATURE_FLAG_TO_SCHEME,
  SIGNATURE_SCHEME_TO_FLAG,
  SUI_ADDRESS_LENGTH,
  SUI_FRAMEWORK_ADDRESS,
  SUI_SYSTEM_MODULE_NAME,
  SUI_SYSTEM_STATE_OBJECT_ID,
  SUI_TYPE_ARG,
  Secp256k1Keypair,
  Secp256k1PublicKey,
  SequenceNumber,
  SignerWithProvider,
  StakeSubsidy,
  StakeSubsidyFields,
  StakedSui,
  SubscriptionEvent,
  SubscriptionId,
  SuiAddress,
  SuiCertifiedTransactionEffects,
  SuiChangeEpoch,
  SuiConsensusCommitPrologue,
  SuiData,
  SuiEffectsFinalityInfo,
  SuiEvent,
  SuiEventEnvelope,
  SuiExecuteTransactionResponse,
  SuiFinalizedEffects,
  SuiGasData,
  SuiJsonValue,
  SuiMoveAbilitySet,
  SuiMoveFunctionArgType,
  SuiMoveFunctionArgTypes,
  SuiMoveModuleId,
  SuiMoveNormalizedField,
  SuiMoveNormalizedFunction,
  SuiMoveNormalizedModule,
  SuiMoveNormalizedModules,
  SuiMoveNormalizedStruct,
  SuiMoveNormalizedStructType,
  SuiMoveNormalizedType,
  SuiMoveNormalizedTypeParameterType,
  SuiMoveObject,
  SuiMovePackage,
  SuiMoveStructTypeParameter,
  SuiMoveVisibility,
  SuiObject,
  SuiObjectInfo,
  SuiObjectRef,
  SuiPackage,
  SuiParsedMergeCoinResponse,
  SuiParsedPublishResponse,
  SuiParsedSplitCoinResponse,
  SuiParsedTransactionResponse,
  SuiSupplyFields,
  SuiSystemState,
  SuiSystemStateUtil,
  SuiTransaction,
  SuiTransactionData,
  SuiTransactionKind,
  SuiTransactionResponse,
  SuiTransferSui,
  SystemParameters,
  TARGETED_RPC_VERSION,
  TRANSACTION_DATA_TYPE_TAG,
  TransactionBytes,
  TransactionDigest,
  TransactionEffects,
  TransactionEffectsDigest,
  TransferObject,
  TransferObjectEvent,
  TypeTagSerializer,
  UID_STRUCT_NAME,
  ValidResponse,
  Validator,
  ValidatorMetaData,
  ValidatorPair,
  ValidatorSet,
  WITHDRAW_DELEGATION_FUN_NAME,
  WebsocketClient,
  assert,
  bcs,
  bcsForVersion,
  bytesEqual,
  deserializeTransactionBytesToTransactionData,
  devnetConnection,
  extractMutableReference,
  extractReference,
  extractStructTag,
  formatAddress,
  formatDigest,
  fromB648 as fromB64,
  fromExportedKeypair,
  fromSerializedSignature,
  generateTransactionDigest,
  getCertifiedTransaction,
  getChangeEpochTransaction,
  getCoinAfterMerge,
  getCoinAfterSplit,
  getConsensusCommitPrologueTransaction,
  getCreatedObjects,
  getEvents,
  getExecutionStatus,
  getExecutionStatusError,
  getExecutionStatusGasSummary,
  getExecutionStatusType,
  getGasData,
  getMoveCallTransaction,
  getMoveObject,
  getMoveObjectType,
  getMovePackageContent,
  getNewlyCreatedCoinRefsAfterSplit,
  getNewlyCreatedCoinsAfterSplit,
  getObjectDeletedResponse,
  getObjectExistsResponse,
  getObjectFields,
  getObjectId,
  getObjectNotExistsResponse,
  getObjectOwner,
  getObjectPreviousTransactionDigest,
  getObjectReference,
  getObjectType,
  getObjectVersion,
  getParsedMergeCoinResponse,
  getParsedPublishResponse,
  getParsedSplitCoinResponse,
  getPayAllSuiTransaction,
  getPaySuiTransaction,
  getPayTransaction,
  getPublishTransaction,
  getSharedObjectInitialVersion,
  getTimestampFromTransactionResponse,
  getTotalGasUsed,
  getTotalGasUsedUpperBound,
  getTransactionData,
  getTransactionDigest,
  getTransactionEffects,
  getTransactionGasBudget,
  getTransactionGasObject,
  getTransactionGasPrice,
  getTransactionKindName,
  getTransactionSender,
  getTransactionSignature,
  getTransactions,
  getTransferObjectTransaction,
  getTransferSuiAmount,
  getTransferSuiTransaction,
  getWebsocketUrl,
  hasPublicTransfer,
  is7 as is,
  isImmutableObject,
  isPureArg,
  isSharedObject,
  isValidBIP32Path,
  isValidHardenedPath,
  isValidSuiAddress,
  isValidSuiObjectId,
  isValidTransactionDigest,
  localnetConnection,
  messageWithIntent,
  mnemonicToSeed,
  mnemonicToSeedHex,
  normalizeSuiAddress,
  normalizeSuiObjectId,
  parseVersionFromString,
  publicKeyFromSerialized,
  requestSuiFromFaucet,
  toB648 as toB64,
  toSerializedSignature,
  verifyMessage,
  versionToString
};
//# sourceMappingURL=index.mjs.map